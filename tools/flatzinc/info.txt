--------------------------------------------------------------------------------
Profile data file 'callgrind.out.248076' (creator: callgrind-3.18.1)
--------------------------------------------------------------------------------
I1 cache: 
D1 cache: 
LL cache: 
Timerange: Basic block 0 - 15549838744
Trigger: Program termination
Profiled target:  ./fzn-gecode --use-pbs ../../data/hej.fzn (PID 248076, part 1)
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Thresholds:       99
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                      
--------------------------------------------------------------------------------
89,413,284,728 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                      file:function
--------------------------------------------------------------------------------
8,755,989,249 ( 9.79%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/distinct/bnd.hpp:Gecode::Int::Distinct::Bnd<Gecode::Int::IntView>::propagate(Gecode::Space&, int const&) [/usr/local/lib/libgecodeint.so.51.0]
3,468,880,842 ( 3.88%)  /home/dexter/master-thesis/gecode-dexter/gecode/int/var-imp/int.cpp:Gecode::Int::IntVarImp::perform_copy(Gecode::Space&) [/usr/local/lib/libgecodeint.so.51.0]
3,029,359,714 ( 3.39%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::Int::IntVarImp::perform_copy(Gecode::Space&)
2,805,786,471 ( 3.14%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/linear/int-nary.hpp:Gecode::ExecStatus Gecode::Int::Linear::prop_bnd<int, Gecode::Int::ScaleView<int, unsigned int>, Gecode::Int::ScaleView<int, unsigned int> >(Gecode::Space&, int, Gecode::Propagator&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, int&) [/usr/local/lib/libgecodeint.so.51.0]
2,787,756,755 ( 3.12%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::Space::_clone()
2,565,169,204 ( 2.87%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/data/array.hpp:Gecode::FlatZinc::FlatZincSpace::FlatZincSpace(Gecode::FlatZinc::FlatZincSpace&)
2,527,067,077 ( 2.83%)  ./nptl/./nptl/pthread_mutex_lock.c:pthread_mutex_lock@@GLIBC_2.2.5 [/usr/lib/x86_64-linux-gnu/libc.so.6]
1,891,749,055 ( 2.12%)  /home/dexter/master-thesis/gecode-dexter/gecode/kernel/core.cpp:Gecode::Space::status(Gecode::StatusStatistics&) [/usr/local/lib/libgecodekernel.so.51.0]
1,778,808,695 ( 1.99%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/data/array.hpp:Gecode::ViewArray<Gecode::Int::IntView>::update(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&) [/usr/local/lib/libgecodeint.so.51.0]
1,732,846,474 ( 1.94%)  ./nptl/./nptl/pthread_mutex_unlock.c:pthread_mutex_unlock@@GLIBC_2.2.5 [/usr/lib/x86_64-linux-gnu/libc.so.6]
1,627,279,210 ( 1.82%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/var.hpp:Gecode::FlatZinc::FlatZincSpace::FlatZincSpace(Gecode::FlatZinc::FlatZincSpace&)
1,624,763,652 ( 1.82%)  /home/dexter/master-thesis/gecode-dexter/gecode/kernel/core.cpp:Gecode::Space::_clone() [/usr/local/lib/libgecodekernel.so.51.0]
1,525,967,265 ( 1.71%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::Int::IntVarImp::eq_full(Gecode::Space&, int)
1,484,242,624 ( 1.66%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/view/scale.hpp:Gecode::ExecStatus Gecode::Int::Linear::prop_bnd<int, Gecode::Int::ScaleView<int, unsigned int>, Gecode::Int::ScaleView<int, unsigned int> >(Gecode::Space&, int, Gecode::Propagator&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, int&)
1,395,133,335 ( 1.56%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms [/usr/lib/x86_64-linux-gnu/libc.so.6]
1,242,596,030 ( 1.39%)  /home/dexter/master-thesis/gecode-dexter/gecode/int/var-imp/int.cpp:Gecode::Int::IntVarImp::nq_full(Gecode::Space&, int) [/usr/local/lib/libgecodeint.so.51.0]
1,146,137,935 ( 1.28%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/manager.hpp:Gecode::Int::IntVarImp::perform_copy(Gecode::Space&)
1,069,539,736 ( 1.20%)  ./malloc/./malloc/malloc.c:_int_free [/usr/lib/x86_64-linux-gnu/libc.so.6]
1,046,705,478 ( 1.17%)  /home/dexter/master-thesis/gecode-dexter/gecode/kernel/core.cpp:Gecode::Space::_commit(Gecode::Choice const&, unsigned int) [/usr/local/lib/libgecodekernel.so.51.0]
1,039,068,523 ( 1.16%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/linear/int-nary.hpp:void Gecode::Int::Linear::bounds_n<int, Gecode::Int::ScaleView<int, unsigned int> >(int, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, int&, int&, int&) [/usr/local/lib/libgecodeint.so.51.0]
1,034,772,694 ( 1.16%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/data/array.hpp:Gecode::ExecStatus Gecode::Int::Linear::prop_bnd<int, Gecode::Int::ScaleView<int, unsigned int>, Gecode::Int::ScaleView<int, unsigned int> >(Gecode::Space&, int, Gecode::Propagator&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, int&)
  975,089,268 ( 1.09%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/region.hpp:Gecode::Int::Distinct::Bnd<Gecode::Int::IntView>::propagate(Gecode::Space&, int const&)
  906,404,430 ( 1.01%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/count/int-eq.hpp:Gecode::Int::Count::EqInt<Gecode::Int::IntView, Gecode::Int::ConstIntView>::propagate(Gecode::Space&, int const&) [/usr/local/lib/libgecodeint.so.51.0]
  868,319,909 ( 0.97%)  /home/dexter/master-thesis/gecode-dexter/gecode/int/var-imp/int.cpp:Gecode::Int::IntVarImp::lq_full(Gecode::Space&, int) [/usr/local/lib/libgecodeint.so.51.0]
  858,806,459 ( 0.96%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/data/array.hpp:Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >::update(Gecode::Space&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&) [/usr/local/lib/libgecodeint.so.51.0]
  838,333,300 ( 0.94%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/var-imp/int.hpp:Gecode::Int::IntVarImp::perform_copy(Gecode::Space&)
  779,908,410 ( 0.87%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/var-imp/int.hpp:Gecode::ViewArray<Gecode::Int::IntView>::update(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&)
  777,566,938 ( 0.87%)  /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/flatzinc.cpp:Gecode::FlatZinc::FlatZincSpace::FlatZincSpace(Gecode::FlatZinc::FlatZincSpace&) [/usr/local/lib/libgecodeflatzinc.so.51.0]
  771,514,067 ( 0.86%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view-sel.hpp:Gecode::ViewSelChoose<Gecode::ChooseMax, Gecode::Int::Branch::MeritAFCSize<Gecode::Int::IntView> >::select(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&, int) [/usr/local/lib/libgecodeint.so.51.0]
  769,595,184 ( 0.86%)  ./elf/../sysdeps/x86_64/tls_get_addr.S:__tls_get_addr [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
  768,901,441 ( 0.86%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::ViewSelChoose<Gecode::ChooseMax, Gecode::Int::Branch::MeritAFCSize<Gecode::Int::IntView> >::select(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&, int)
  765,982,690 ( 0.86%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::Int::IntVarImp::nq_full(Gecode::Space&, int)
  761,894,509 ( 0.85%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/view.hpp:Gecode::ViewArray<Gecode::Int::IntView>::update(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&)
  752,275,387 ( 0.84%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/distinct/val.hpp:Gecode::ExecStatus Gecode::Int::Distinct::prop_val<Gecode::Int::IntView, false>(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&) [/usr/local/lib/libgecodeint.so.51.0]
  745,043,794 ( 0.83%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/var-imp/int.hpp:Gecode::ExecStatus Gecode::Int::Linear::prop_bnd<int, Gecode::Int::ScaleView<int, unsigned int>, Gecode::Int::ScaleView<int, unsigned int> >(Gecode::Space&, int, Gecode::Propagator&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, int&)
  738,104,055 ( 0.83%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::Int::IntVarImp::lq_full(Gecode::Space&, int)
  696,786,206 ( 0.78%)  ./malloc/./malloc/malloc.c:malloc [/usr/lib/x86_64-linux-gnu/libc.so.6]
  677,700,644 ( 0.76%)  /home/dexter/master-thesis/gecode-dexter/gecode/int/var-imp/int.cpp:Gecode::Int::IntVarImp::eq_full(Gecode::Space&, int) [/usr/local/lib/libgecodeint.so.51.0]
  663,834,356 ( 0.74%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::Space::status(Gecode::StatusStatistics&)
  586,269,494 ( 0.66%)  /home/dexter/master-thesis/gecode-dexter/gecode/kernel/core.cpp:Gecode::Space::Space(Gecode::Space&) [/usr/local/lib/libgecodekernel.so.51.0]
  577,163,234 ( 0.65%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/var-imp/int.hpp:Gecode::FlatZinc::FlatZincSpace::FlatZincSpace(Gecode::FlatZinc::FlatZincSpace&)
  577,163,002 ( 0.65%)  /home/dexter/master-thesis/gecode-dexter/./gecode/support/marked-pointer.hpp:Gecode::FlatZinc::FlatZincSpace::FlatZincSpace(Gecode::FlatZinc::FlatZincSpace&)
  527,045,528 ( 0.59%)  /home/dexter/master-thesis/gecode-dexter/./gecode/driver/script.hpp:Gecode::Driver::PBSCombinedStop::stop(Gecode::Search::Statistics const&, Gecode::Search::Options const&) [/usr/local/lib/libgecodeflatzinc.so.51.0]
  480,996,660 ( 0.54%)  /home/dexter/master-thesis/gecode-dexter/gecode/kernel/memory/region.cpp:Gecode::Region::pool() [/usr/local/lib/libgecodekernel.so.51.0]
  461,252,009 ( 0.52%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::Int::IntVarImp::gq_full(Gecode::Space&, int)
  447,938,359 ( 0.50%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/linear/int-nary.hpp:void Gecode::Int::Linear::bounds_p<int, Gecode::Int::ScaleView<int, unsigned int> >(int, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, int&, int&, int&) [/usr/local/lib/libgecodeint.so.51.0]
  424,196,303 ( 0.47%)  /home/dexter/master-thesis/gecode-dexter/./gecode/search/seq/path.hpp:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::DFS<Gecode::Search::NoTraceRecorder> >::next()
  413,173,215 ( 0.46%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view-val.hpp:Gecode::ViewValBrancher<Gecode::Int::IntView, 1, int, 2u, Gecode::BrancherNoFilter<Gecode::Int::IntView>, Gecode::BrancherPrint<Gecode::Int::IntView, int> >::commit(Gecode::Space&, Gecode::Choice const&, unsigned int) [/usr/local/lib/libgecodeint.so.51.0]
  405,686,235 ( 0.45%)  /home/dexter/master-thesis/gecode-dexter/./gecode/support/marked-pointer.hpp:Gecode::ViewArray<Gecode::Int::IntView>::update(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&)
  403,370,126 ( 0.45%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/view/rel-test.hpp:Gecode::Int::Count::EqInt<Gecode::Int::IntView, Gecode::Int::ConstIntView>::propagate(Gecode::Space&, int const&)
  401,396,323 ( 0.45%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/var-type.hpp:Gecode::Int::IntVarImp::lq_full(Gecode::Space&, int)
  392,791,083 ( 0.44%)  /home/dexter/master-thesis/gecode-dexter/gecode/kernel/core.cpp:Gecode::Space::~Space() [/usr/local/lib/libgecodekernel.so.51.0]
  385,628,334 ( 0.43%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::Space::_commit(Gecode::Choice const&, unsigned int)
  370,318,081 ( 0.41%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/data/array.hpp:void Gecode::Int::Linear::bounds_n<int, Gecode::Int::ScaleView<int, unsigned int> >(int, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, int&, int&, int&)
  354,702,918 ( 0.40%)  ./malloc/./malloc/malloc.c:free [/usr/lib/x86_64-linux-gnu/libc.so.6]
  353,311,260 ( 0.40%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/manager.hpp:Gecode::Space::Space(Gecode::Space&)
  352,710,776 ( 0.39%)  /home/dexter/master-thesis/gecode-dexter/./gecode/support/marked-pointer.hpp:Gecode::Int::IntVarImp::perform_copy(Gecode::Space&)
  352,710,665 ( 0.39%)  ???:0x0000000004e953f0 [???]
  352,710,600 ( 0.39%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view-val.hpp:Gecode::ViewValBrancher<Gecode::Int::IntView, 1, int, 2u, Gecode::BrancherNoFilter<Gecode::Int::IntView>, Gecode::BrancherPrint<Gecode::Int::IntView, int> >::copy(Gecode::Space&) [/usr/local/lib/libgecodeint.so.51.0]
  345,786,284 ( 0.39%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/data/array.hpp:Gecode::Int::Count::EqInt<Gecode::Int::IntView, Gecode::Int::ConstIntView>::propagate(Gecode::Space&, int const&)
  336,730,539 ( 0.38%)  /home/dexter/master-thesis/gecode-dexter/gecode/int/var-imp/int.cpp:Gecode::Int::IntVarImp::gq_full(Gecode::Space&, int) [/usr/local/lib/libgecodeint.so.51.0]
  336,274,000 ( 0.38%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/manager.hpp:Gecode::Kernel::MemoryManager::alloc_refill(Gecode::Kernel::SharedMemory&, unsigned long)
  334,356,904 ( 0.37%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/var-type.hpp:Gecode::Int::IntVarImp::nq_full(Gecode::Space&, int)
  332,875,773 ( 0.37%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/var-type.hpp:Gecode::Int::IntVarImp::eq_full(Gecode::Space&, int)
  325,022,561 ( 0.36%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/var-imp/int.hpp:Gecode::ViewSelChoose<Gecode::ChooseMax, Gecode::Int::Branch::MeritAFCSize<Gecode::Int::IntView> >::select(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&, int)
  320,664,420 ( 0.36%)  /home/dexter/master-thesis/gecode-dexter/gecode/kernel/memory/region.cpp:Gecode::Region::Pool::chunk() [/usr/local/lib/libgecodekernel.so.51.0]
  320,199,302 ( 0.36%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/var-imp/int.hpp:Gecode::ValSelCommit<Gecode::Int::Branch::ValSelMin<Gecode::Int::IntView>, Gecode::Int::Branch::ValCommitEq<Gecode::Int::IntView> >::commit(Gecode::Space&, unsigned int, Gecode::Int::IntView, int, int)
  312,360,553 ( 0.35%)  /home/dexter/master-thesis/gecode-dexter/gecode/search/seq/rbs.cpp:Gecode::Search::Seq::RestartStop::stop(Gecode::Search::Statistics const&, Gecode::Search::Options const&) [/usr/local/lib/libgecodesearch.so.51.0]
  290,332,514 ( 0.32%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/manager.hpp:Gecode::Int::IntVarImp::eq_full(Gecode::Space&, int)
  288,581,220 ( 0.32%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view-val.hpp:Gecode::ViewValBrancher<Gecode::Int::IntView, 1, int, 2u, Gecode::BrancherNoFilter<Gecode::Int::IntView>, Gecode::BrancherPrint<Gecode::Int::IntView, int> >::dispose(Gecode::Space&) [/usr/local/lib/libgecodeint.so.51.0]
  287,474,618 ( 0.32%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/view/scale.hpp:void Gecode::Int::Linear::bounds_n<int, Gecode::Int::ScaleView<int, unsigned int> >(int, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, int&, int&, int&)
  284,163,763 ( 0.32%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/var-imp/int.hpp:Gecode::Int::IntVarImp::nq_full(Gecode::Space&, int)
  273,857,542 ( 0.31%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::Space::Space(Gecode::Space&)
  273,610,510 ( 0.31%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/var-imp/int.hpp:Gecode::Int::Distinct::Bnd<Gecode::Int::IntView>::propagate(Gecode::Space&, int const&)
  264,532,950 ( 0.30%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view.hpp:Gecode::ViewValBrancher<Gecode::Int::IntView, 1, int, 2u, Gecode::BrancherNoFilter<Gecode::Int::IntView>, Gecode::BrancherPrint<Gecode::Int::IntView, int> >::copy(Gecode::Space&)
  262,870,681 ( 0.29%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/var-imp/int.hpp:Gecode::Int::Count::EqInt<Gecode::Int::IntView, Gecode::Int::ConstIntView>::propagate(Gecode::Space&, int const&)
  259,616,922 ( 0.29%)  /usr/include/c++/11/bits/align.h:Gecode::Int::IntVarImp::eq_full(Gecode::Space&, int)
  256,368,697 ( 0.29%)  /home/dexter/master-thesis/gecode-dexter/./gecode/search/seq/dfs.hpp:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::DFS<Gecode::Search::NoTraceRecorder> >::next()
  250,526,736 ( 0.28%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/var-imp/int.hpp:Gecode::Int::IntVarImp::lq_full(Gecode::Space&, int)
  249,711,452 ( 0.28%)  /home/dexter/master-thesis/gecode-dexter/./gecode/support/dynamic-stack.hpp:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::DFS<Gecode::Search::NoTraceRecorder> >::next()
  243,516,009 ( 0.27%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >::update(Gecode::Space&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&)
  240,498,315 ( 0.27%)  /home/dexter/master-thesis/gecode-dexter/gecode/kernel/memory/region.cpp:Gecode::Region::Pool::chunk(Gecode::Region::Chunk*) [/usr/local/lib/libgecodekernel.so.51.0]
  240,484,560 ( 0.27%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/linear/int-nary.hpp:Gecode::Int::Linear::Eq<int, Gecode::Int::ScaleView<int, unsigned int>, Gecode::Int::ScaleView<int, unsigned int> >::copy(Gecode::Space&) [/usr/local/lib/libgecodeint.so.51.0]
  233,266,855 ( 0.26%)  /home/dexter/master-thesis/gecode-dexter/gecode/kernel/core.cpp:Gecode::Space::choice() [/usr/local/lib/libgecodekernel.so.51.0]
  224,449,883 ( 0.25%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/manager.hpp:Gecode::Space::~Space()
  220,359,048 ( 0.25%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/val-sel-commit.hpp:Gecode::ValSelCommit<Gecode::Int::Branch::ValSelMin<Gecode::Int::IntView>, Gecode::Int::Branch::ValCommitEq<Gecode::Int::IntView> >::commit(Gecode::Space&, unsigned int, Gecode::Int::IntView, int, int) [/usr/local/lib/libgecodeint.so.51.0]
  216,436,156 ( 0.24%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/shared-object.hpp:Gecode::FlatZinc::FlatZincSpace::FlatZincSpace(Gecode::FlatZinc::FlatZincSpace&)
  216,435,945 ( 0.24%)  /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/flatzinc.cpp:Gecode::FlatZinc::FlatZincSpace::~FlatZincSpace()'2 [/usr/local/lib/libgecodeflatzinc.so.51.0]
  216,435,915 ( 0.24%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view.hpp:Gecode::ViewValBrancher<Gecode::Int::IntView, 1, int, 2u, Gecode::BrancherNoFilter<Gecode::Int::IntView>, Gecode::BrancherPrint<Gecode::Int::IntView, int> >::dispose(Gecode::Space&)
  205,199,444 ( 0.23%)  /home/dexter/master-thesis/gecode-dexter/./gecode/search/seq/path.hpp:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::BAB<Gecode::Search::NoTraceRecorder> >::next()
  204,810,228 ( 0.23%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/view.hpp:Gecode::ViewSelChoose<Gecode::ChooseMax, Gecode::Int::Branch::MeritAFCSize<Gecode::Int::IntView> >::select(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&, int)
  203,348,869 ( 0.23%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/view/int.hpp:Gecode::ExecStatus Gecode::Int::Linear::prop_bnd<int, Gecode::Int::ScaleView<int, unsigned int>, Gecode::Int::ScaleView<int, unsigned int> >(Gecode::Space&, int, Gecode::Propagator&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, int&)
  202,082,878 ( 0.23%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::Int::Linear::Lin<int, Gecode::Int::ScaleView<int, unsigned int>, Gecode::Int::ScaleView<int, unsigned int>, 1>::cost(Gecode::Space const&, int const&) const
  194,936,339 ( 0.22%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/var-imp/int.hpp:Gecode::ExecStatus Gecode::Int::Distinct::prop_val<Gecode::Int::IntView, false>(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&)
  192,387,741 ( 0.22%)  /home/dexter/master-thesis/gecode-dexter/gecode/kernel/memory/manager.cpp:Gecode::Kernel::SharedMemory::m() [/usr/local/lib/libgecodekernel.so.51.0]
  190,043,520 ( 0.21%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/div.hpp:Gecode::ExecStatus Gecode::Int::Linear::prop_bnd<int, Gecode::Int::ScaleView<int, unsigned int>, Gecode::Int::ScaleView<int, unsigned int> >(Gecode::Space&, int, Gecode::Propagator&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, int&)
  179,132,970 ( 0.20%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/linear/int-nary.hpp:Gecode::Int::Linear::Eq<int, Gecode::Int::ScaleView<int, unsigned int>, Gecode::Int::ScaleView<int, unsigned int> >::propagate(Gecode::Space&, int const&) [/usr/local/lib/libgecodeint.so.51.0]
  178,376,290 ( 0.20%)  /home/dexter/master-thesis/gecode-dexter/./gecode/support/marked-pointer.hpp:Gecode::Space::_clone()
  176,067,498 ( 0.20%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/data/array.hpp:Gecode::Int::Distinct::Bnd<Gecode::Int::IntView>::propagate(Gecode::Space&, int const&)
  171,870,217 ( 0.19%)  ./malloc/./malloc/arena.c:free
  168,917,301 ( 0.19%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view-val.hpp:Gecode::ViewValBrancher<Gecode::Int::IntView, 1, int, 2u, Gecode::BrancherNoFilter<Gecode::Int::IntView>, Gecode::BrancherPrint<Gecode::Int::IntView, int> >::choice(Gecode::Space&) [/usr/local/lib/libgecodeint.so.51.0]
  168,496,168 ( 0.19%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/var-imp/int.hpp:Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >::update(Gecode::Space&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&)
  168,339,465 ( 0.19%)  /home/dexter/master-thesis/gecode-dexter/gecode/kernel/memory/manager.cpp:Gecode::Kernel::MemoryManager::alloc_refill(Gecode::Kernel::SharedMemory&, unsigned long) [/usr/local/lib/libgecodekernel.so.51.0]
  166,162,270 ( 0.19%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/view/int.hpp:Gecode::Int::Distinct::Bnd<Gecode::Int::IntView>::propagate(Gecode::Space&, int const&)
  165,497,944 ( 0.19%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/branch/merit.hpp:Gecode::ViewSelChoose<Gecode::ChooseMax, Gecode::Int::Branch::MeritAFCSize<Gecode::Int::IntView> >::select(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&, int)
  161,913,370 ( 0.18%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/manager.hpp:Gecode::ViewArray<Gecode::Int::IntView>::update(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&)
  157,828,044 ( 0.18%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::Int::Distinct::Bnd<Gecode::Int::IntView>::cost(Gecode::Space const&, int const&) const
  153,770,552 ( 0.17%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/region.hpp:Gecode::ExecStatus Gecode::Int::Distinct::prop_val<Gecode::Int::IntView, false>(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&)
  152,918,610 ( 0.17%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/manager.hpp:Gecode::ViewValBrancher<Gecode::Int::IntView, 1, int, 2u, Gecode::BrancherNoFilter<Gecode::Int::IntView>, Gecode::BrancherPrint<Gecode::Int::IntView, int> >::copy(Gecode::Space&)
  147,322,185 ( 0.16%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/view.hpp:Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >::update(Gecode::Space&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&)
  144,344,930 ( 0.16%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/linear/int-nary.hpp:Gecode::Int::Linear::Lin<int, Gecode::Int::ScaleView<int, unsigned int>, Gecode::Int::ScaleView<int, unsigned int>, 1>::cost(Gecode::Space const&, int const&) const [/usr/local/lib/libgecodeint.so.51.0]
  144,290,804 ( 0.16%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/manager.hpp:Gecode::FlatZinc::FlatZincSpace::FlatZincSpace(Gecode::FlatZinc::FlatZincSpace&)
  144,116,929 ( 0.16%)  ???:0x00000000049547c0 [???]
  144,116,929 ( 0.16%)  ???:0x0000000004954980 [???]
  143,737,309 ( 0.16%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/var-imp/int.hpp:void Gecode::Int::Linear::bounds_n<int, Gecode::Int::ScaleView<int, unsigned int> >(int, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, int&, int&, int&)
  142,464,102 ( 0.16%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view.hpp:Gecode::ViewBrancher<Gecode::Int::IntView, Gecode::BrancherNoFilter<Gecode::Int::IntView>, 1>::status(Gecode::Space const&) const [/usr/local/lib/libgecodeint.so.51.0]
  142,403,120 ( 0.16%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/var-imp/int.hpp:Gecode::Int::IntVarImp::eq_full(Gecode::Space&, int)
  140,657,632 ( 0.16%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::Int::Count::IntBase<Gecode::Int::IntView, Gecode::Int::ConstIntView>::cost(Gecode::Space const&, int const&) const
  137,743,144 ( 0.15%)  /home/dexter/master-thesis/gecode-dexter/./gecode/support/marked-pointer.hpp:Gecode::ViewSelChoose<Gecode::ChooseMax, Gecode::Int::Branch::MeritAFCSize<Gecode::Int::IntView> >::select(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&, int)
  137,462,837 ( 0.15%)  /home/dexter/master-thesis/gecode-dexter/./gecode/search/seq/bab.hpp:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::BAB<Gecode::Search::NoTraceRecorder> >::next()
  131,709,564 ( 0.15%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::ViewValBrancher<Gecode::Int::IntView, 1, int, 2u, Gecode::BrancherNoFilter<Gecode::Int::IntView>, Gecode::BrancherPrint<Gecode::Int::IntView, int> >::copy(Gecode::Space&)
  128,265,773 ( 0.14%)  ???:0x0000000004954a10 [???]
  128,258,464 ( 0.14%)  /usr/include/c++/11/bits/stl_bvector.h:Gecode::FlatZinc::FlatZincSpace::FlatZincSpace(Gecode::FlatZinc::FlatZincSpace&)
  126,464,409 ( 0.14%)  ???:0x0000000004e951f0 [???]
  125,264,958 ( 0.14%)  /home/dexter/master-thesis/gecode-dexter/./gecode/support/dynamic-stack.hpp:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::BAB<Gecode::Search::NoTraceRecorder> >::next()
  124,772,172 ( 0.14%)  /home/dexter/master-thesis/gecode-dexter/./gecode/search/statistics.hpp:Gecode::Search::Seq::RestartStop::stop(Gecode::Search::Statistics const&, Gecode::Search::Options const&)
  122,945,919 ( 0.14%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/var-type.hpp:Gecode::Int::IntVarImp::gq_full(Gecode::Space&, int)
  120,655,215 ( 0.13%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view.hpp:Gecode::ViewValBrancher<Gecode::Int::IntView, 1, int, 2u, Gecode::BrancherNoFilter<Gecode::Int::IntView>, Gecode::BrancherPrint<Gecode::Int::IntView, int> >::choice(Gecode::Space&)
  112,226,156 ( 0.13%)  /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/flatzinc.cpp:Gecode::FlatZinc::FlatZincSpace::copy() [/usr/local/lib/libgecodeflatzinc.so.51.0]
  112,226,116 ( 0.13%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/manager.hpp:Gecode::Space::_clone()
  112,226,100 ( 0.13%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/val-sel-commit.hpp:Gecode::ValSelCommit<Gecode::Int::Branch::ValSelMin<Gecode::Int::IntView>, Gecode::Int::Branch::ValCommitEq<Gecode::Int::IntView> >::copy(Gecode::Space&) [/usr/local/lib/libgecodeint.so.51.0]
  112,226,100 ( 0.13%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view-sel.hpp:Gecode::ViewSelMax<Gecode::Int::Branch::MeritAFCSize<Gecode::Int::IntView> >::copy(Gecode::Space&) [/usr/local/lib/libgecodeint.so.51.0]
  105,891,662 ( 0.12%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::DFS<Gecode::Search::NoTraceRecorder> >::next()
  104,503,106 ( 0.12%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/data/array.hpp:void Gecode::Int::Linear::bounds_p<int, Gecode::Int::ScaleView<int, unsigned int> >(int, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, int&, int&, int&)
  104,209,898 ( 0.12%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/shared-object.hpp:Gecode::FlatZinc::FlatZincSpace::~FlatZincSpace()'2
   99,478,170 ( 0.11%)  /home/dexter/master-thesis/gecode-dexter/./gecode/search/worker.hh:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::DFS<Gecode::Search::NoTraceRecorder> >::next()
   98,214,790 ( 0.11%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/view/scale.hpp:Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >::update(Gecode::Space&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&)
   96,279,196 ( 0.11%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/manager.hpp:Gecode::ValSelCommit<Gecode::Int::Branch::ValSelMin<Gecode::Int::IntView>, Gecode::Int::Branch::ValCommitEq<Gecode::Int::IntView> >::copy(Gecode::Space&)
   96,193,824 ( 0.11%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/manager.hpp:Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >::update(Gecode::Space&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&)
   96,193,754 ( 0.11%)  /usr/include/c++/11/bits/stl_bvector.h:Gecode::FlatZinc::FlatZincSpace::~FlatZincSpace()'2
   93,579,129 ( 0.10%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::Search::Seq::RestartStop::stop(Gecode::Search::Statistics const&, Gecode::Search::Options const&)
   89,938,191 ( 0.10%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::VarImp<Gecode::Int::IntVarImpConf>::remove(Gecode::Space&, Gecode::Propagator*, int) [clone .constprop.0] [/usr/local/lib/libgecodeint.so.51.0]
   85,474,545 ( 0.10%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::Int::Count::EqInt<Gecode::Int::IntView, Gecode::Int::ConstIntView>::propagate(Gecode::Space&, int const&)
   77,076,776 ( 0.09%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/distinct/bnd.hpp:Gecode::Int::Distinct::Bnd<Gecode::Int::IntView>::copy(Gecode::Space&) [/usr/local/lib/libgecodeint.so.51.0]
   74,787,664 ( 0.08%)  /home/dexter/master-thesis/gecode-dexter/./gecode/support/marked-pointer.hpp:Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >::update(Gecode::Space&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&)
   74,591,490 ( 0.08%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/manager.hpp:Gecode::Int::IntVarImp::nq_full(Gecode::Space&, int)
   72,406,370 ( 0.08%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/var-imp.hpp:Gecode::Int::IntVarImp::nq_full(Gecode::Space&, int)
   72,145,350 ( 0.08%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/shared-object.hpp:Gecode::ViewValBrancher<Gecode::Int::IntView, 1, int, 2u, Gecode::BrancherNoFilter<Gecode::Int::IntView>, Gecode::BrancherPrint<Gecode::Int::IntView, int> >::copy(Gecode::Space&)
   71,653,230 ( 0.08%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/view/scale.hpp:void Gecode::Int::Linear::bounds_p<int, Gecode::Int::ScaleView<int, unsigned int> >(int, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, int&, int&, int&)
   71,194,520 ( 0.08%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/var-imp.hpp:Gecode::Int::IntVarImp::lq_full(Gecode::Space&, int)
   70,544,383 ( 0.08%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/count/int-eq.hpp:Gecode::Int::Count::EqInt<Gecode::Int::IntView, Gecode::Int::ConstIntView>::copy(Gecode::Space&) [/usr/local/lib/libgecodeint.so.51.0]
   69,376,916 ( 0.08%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/view/int.hpp:void Gecode::Int::Linear::bounds_n<int, Gecode::Int::ScaleView<int, unsigned int> >(int, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, int&, int&, int&)
   67,355,820 ( 0.08%)  /usr/include/c++/11/bits/align.h:Gecode::Kernel::MemoryManager::alloc_refill(Gecode::Kernel::SharedMemory&, unsigned long)
   64,349,492 ( 0.07%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::Space::choice()
   64,132,889 ( 0.07%)  ???:0x0000000004e95750 [???]
   64,132,884 ( 0.07%)  /usr/include/x86_64-linux-gnu/c++/11/bits/gthr-default.h:Gecode::Region::Pool::chunk()
   64,132,884 ( 0.07%)  /usr/include/x86_64-linux-gnu/c++/11/bits/gthr-default.h:Gecode::Region::Pool::chunk(Gecode::Region::Chunk*)
   64,129,249 ( 0.07%)  ???:0x0000000004954710 [???]
   64,129,216 ( 0.07%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::Int::Linear::Eq<int, Gecode::Int::ScaleView<int, unsigned int>, Gecode::Int::ScaleView<int, unsigned int> >::copy(Gecode::Space&)
   64,129,208 ( 0.07%)  /usr/include/x86_64-linux-gnu/c++/11/bits/gthr-default.h:Gecode::Space::~Space()
   62,427,049 ( 0.07%)  /usr/include/c++/11/bits/basic_string.h:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::DFS<Gecode::Search::NoTraceRecorder> >::next()
   61,774,712 ( 0.07%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/var-imp/int.hpp:Gecode::Int::IntVarImp::gq_full(Gecode::Space&, int)
   61,442,375 ( 0.07%)  ???:0x0000000004e95920 [???]
   61,376,216 ( 0.07%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/config.hpp:Gecode::Int::Distinct::Bnd<Gecode::Int::IntView>::propagate(Gecode::Space&, int const&)
   59,230,113 ( 0.07%)  ./malloc/./malloc/malloc.c:_int_malloc [/usr/lib/x86_64-linux-gnu/libc.so.6]
   56,326,275 ( 0.06%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/count/int-base.hpp:Gecode::Int::Count::EqInt<Gecode::Int::IntView, Gecode::Int::ConstIntView>::propagate(Gecode::Space&, int const&)
   56,113,098 ( 0.06%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::FlatZinc::FlatZincSpace::FlatZincSpace(Gecode::FlatZinc::FlatZincSpace&)
   55,755,824 ( 0.06%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/view.hpp:Gecode::ExecStatus Gecode::Int::Distinct::prop_val<Gecode::Int::IntView, false>(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&)
   55,207,832 ( 0.06%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/distinct/bnd.hpp:Gecode::Int::Distinct::Bnd<Gecode::Int::IntView>::cost(Gecode::Space const&, int const&) const [/usr/local/lib/libgecodeint.so.51.0]
   55,103,315 ( 0.06%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/manager.hpp:Gecode::Int::IntVarImp::lq_full(Gecode::Space&, int)
   55,089,767 ( 0.06%)  ???:0x0000000004df1740 [???]
   55,089,762 ( 0.06%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/branch/val-commit.hpp:Gecode::ValSelCommit<Gecode::Int::Branch::ValSelMin<Gecode::Int::IntView>, Gecode::Int::Branch::ValCommitEq<Gecode::Int::IntView> >::commit(Gecode::Space&, unsigned int, Gecode::Int::IntView, int, int)
   54,264,910 ( 0.06%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/count/int-base.hpp:Gecode::Int::Count::EqInt<Gecode::Int::IntView, Gecode::Int::ConstIntView>::copy(Gecode::Space&)
   54,024,340 ( 0.06%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::ViewArray<Gecode::Int::IntView>::update(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&)
   53,106,904 ( 0.06%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::ExecStatus Gecode::Int::Linear::prop_bnd<int, Gecode::Int::ScaleView<int, unsigned int>, Gecode::Int::ScaleView<int, unsigned int> >(Gecode::Space&, int, Gecode::Propagator&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, int&)
   52,947,295 ( 0.06%)  /home/dexter/master-thesis/gecode-dexter/./gecode/search/worker.hh:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::BAB<Gecode::Search::NoTraceRecorder> >::next()
   52,477,211 ( 0.06%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::BAB<Gecode::Search::NoTraceRecorder> >::next()
   51,085,225 ( 0.06%)  ???:0x0000000004e95500 [???]
   51,019,622 ( 0.06%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/manager.hpp:void Gecode::Kernel::MemoryManager::fl_refill<16ul>(Gecode::Kernel::SharedMemory&) [/usr/local/lib/libgecodeint.so.51.0]
   50,706,150 ( 0.06%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/manager.hpp:Gecode::Space::status(Gecode::StatusStatistics&)
   50,706,150 ( 0.06%)  /usr/include/c++/11/bits/align.h:Gecode::Space::status(Gecode::StatusStatistics&)
   50,496,608 ( 0.06%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::Int::Distinct::Bnd<Gecode::Int::IntView>::propagate(Gecode::Space&, int const&)
   49,307,209 ( 0.06%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/count/rel.hpp:Gecode::Int::Count::EqInt<Gecode::Int::IntView, Gecode::Int::ConstIntView>::propagate(Gecode::Space&, int const&)
   49,251,076 ( 0.06%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/manager.hpp:Gecode::ViewSelMax<Gecode::Int::Branch::MeritAFCSize<Gecode::Int::IntView> >::copy(Gecode::Space&)
   48,830,627 ( 0.05%)  ???:0x0000000004e95580 [???]
   48,830,622 ( 0.05%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/var-imp/delta.hpp:Gecode::Int::IntVarImp::eq_full(Gecode::Space&, int)
   48,099,663 ( 0.05%)  /usr/include/c++/11/bits/std_mutex.h:Gecode::Region::Pool::chunk()
   48,099,663 ( 0.05%)  /usr/include/c++/11/bits/std_mutex.h:Gecode::Region::Pool::chunk(Gecode::Region::Chunk*)
   48,096,971 ( 0.05%)  ???:0x0000000004866660 [???]
   48,096,912 ( 0.05%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/manager.hpp:Gecode::Int::Linear::Eq<int, Gecode::Int::ScaleView<int, unsigned int>, Gecode::Int::ScaleView<int, unsigned int> >::copy(Gecode::Space&)
   48,096,882 ( 0.05%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/val-sel-commit.hpp:Gecode::ValSelCommit<Gecode::Int::Branch::ValSelMin<Gecode::Int::IntView>, Gecode::Int::Branch::ValCommitEq<Gecode::Int::IntView> >::notice() const [/usr/local/lib/libgecodeint.so.51.0]
   48,096,876 ( 0.05%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/shared-object.hpp:Gecode::Space::~Space()
   47,913,231 ( 0.05%)  /usr/include/c++/11/bits/atomic_base.h:Gecode::Driver::PBSCombinedStop::stop(Gecode::Search::Statistics const&, Gecode::Search::Options const&)
   47,582,454 ( 0.05%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/gpi.hpp:Gecode::Space::status(Gecode::StatusStatistics&)
   47,564,358 ( 0.05%)  /usr/include/x86_64-linux-gnu/c++/11/bits/gthr-default.h:Gecode::Space::status(Gecode::StatusStatistics&)
   44,434,104 ( 0.05%)  /home/dexter/master-thesis/gecode-dexter/./gecode/support/sort.hpp:Gecode::Int::Distinct::Bnd<Gecode::Int::IntView>::propagate(Gecode::Space&, int const&)
   43,951,492 ( 0.05%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/var-imp/delta.hpp:Gecode::Int::IntVarImp::lq_full(Gecode::Space&, int)
   43,411,928 ( 0.05%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::Int::Count::EqInt<Gecode::Int::IntView, Gecode::Int::ConstIntView>::copy(Gecode::Space&)
   40,218,405 ( 0.04%)  /home/dexter/master-thesis/gecode-dexter/./gecode/support/allocator.hpp:Gecode::ViewValBrancher<Gecode::Int::IntView, 1, int, 2u, Gecode::BrancherNoFilter<Gecode::Int::IntView>, Gecode::BrancherPrint<Gecode::Int::IntView, int> >::choice(Gecode::Space&)
   40,183,563 ( 0.04%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/shared-object.hpp:Gecode::Rnd::~Rnd()
   40,080,770 ( 0.04%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/shared-object.hpp:Gecode::Space::Space(Gecode::Space&)
   40,080,770 ( 0.04%)  /usr/include/x86_64-linux-gnu/c++/11/bits/gthr-default.h:Gecode::Space::Space(Gecode::Space&)
   40,080,730 ( 0.04%)  /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/flatzinc.cpp:Gecode::FlatZinc::FlatZincSpace::~FlatZincSpace() [/usr/local/lib/libgecodeflatzinc.so.51.0]
   39,732,721 ( 0.04%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/data/array.hpp:Gecode::ExecStatus Gecode::Int::Distinct::prop_val<Gecode::Int::IntView, false>(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&)
   39,432,759 ( 0.04%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/view/int.hpp:Gecode::ExecStatus Gecode::Int::Distinct::prop_val<Gecode::Int::IntView, false>(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&)
   36,794,276 ( 0.04%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/count/int-base.hpp:Gecode::Int::Count::IntBase<Gecode::Int::IntView, Gecode::Int::ConstIntView>::cost(Gecode::Space const&, int const&) const [/usr/local/lib/libgecodeint.so.51.0]
   35,826,615 ( 0.04%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/var-imp/int.hpp:void Gecode::Int::Linear::bounds_p<int, Gecode::Int::ScaleView<int, unsigned int> >(int, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, int&, int&, int&)
   34,453,283 ( 0.04%)  ???:0x0000000004df1910 [???]
   33,831,679 ( 0.04%)  /usr/include/c++/11/bits/align.h:Gecode::Int::IntVarImp::lq_full(Gecode::Space&, int)
   33,440,374 ( 0.04%)  /usr/include/c++/11/bits/basic_string.h:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::BAB<Gecode::Search::NoTraceRecorder> >::next()
   32,558,946 ( 0.04%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/manager.hpp:Gecode::Int::Count::EqInt<Gecode::Int::IntView, Gecode::Int::ConstIntView>::copy(Gecode::Space&)
   32,146,860 ( 0.04%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/shared-object.hpp:Gecode::Rnd::Rnd(Gecode::Rnd const&)
   32,066,447 ( 0.04%)  ???:0x0000000004e95070 [???]
   32,066,447 ( 0.04%)  ???:0x0000000004e955a0 [???]
   32,064,660 ( 0.04%)  /usr/include/x86_64-linux-gnu/c++/11/bits/gthr-default.h:Gecode::Kernel::MemoryManager::alloc_refill(Gecode::Kernel::SharedMemory&, unsigned long)
   32,064,616 ( 0.04%)  /home/dexter/master-thesis/gecode-dexter/./gecode/flatzinc.hh:Gecode::FlatZinc::FlatZincSpace::FlatZincSpace(Gecode::FlatZinc::FlatZincSpace&)
   32,064,608 ( 0.04%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/data/array.hpp:Gecode::Int::Linear::Eq<int, Gecode::Int::ScaleView<int, unsigned int>, Gecode::Int::ScaleView<int, unsigned int> >::copy(Gecode::Space&)
   32,064,604 ( 0.04%)  /usr/include/c++/11/bits/std_mutex.h:Gecode::Space::~Space()
   32,064,600 ( 0.04%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/data/array.hpp:Gecode::ViewValBrancher<Gecode::Int::IntView, 1, int, 2u, Gecode::BrancherNoFilter<Gecode::Int::IntView>, Gecode::BrancherPrint<Gecode::Int::IntView, int> >::copy(Gecode::Space&)
   32,064,596 ( 0.04%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::ViewValBrancher<Gecode::Int::IntView, 1, int, 2u, Gecode::BrancherNoFilter<Gecode::Int::IntView>, Gecode::BrancherPrint<Gecode::Int::IntView, int> >::dispose(Gecode::Space&)
   32,064,580 ( 0.04%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/val-sel-commit.hpp:Gecode::ValSelCommit<Gecode::Int::Branch::ValSelMin<Gecode::Int::IntView>, Gecode::Int::Branch::ValCommitEq<Gecode::Int::IntView> >::dispose(Gecode::Space&) [/usr/local/lib/libgecodeint.so.51.0]
   31,015,698 ( 0.03%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/var-imp.hpp:Gecode::Int::IntVarImp::gq_full(Gecode::Space&, int)
   30,716,199 ( 0.03%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/var-imp/delta.hpp:Gecode::Int::IntVarImp::nq_full(Gecode::Space&, int)
   27,897,753 ( 0.03%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/data/array.hpp:Gecode::ViewBrancher<Gecode::Int::IntView, Gecode::BrancherNoFilter<Gecode::Int::IntView>, 1>::status(Gecode::Space const&) const
   27,544,881 ( 0.03%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view.hpp:Gecode::ViewValBrancher<Gecode::Int::IntView, 1, int, 2u, Gecode::BrancherNoFilter<Gecode::Int::IntView>, Gecode::BrancherPrint<Gecode::Int::IntView, int> >::commit(Gecode::Space&, Gecode::Choice const&, unsigned int)
   24,415,311 ( 0.03%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/var-imp.hpp:Gecode::Int::IntVarImp::eq_full(Gecode::Space&, int)
   24,131,043 ( 0.03%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/val-sel-commit.hpp:Gecode::ValSelCommit<Gecode::Int::Branch::ValSelMin<Gecode::Int::IntView>, Gecode::Int::Branch::ValCommitEq<Gecode::Int::IntView> >::val(Gecode::Space const&, Gecode::Int::IntView, int) [/usr/local/lib/libgecodeint.so.51.0]
   24,131,043 ( 0.03%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::ViewValBrancher<Gecode::Int::IntView, 1, int, 2u, Gecode::BrancherNoFilter<Gecode::Int::IntView>, Gecode::BrancherPrint<Gecode::Int::IntView, int> >::choice(Gecode::Space&)
   24,048,441 ( 0.03%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view-sel.hpp:Gecode::ViewSelChoose<Gecode::ChooseMax, Gecode::Int::Branch::MeritAFCSize<Gecode::Int::IntView> >::notice() const [/usr/local/lib/libgecodeint.so.51.0]
   24,048,438 ( 0.03%)  /home/dexter/master-thesis/gecode-dexter/./gecode/flatzinc.hh:Gecode::FlatZinc::FlatZincSpace::~FlatZincSpace()'2
   23,657,008 ( 0.03%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/config.hpp:Gecode::ExecStatus Gecode::Int::Distinct::prop_val<Gecode::Int::IntView, false>(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&)
   22,021,936 ( 0.02%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::Int::Distinct::Bnd<Gecode::Int::IntView>::copy(Gecode::Space&)
   21,650,419 ( 0.02%)  ???:0x0000000004e95cc0 [???]
   19,710,354 ( 0.02%)  /home/dexter/master-thesis/gecode-dexter/./gecode/int/view/int.hpp:Gecode::Int::Count::EqInt<Gecode::Int::IntView, Gecode::Int::ConstIntView>::propagate(Gecode::Space&, int const&)
   17,913,298 ( 0.02%)  /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:void Gecode::Int::Linear::bounds_p<int, Gecode::Int::ScaleView<int, unsigned int> >(int, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, int&, int&, int&)

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/int/view/int.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 51 ----------------------------------------
          .               : VarImpView<IntVar>(y) {}
          .           
          .             /*
          .              * Value access
          .              *
          .              */
          .             forceinline int
          .             IntView::min(void) const {
198,762,397 ( 0.22%)      return x->min();
          .             }
          .             forceinline int
          .             IntView::max(void) const {
250,125,100 ( 0.28%)      return x->max();
          .             }
          .             forceinline int
          .             IntView::med(void) const {
          .               return x->med();
          .             }
          .             forceinline int
          .             IntView::val(void) const {
     12,053 ( 0.00%)      return x->val();
          .             }
          .           #ifdef GECODE_HAS_CBS
          .             forceinline int
          .             IntView::baseval(int val) const {
          .               return val;
          .             }
          .           #endif
          .           
-- line 79 ----------------------------------------
-- line 123 ----------------------------------------
          .             }
          .             forceinline ModEvent
          .             IntView::lq(Space& home, long long int n) {
          .               return x->lq(home,n);
          .             }
          .           
          .             forceinline ModEvent
          .             IntView::le(Space& home, int n) {
     20,485 ( 0.00%)      return x->lq(home,n-1);
          .             }
          .             forceinline ModEvent
          .             IntView::le(Space& home, long long int n) {
          .               return x->lq(home,n-1);
          .             }
          .           
          .             forceinline ModEvent
          .             IntView::gq(Space& home, int n) {
  1,438,274 ( 0.00%)      return x->gq(home,n);
          .             }
          .             forceinline ModEvent
          .             IntView::gq(Space& home, long long int n) {
          .               return x->gq(home,n);
          .             }
          .           
          .             forceinline ModEvent
          .             IntView::gr(Space& home, int n) {
-- line 148 ----------------------------------------
-- line 150 ----------------------------------------
          .             }
          .             forceinline ModEvent
          .             IntView::gr(Space& home, long long int n) {
          .               return x->gq(home,n+1);
          .             }
          .           
          .             forceinline ModEvent
          .             IntView::nq(Space& home, int n) {
 39,534,466 ( 0.04%)      return x->nq(home,n);
          .             }
          .             forceinline ModEvent
          .             IntView::nq(Space& home, long long int n) {
          .               return x->nq(home,n);
          .             }
          .           
          .             forceinline ModEvent
          .             IntView::eq(Space& home, int n) {
 23,193,783 ( 0.03%)      return x->eq(home,n);
          .             }
          .             forceinline ModEvent
          .             IntView::eq(Space& home, long long int n) {
          .               return x->eq(home,n);
          .             }
          .           
          .           
          .             /*
-- line 175 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/support/allocator.hpp
--------------------------------------------------------------------------------
Ir                  

-- line 72 ----------------------------------------
         .             };
         .           
         .           
         .             forceinline
         .             Allocator::Allocator(void) {
         .             }
         .             forceinline void*
         .             Allocator::alloc(size_t n) {
56,433,613 ( 0.06%)      return ::malloc(n);
     2,063 ( 0.00%)  => ???:0x0000000004df1780 (2x)
         .             }
         .             forceinline void*
         .             Allocator::realloc(void* p, size_t n) {
         .               return ::realloc(p,n);
         .             }
         .             forceinline void
         .             Allocator::free(void* p) {
24,197,795 ( 0.03%)      ::free(p);
     1,174 ( 0.00%)  => ???:0x0000000004df1730 (2x)
         .             }
         .             forceinline void*
         .             Allocator::memcpy(void *d, const void *s, size_t n) {
         .               return ::memcpy(d,s,n);
         .             }
         .           
         .           }}
         .           
-- line 96 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/search/seq/dfs.hpp
--------------------------------------------------------------------------------
Ir                  

-- line 31 ----------------------------------------
         .            *
         .            */
         .           
         .           namespace Gecode { namespace Search { namespace Seq {
         .           
         .             template<class Tracer>
         .             forceinline
         .             DFS<Tracer>::DFS(Space* s, const Options& o)
        11 ( 0.00%)      : tracer(o.tracer), opt(o), path(opt.nogoods_limit), d(0) {
         .               if (tracer) {
         .                 tracer.engine(SearchTracer::EngineType::DFS, 1U);
         .                 tracer.worker();
         .               }
         7 ( 0.00%)      if ((s == nullptr) || (s->status(*this) == SS_FAILED)) {
        55 ( 0.00%)  => ???:0x0000000004df1910 (1x)
         .                 fail++;
         .                 cur = nullptr;
         .                 if (!opt.clone)
         .                   delete s;
         .               } else {
         2 ( 0.00%)        cur = snapshot(s,opt);
         .               }
         .             }
         .           
         .             template<class Tracer>
         .             forceinline void
         .             DFS<Tracer>::reset(Space* s) {
         .               tracer.round();
    61,449 ( 0.00%)      delete cur;
         .               path.reset();
    20,483 ( 0.00%)      d = 0;
   143,381 ( 0.00%)      if ((s == nullptr) || (s->status(*this) == SS_FAILED)) {
101,274,273 ( 0.11%)  => ???:0x0000000004df1910 (20,483x)
         .                 delete s;
         .                 cur = nullptr;
         .               } else {
    20,483 ( 0.00%)        cur = s;
         .               }
         .               Worker::reset();
         .             }
         .           
         .             template<class Tracer>
         .             forceinline NoGoods&
         .             DFS<Tracer>::nogoods(void) {
    20,483 ( 0.00%)      return path;
         .             }
         .           
         .             template<class Tracer>
         .             forceinline Space*
         .             DFS<Tracer>::next(void) {
         .               /*
         .                * The engine maintains the following invariant:
         .                *  - If the current space (cur) is not nullptr, the path always points
-- line 81 ----------------------------------------
-- line 84 ----------------------------------------
         .                *    to the next space (if there is any).
         .                *
         .                * This invariant is needed so that no-goods can be extracted properly
         .                * when the engine is stopped or has found a solution.
         .                *
         .                */
         .               start();
         .               while (true) {
20,856,811 ( 0.02%)        if (stop(opt))
    20,483 ( 0.00%)          return nullptr;
31,193,040 ( 0.03%)        while (cur == nullptr) {
10,240,428 ( 0.01%)          if (path.empty())
         .                     return nullptr;
10,240,428 ( 0.01%)          cur = path.recompute(d,opt.a_d,*this,tracer);
 7,011,066 ( 0.01%)          if (cur != nullptr)
         .                     break;
         .                   path.next();
         .                 }
10,397,680 ( 0.01%)        node++;
         .                 SearchTracer::EdgeInfo ei;
         .                 if (tracer && (path.entries() > 0)) {
         .                   typename Path<Tracer>::Edge& top = path.top();
         .                   ei.init(tracer.wid(), top.nid(), top.truealt(), *cur, *top.choice());
         .                 }
         .                 unsigned int nid = tracer.nid();
83,065,150 ( 0.09%)        switch (cur->status(*this)) {
11,569,104,467 (12.94%)  => ???:0x0000000004df1910 (10,397,680x)
         .                 case SS_FAILED:
         .                   if (tracer) {
         .                     SearchTracer::NodeInfo ni(SearchTracer::NodeType::FAILED,
         .                                               tracer.wid(), nid, *cur);
         .                     tracer.node(ei,ni);
         .                   }
 5,140,696 ( 0.01%)          fail++;
25,703,480 ( 0.03%)          delete cur;
2,549,602,790 ( 2.85%)  => /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/flatzinc.cpp:Gecode::FlatZinc::FlatZincSpace::~FlatZincSpace() (5,140,696x)
 5,140,696 ( 0.01%)          cur = nullptr;
         .                   path.next();
         .                   break;
         .                 case SS_SOLVED:
         .                   {
         .                     if (tracer) {
         .                       SearchTracer::NodeInfo ni(SearchTracer::NodeType::SOLVED,
         .                                                 tracer.wid(), nid, *cur);
         .                       tracer.node(ei,ni);
         .                     }
         .                     // Deletes all pending branchers
         2 ( 0.00%)            (void) cur->choice();
     1,378 ( 0.00%)  => ???:0x0000000004df1820 (1x)
         1 ( 0.00%)            Space* s = cur;
         1 ( 0.00%)            cur = nullptr;
         .                     path.next();
         .                     return s;
         .                   }
         .                 case SS_BRANCH:
         .                   {
         .                     Space* c;
24,202,487 ( 0.03%)            if ((d == 0) || (d >= opt.c_d)) {
         .                       c = cur->clone();
 5,256,983 ( 0.01%)              d = 1;
         .                     } else {
 8,428,188 ( 0.01%)              c = nullptr;
 4,214,094 ( 0.00%)              d++;
         .                     }
 5,256,983 ( 0.01%)            const Choice* ch = path.push(*this,cur,c,nid);
         .                     if (tracer) {
         .                       SearchTracer::NodeInfo ni(SearchTracer::NodeType::BRANCH,
         .                                                 tracer.wid(), nid, *cur, ch);
         .                       tracer.node(ei,ni);
         .                     }
         .                     cur->commit(*ch,0);
         .                     break;
         .                   }
-- line 153 ----------------------------------------
-- line 157 ----------------------------------------
         .               }
         .               GECODE_NEVER;
         .               return nullptr;
         .             }
         .           
         .             template<class Tracer>
         .             forceinline Statistics
         .             DFS<Tracer>::statistics(void) const {
   245,796 ( 0.00%)      return *this;
         .             }
         .           
         .             template<class Tracer>
         .             forceinline void
         .             DFS<Tracer>::constrain(const Space& b) {
         .               (void) b;
         .               assert(false);
         .             }
-- line 173 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/int/var-imp/int.hpp
--------------------------------------------------------------------------------
Ir                     

-- line 45 ----------------------------------------
            .           #define GECODE_INT_RL2PD(r) reinterpret_cast<ptrdiff_t>(r)
            .           #define GECODE_INT_PD2RL(p) reinterpret_cast<RangeList*>(p)
            .           
            .             forceinline
            .             IntVarImp::RangeList::RangeList(void) {}
            .           
            .             forceinline
            .             IntVarImp::RangeList::RangeList(int min, int max)
  192,182,365 ( 0.21%)      : _min(min), _max(max) {}
            .           
            .             forceinline
            .             IntVarImp::RangeList::RangeList(int min, int max, RangeList* p, RangeList* n)
            .               : _min(min), _max(max) {
   11,828,504 ( 0.01%)      _next = GECODE_INT_PD2RL(GECODE_INT_RL2PD(p)^GECODE_INT_RL2PD(n));
            .             }
            .           
            .             forceinline IntVarImp::RangeList*
            .             IntVarImp::RangeList::next(const RangeList* p) const {
  347,449,328 ( 0.39%)      return GECODE_INT_PD2RL(GECODE_INT_RL2PD(_next)^GECODE_INT_RL2PD(p));
            .             }
            .             forceinline IntVarImp::RangeList*
            .             IntVarImp::RangeList::prev(const RangeList* n) const {
    9,061,609 ( 0.01%)      return GECODE_INT_PD2RL(GECODE_INT_RL2PD(_next)^GECODE_INT_RL2PD(n));
            .             }
            .             forceinline void
            .             IntVarImp::RangeList::prevnext(RangeList* p, RangeList* n) {
  224,080,352 ( 0.25%)      _next = GECODE_INT_PD2RL(GECODE_INT_RL2PD(p)^GECODE_INT_RL2PD(n));
            .             }
            .             forceinline void
            .             IntVarImp::RangeList::next(RangeList* o, RangeList* n) {
   41,114,360 ( 0.05%)      _next = GECODE_INT_PD2RL(GECODE_INT_RL2PD(_next)^
            .                                        (GECODE_INT_RL2PD(o)^GECODE_INT_RL2PD(n)));
            .             }
            .             forceinline void
            .             IntVarImp::RangeList::prev(RangeList* o, RangeList* n) {
   16,559,010 ( 0.02%)      _next = GECODE_INT_PD2RL(GECODE_INT_RL2PD(_next)^
            .                                        (GECODE_INT_RL2PD(o)^GECODE_INT_RL2PD(n)));
            .             }
            .             forceinline void
            .             IntVarImp::RangeList::fix(RangeList* n) {
   17,002,965 ( 0.02%)      _next = n;
            .             }
            .           
            .             forceinline void
            .             IntVarImp::RangeList::min(int n) {
  131,309,880 ( 0.15%)      _min = n;
            .             }
            .             forceinline void
            .             IntVarImp::RangeList::max(int n) {
   68,433,964 ( 0.08%)      _max = n;
            .             }
            .           
            .             forceinline int
            .             IntVarImp::RangeList::min(void) const {
1,007,854,545 ( 1.13%)      return _min;
            .             }
            .             forceinline int
            .             IntVarImp::RangeList::max(void) const {
  815,775,327 ( 0.91%)      return _max;
            .             }
            .             forceinline unsigned int
            .             IntVarImp::RangeList::width(void) const {
   42,752,006 ( 0.05%)      return static_cast<unsigned int>(_max - _min) + 1;
            .             }
            .           
            .           
            .             forceinline void
            .             IntVarImp::RangeList::operator delete(void*) {}
            .           
            .             forceinline void
            .             IntVarImp::RangeList::operator delete(void*, Space&) {
-- line 115 ----------------------------------------
-- line 128 ----------------------------------------
            .             forceinline void*
            .             IntVarImp::RangeList::operator new(size_t, void* p) {
            .               return p;
            .             }
            .           
            .             forceinline void
            .             IntVarImp::RangeList::dispose(Space& home, RangeList* p, RangeList* l) {
            .               RangeList* c = this;
   36,082,846 ( 0.04%)      while (c != l) {
            .                 RangeList* n = c->next(p);
            .                 c->fix(n);
            .                 p=c; c=n;
            .               }
            .               home.fl_dispose<sizeof(RangeList)>(this,l);
            .             }
            .           
            .             forceinline void
            .             IntVarImp::RangeList::dispose(Space& home, RangeList* l) {
    3,094,717 ( 0.00%)      home.fl_dispose<sizeof(RangeList)>(this,l);
            .             }
            .           
            .             forceinline void
            .             IntVarImp::RangeList::dispose(Space& home) {
            .               home.fl_dispose<sizeof(RangeList)>(this,this);
            .             }
            .           
            .           #undef GECODE_INT_RL2PD
-- line 154 ----------------------------------------
-- line 166 ----------------------------------------
            .           
            .             forceinline void
            .             IntVarImp::fst(IntVarImp::RangeList* f) {
            .               dom.prevnext(nullptr,f);
            .             }
            .           
            .             forceinline IntVarImp::RangeList*
            .             IntVarImp::lst(void) const {
   25,460,144 ( 0.03%)      return _lst;
            .             }
            .           
            .             forceinline void
            .             IntVarImp::lst(IntVarImp::RangeList* l) {
    6,438,036 ( 0.01%)      _lst = l;
            .             }
            .           
            .             /*
            .              * Creation of new variable implementations
            .              *
            .              */
            .           
            .             forceinline
            .             IntVarImp::IntVarImp(Space& home, int min, int max)
            .               : IntVarImpBase(home), dom(min,max,nullptr,nullptr), holes(0) {}
            .           
            .             forceinline
            .             IntVarImp::IntVarImp(Space& home, const IntSet& d)
            .               : IntVarImpBase(home), dom(d.min(),d.max()) {
           44 ( 0.00%)      if (d.ranges() > 1) {
            .                 int n = d.ranges();
            .                 assert(n >= 2);
            .                 RangeList* r = home.alloc<RangeList>(n);
            .                 fst(r); lst(r+n-1);
            .                 unsigned int h = static_cast<unsigned int>(d.max()-d.min())+1;
            .                 h -= d.width(0);
            .                 r[0].min(d.min(0)); r[0].max(d.max(0));
            .                 r[0].prevnext(nullptr,&r[1]);
-- line 202 ----------------------------------------
-- line 203 ----------------------------------------
            .                 for (int i = 1; i < n-1; i++) {
            .                   h -= d.width(i);
            .                   r[i].min(d.min(i)); r[i].max(d.max(i));
            .                   r[i].prevnext(&r[i-1],&r[i+1]);
            .                 }
            .                 h -= d.width(n-1);
            .                 r[n-1].min(d.min(n-1)); r[n-1].max(d.max(n-1));
            .                 r[n-1].prevnext(&r[n-2],nullptr);
           22 ( 0.00%)        holes = h;
            .               } else {
            .                 fst(nullptr); holes = 0;
            .               }
            .             }
            .           
            .           
            .             /*
            .              * Operations on integer variable implementations
-- line 219 ----------------------------------------
-- line 246 ----------------------------------------
            .           
            .             forceinline unsigned int
            .             IntVarImp::width(void) const {
            .               return dom.width();
            .             }
            .           
            .             forceinline unsigned int
            .             IntVarImp::size(void) const {
   77,460,327 ( 0.09%)      return dom.width() - holes;
            .             }
            .           
            .             forceinline unsigned int
            .             IntVarImp::regret_min(void) const {
            .               if (fst() == nullptr) {
            .                 return (dom.min() == dom.max()) ? 0U : 1U;
            .               } else if (dom.min() == fst()->max()) {
            .                 return static_cast<unsigned int>(fst()->next(nullptr)->min()-dom.min());
-- line 262 ----------------------------------------
-- line 337 ----------------------------------------
            .           
            .             /*
            .              * Tell operations (to be inlined: performing bounds checks first)
            .              *
            .              */
            .           
            .             forceinline ModEvent
            .             IntVarImp::gq(Space& home, int n) {
   23,406,554 ( 0.03%)      if (n <= dom.min()) return ME_INT_NONE;
   23,406,554 ( 0.03%)      if (n > dom.max())  return fail(home);
   41,862,554 ( 0.05%)      ModEvent me = gq_full(home,n);
  132,123,982 ( 0.15%)  => ???:0x0000000004e95cc0 (719,137x)
            .               GECODE_ASSUME((me == ME_INT_FAILED) |
            .                             (me == ME_INT_VAL) |
            .                             (me == ME_INT_BND));
            .               return me;
            .             }
            .             forceinline ModEvent
            .             IntVarImp::gq(Space& home, long long int n) {
            .               if (n <= dom.min()) return ME_INT_NONE;
-- line 355 ----------------------------------------
-- line 358 ----------------------------------------
            .               GECODE_ASSUME((me == ME_INT_FAILED) |
            .                             (me == ME_INT_VAL) |
            .                             (me == ME_INT_BND));
            .               return me;
            .             }
            .           
            .             forceinline ModEvent
            .             IntVarImp::lq(Space& home, int n) {
   51,126,184 ( 0.06%)      if (n >= dom.max()) return ME_INT_NONE;
   51,085,220 ( 0.06%)      if (n < dom.min())  return fail(home);
  102,170,434 ( 0.11%)      ModEvent me = lq_full(home,n);
          318 ( 0.00%)  => ???:0x0000000004e95500 (3x)
            .               GECODE_ASSUME((me == ME_INT_FAILED) |
            .                             (me == ME_INT_VAL) |
            .                             (me == ME_INT_BND));
            .               return me;
            .             }
            .             forceinline ModEvent
            .             IntVarImp::lq(Space& home, long long int n) {
            .               if (n >= dom.max()) return ME_INT_NONE;
-- line 376 ----------------------------------------
-- line 379 ----------------------------------------
            .               GECODE_ASSUME((me == ME_INT_FAILED) |
            .                             (me == ME_INT_VAL) |
            .                             (me == ME_INT_BND));
            .               return me;
            .             }
            .           
            .             forceinline ModEvent
            .             IntVarImp::eq(Space& home, int n) {
  111,656,968 ( 0.12%)      if ((n < dom.min()) || (n > dom.max()))
            .                 return fail(home);
   77,510,804 ( 0.09%)      if ((n == dom.min()) && (n == dom.max()))
   13,065,454 ( 0.01%)        return ME_INT_NONE;
   87,813,817 ( 0.10%)      ModEvent me = eq_full(home,n);
   10,644,896 ( 0.01%)  => ???:0x0000000004e95580 (88,457x)
            .               GECODE_ASSUME((me == ME_INT_FAILED) | (me == ME_INT_VAL));
            .               return me;
            .             }
            .             forceinline ModEvent
            .             IntVarImp::eq(Space& home, long long int m) {
            .               if ((m < dom.min()) || (m > dom.max()))
            .                 return fail(home);
            .               int n = static_cast<int>(m);
-- line 399 ----------------------------------------
-- line 401 ----------------------------------------
            .                 return ME_INT_NONE;
            .               ModEvent me = eq_full(home,n);
            .               GECODE_ASSUME((me == ME_INT_FAILED) | (me == ME_INT_VAL));
            .               return me;
            .             }
            .           
            .             forceinline ModEvent
            .             IntVarImp::nq(Space& home, int n) {
  131,496,146 ( 0.15%)      if ((n < dom.min()) || (n > dom.max()))
            .                 return ME_INT_NONE;
   92,087,925 ( 0.10%)      return nq_full(home,n);
      963,419 ( 0.00%)  => ???:0x0000000004e95920 (7,752x)
            .             }
            .             forceinline ModEvent
            .             IntVarImp::nq(Space& home, long long int d) {
            .               if ((d < dom.min()) || (d > dom.max()))
            .                 return ME_INT_NONE;
            .               return nq_full(home,static_cast<int>(d));
            .             }
            .           
-- line 419 ----------------------------------------
-- line 984 ----------------------------------------
            .           
            .             /*
            .              * Copying a variable
            .              *
            .              */
            .           
            .             forceinline IntVarImp*
            .             IntVarImp::copy(Space& home) {
1,149,835,632 ( 1.29%)      return copied() ? static_cast<IntVarImp*>(forward())
  376,230,888 ( 0.42%)        : perform_copy(home);
        5,458 ( 0.00%)  => ???:0x0000000004867680 (58x)
            .             }
            .           
            .           
            .             forceinline ModEventDelta
            .             IntVarImp::med(ModEvent me) {
            .               return IntVarImpBase::med(me);
            .             }
            .           
-- line 1001 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/atomic_base.h
--------------------------------------------------------------------------------
Ir                  

-- line 337 ----------------------------------------
         .               public:
         .                 __atomic_base() noexcept = default;
         .                 ~__atomic_base() noexcept = default;
         .                 __atomic_base(const __atomic_base&) = delete;
         .                 __atomic_base& operator=(const __atomic_base&) = delete;
         .                 __atomic_base& operator=(const __atomic_base&) volatile = delete;
         .           
         .                 // Requires __int_type convertible to _M_i.
         2 ( 0.00%)        constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
         .           
         .                 operator __int_type() const noexcept
         .                 { return load(); }
         .           
         .                 operator __int_type() const volatile noexcept
         .                 { return load(); }
         .           
         .                 __int_type
-- line 353 ----------------------------------------
-- line 456 ----------------------------------------
         .                 store(__int_type __i, memory_order __m = memory_order_seq_cst) noexcept
         .                 {
         .           	memory_order __b __attribute__ ((__unused__))
         .           	  = __m & __memory_order_mask;
         .           	__glibcxx_assert(__b != memory_order_acquire);
         .           	__glibcxx_assert(__b != memory_order_acq_rel);
         .           	__glibcxx_assert(__b != memory_order_consume);
         .           
        39 ( 0.00%)  	__atomic_store_n(&_M_i, __i, int(__m));
         .                 }
         .           
         .                 _GLIBCXX_ALWAYS_INLINE void
         .                 store(__int_type __i,
         .           	    memory_order __m = memory_order_seq_cst) volatile noexcept
         .                 {
         .           	memory_order __b __attribute__ ((__unused__))
         .           	  = __m & __memory_order_mask;
-- line 472 ----------------------------------------
-- line 480 ----------------------------------------
         .                 _GLIBCXX_ALWAYS_INLINE __int_type
         .                 load(memory_order __m = memory_order_seq_cst) const noexcept
         .                 {
         .           	memory_order __b __attribute__ ((__unused__))
         .           	  = __m & __memory_order_mask;
         .           	__glibcxx_assert(__b != memory_order_release);
         .           	__glibcxx_assert(__b != memory_order_acq_rel);
         .           
48,131,123 ( 0.05%)  	return __atomic_load_n(&_M_i, int(__m));
         .                 }
         .           
         .                 _GLIBCXX_ALWAYS_INLINE __int_type
         .                 load(memory_order __m = memory_order_seq_cst) const volatile noexcept
         .                 {
         .           	memory_order __b __attribute__ ((__unused__))
         .           	  = __m & __memory_order_mask;
         .           	__glibcxx_assert(__b != memory_order_release);
-- line 496 ----------------------------------------
-- line 498 ----------------------------------------
         .           
         .           	return __atomic_load_n(&_M_i, int(__m));
         .                 }
         .           
         .                 _GLIBCXX_ALWAYS_INLINE __int_type
         .                 exchange(__int_type __i,
         .           	       memory_order __m = memory_order_seq_cst) noexcept
         .                 {
         6 ( 0.00%)  	return __atomic_exchange_n(&_M_i, __i, int(__m));
         .                 }
         .           
         .           
         .                 _GLIBCXX_ALWAYS_INLINE __int_type
         .                 exchange(__int_type __i,
         .           	       memory_order __m = memory_order_seq_cst) volatile noexcept
         .                 {
         .           	return __atomic_exchange_n(&_M_i, __i, int(__m));
-- line 514 ----------------------------------------
-- line 610 ----------------------------------------
         .                 { std::__atomic_notify_address(&_M_i, true); }
         .           
         .                 // TODO add const volatile overload
         .           #endif // __cpp_lib_atomic_wait
         .           
         .                 _GLIBCXX_ALWAYS_INLINE __int_type
         .                 fetch_add(__int_type __i,
         .           		memory_order __m = memory_order_seq_cst) noexcept
48,117,451 ( 0.05%)        { return __atomic_fetch_add(&_M_i, __i, int(__m)); }
         .           
         .                 _GLIBCXX_ALWAYS_INLINE __int_type
         .                 fetch_add(__int_type __i,
         .           		memory_order __m = memory_order_seq_cst) volatile noexcept
         .                 { return __atomic_fetch_add(&_M_i, __i, int(__m)); }
         .           
         .                 _GLIBCXX_ALWAYS_INLINE __int_type
         .                 fetch_sub(__int_type __i,
-- line 626 ----------------------------------------
-- line 683 ----------------------------------------
         .               public:
         .                 __atomic_base() noexcept = default;
         .                 ~__atomic_base() noexcept = default;
         .                 __atomic_base(const __atomic_base&) = delete;
         .                 __atomic_base& operator=(const __atomic_base&) = delete;
         .                 __atomic_base& operator=(const __atomic_base&) volatile = delete;
         .           
         .                 // Requires __pointer_type convertible to _M_p.
         1 ( 0.00%)        constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }
         .           
         .                 operator __pointer_type() const noexcept
         .                 { return load(); }
         .           
         .                 operator __pointer_type() const volatile noexcept
         .                 { return load(); }
         .           
         .                 __pointer_type
-- line 699 ----------------------------------------
-- line 788 ----------------------------------------
         .                 {
         .           	memory_order __b __attribute__ ((__unused__))
         .           	  = __m & __memory_order_mask;
         .           
         .           	__glibcxx_assert(__b != memory_order_acquire);
         .           	__glibcxx_assert(__b != memory_order_acq_rel);
         .           	__glibcxx_assert(__b != memory_order_consume);
         .           
         2 ( 0.00%)  	__atomic_store_n(&_M_p, __p, int(__m));
         .                 }
         .           
         .                 _GLIBCXX_ALWAYS_INLINE void
         .                 store(__pointer_type __p,
         .           	    memory_order __m = memory_order_seq_cst) volatile noexcept
         .                 {
         .           	memory_order __b __attribute__ ((__unused__))
         .           	  = __m & __memory_order_mask;
-- line 804 ----------------------------------------
-- line 812 ----------------------------------------
         .                 _GLIBCXX_ALWAYS_INLINE __pointer_type
         .                 load(memory_order __m = memory_order_seq_cst) const noexcept
         .                 {
         .           	memory_order __b __attribute__ ((__unused__))
         .           	  = __m & __memory_order_mask;
         .           	__glibcxx_assert(__b != memory_order_release);
         .           	__glibcxx_assert(__b != memory_order_acq_rel);
         .           
    20,490 ( 0.00%)  	return __atomic_load_n(&_M_p, int(__m));
         .                 }
         .           
         .                 _GLIBCXX_ALWAYS_INLINE __pointer_type
         .                 load(memory_order __m = memory_order_seq_cst) const volatile noexcept
         .                 {
         .           	memory_order __b __attribute__ ((__unused__))
         .           	  = __m & __memory_order_mask;
         .           	__glibcxx_assert(__b != memory_order_release);
-- line 828 ----------------------------------------
-- line 830 ----------------------------------------
         .           
         .           	return __atomic_load_n(&_M_p, int(__m));
         .                 }
         .           
         .                 _GLIBCXX_ALWAYS_INLINE __pointer_type
         .                 exchange(__pointer_type __p,
         .           	       memory_order __m = memory_order_seq_cst) noexcept
         .                 {
         6 ( 0.00%)  	return __atomic_exchange_n(&_M_p, __p, int(__m));
         .                 }
         .           
         .           
         .                 _GLIBCXX_ALWAYS_INLINE __pointer_type
         .                 exchange(__pointer_type __p,
         .           	       memory_order __m = memory_order_seq_cst) volatile noexcept
         .                 {
         .           	return __atomic_exchange_n(&_M_p, __p, int(__m));
-- line 846 ----------------------------------------
-- line 848 ----------------------------------------
         .           
         .                 _GLIBCXX_ALWAYS_INLINE bool
         .                 compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         .           			      memory_order __m1,
         .           			      memory_order __m2) noexcept
         .                 {
         .           	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
         .           
         3 ( 0.00%)  	return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0,
         .           					   int(__m1), int(__m2));
         .                 }
         .           
         .                 _GLIBCXX_ALWAYS_INLINE bool
         .                 compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         .           			      memory_order __m1,
         .           			      memory_order __m2) volatile noexcept
         .                 {
-- line 864 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/gecode/kernel/memory/manager.cpp
--------------------------------------------------------------------------------
Ir                  

-- line 30 ----------------------------------------
         .            *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
         .            *
         .            */
         .           
         .           #include <gecode/kernel.hh>
         .           
         .           namespace Gecode { namespace Kernel {
         .           
32,064,623 ( 0.04%)    Support::Mutex& SharedMemory::m(void) {
96,193,873 ( 0.11%)      static Support::Mutex _m;
     1,009 ( 0.00%)  => ???:0x0000000004954a80 (1x)
       935 ( 0.00%)  => ???:0x0000000004954730 (1x)
32,064,622 ( 0.04%)      return _m;
32,064,623 ( 0.04%)    }
         .           
         .             void
88,177,815 ( 0.10%)    MemoryManager::alloc_refill(SharedMemory& sm, size_t sz) {
         .               // Try to reuse the not used memory
16,032,330 ( 0.02%)      reuse(start,lsz);
         .               alloc_fill(sm,sz,false);
64,129,320 ( 0.07%)    }
         .           
         3 ( 0.00%)  }}
         .           
         .           // STATISTICS: kernel-memory
         .           
         .           

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/int/distinct/val.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 34 ----------------------------------------
          .           namespace Gecode { namespace Int { namespace Distinct {
          .           
          .             /*
          .              * Eliminating singleton variables
          .              *
          .              */
          .             template<class View, bool complete>
          .             ExecStatus
 76,885,276 ( 0.09%)    prop_val(Space& home, ViewArray<View>& x) {
          .               assert(x.size() > 1);
          .               int n = x.size();
          .           
          .               Region r;
          .               int* stack = r.alloc<int>(n);
          .               int* c_v = &stack[0];
          .               // c_n is the current number of values on stack
          .               int c_n = 0;
          .           
          .               // Collect all assigned variables on stack
154,604,760 ( 0.17%)      for (int i=n; i--; )
 55,755,824 ( 0.06%)        if (x[i].assigned()) {
 48,190,980 ( 0.05%)          c_v[c_n++]=x[i].val(); x[i]=x[--n];
          .                 }
          .           
          .               // The number of trips
          .               int t = 0;
          .               do {
          .                 t++;
     24,106 ( 0.00%)        if (!complete && (t > 16)) {
          .                   // Give up after sixteen iterations, but the values must be
          .                   // propagated first
          .                   // Maybe we are lucky in that this iteration does the trick...
          .                   ExecStatus es = ES_FIX;
          .                   while (c_n > 0) {
          .                     int v = c_v[--c_n];
          .                     // Check whether value is on stack only once
          .                     for (int i=0; i<c_n; i++)
-- line 70 ----------------------------------------
-- line 71 ----------------------------------------
          .                       if (c_v[i] == v)
          .                         goto failed;
          .                     // Tell and do not collect new values
          .                     for (int i=0; i<n; i++) {
          .                       ModEvent me = x[i].nq(home,v);
          .                       if (me_failed(me))
          .                         goto failed;
          .                       if (me == ME_INT_VAL)
  5,914,252 ( 0.01%)                es = ES_NOFIX;
          .                     }
          .                   }
          .                   x.size(n);
          .                   return es;
          .                 }
 11,852,610 ( 0.01%)        if (c_n > 31) {
          .                   // Many values, use full domain operation
          .                   IntSet d(&c_v[0],c_n);
          .                   // If the size s of d is different from the number of values,
          .                   // a value must have appeared multiply: failure
          .                   if (d.size() != static_cast<unsigned int>(c_n))
          .                     goto failed;
          .                   // We do not need the values on the stack any longer, reset
          .                   c_n = 0;
-- line 93 ----------------------------------------
-- line 99 ----------------------------------------
          .                       if (me_failed(me))
          .                         goto failed;
          .                       if (me == ME_INT_VAL) {
          .                         c_v[c_n++]=x[i].val(); x[i]=x[--n];
          .                       }
          .                     }
          .                 } else {
          .                   // Values for next iteration
 17,778,915 ( 0.02%)          int* n_v = &c_v[c_n];
          .                   // Stack top for the next iteration
 11,852,610 ( 0.01%)          int n_n = 0;
 32,924,418 ( 0.04%)          while (c_n > 0) {
 12,111,132 ( 0.01%)            int v = c_v[--c_n];
          .                     // Check whether value is not on current stack
 24,598,262 ( 0.03%)            for (int i=0; i<c_n; i++)
  2,514,086 ( 0.00%)              if (c_v[i] == v)
          .                         goto failed;
          .                     // Check whether value is not on next stack
 15,151,215 ( 0.02%)            for (int i=0; i<n_n; i++)
      1,632 ( 0.00%)              if (n_v[i] == v)
          .                         goto failed;
          .                     // Tell and collect new values
104,321,708 ( 0.12%)            for (int i = n; i--; ) {
          .                       ModEvent me = x[i].nq(home,v);
 35,144,698 ( 0.04%)              if (me_failed(me))
          .                         goto failed;
 35,144,698 ( 0.04%)              if (me == ME_INT_VAL) {
    108,477 ( 0.00%)                n_v[n_n++]=x[i].val(); x[i]=x[--n];
          .                       }
          .                     }
          .                   }
  9,838,480 ( 0.01%)          c_v = n_v; c_n = n_n;
          .                 }
 14,757,720 ( 0.02%)      } while (c_n > 0);
          .               x.size(n);
  9,814,374 ( 0.01%)      return ES_FIX;
          .             failed:
          .               x.size(0);
  2,014,130 ( 0.00%)      return ES_FAILED;
 70,971,024 ( 0.08%)    }
          .           
          .           
          .             /*
          .              * The propagator proper
          .              *
          .              */
          .             template<class View>
          .             forceinline
-- line 146 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view-val.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 38 ----------------------------------------
          .              *
          .              * Implements view-based brancher for an array of views and value.
          .              * \ingroup TaskActor
          .              */
          .           
          .             //@{
          .             /// %Choice storing position and value
          .             template<class Val>
  8,043,673 ( 0.01%)    class GECODE_VTABLE_EXPORT PosValChoice : public PosChoice {
          .             private:
          .               /// Value to assign to
          .               const Val _val;
          .             public:
          .               /// Initialize choice for brancher \a b, number of alternatives \a a, position \a p, and value \a n
          .               PosValChoice(const Brancher& b, unsigned int a, const Pos& p, const Val& n);
          .               const Val& val(void) const;
          .               /// Archive into \a e
-- line 54 ----------------------------------------
-- line 153 ----------------------------------------
          .             /*
          .              * %Choice with position and value
          .              *
          .              */
          .             template<class Val>
          .             forceinline
          .             PosValChoice<Val>::PosValChoice(const Brancher& b, unsigned int a,
          .                                             const Pos& p, const Val& n)
 24,131,043 ( 0.03%)      : PosChoice(b,a,p), _val(n) {}
          .           
          .             template<class Val>
          .             forceinline const Val&
          .             PosValChoice<Val>::val(void) const {
          .               return _val;
          .             }
          .           
          .             template<class Val>
-- line 169 ----------------------------------------
-- line 226 ----------------------------------------
          .             forceinline
          .             ViewValBrancher<View,n,Val,a,Filter,Print>::
          .             ViewValBrancher(Home home,
          .                             ViewArray<View>& x,
          .                             ViewSel<View>* vs[n],
          .                             ValSelCommitBase<View,Val>* vsc0,
          .                             BranchFilter<Var> bf,
          .                             VarValPrint<Var,Val> vvp)
         16 ( 0.00%)      : ViewBrancher<View,Filter,n>(home,x,vs,bf), vsc(vsc0), p(vvp) {
         12 ( 0.00%)      if (vsc->notice() || f.notice() || p.notice())
         12 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/val-sel-commit.hpp:Gecode::ValSelCommit<Gecode::Int::Branch::ValSelMin<Gecode::Int::IntView>, Gecode::Int::Branch::ValCommitEq<Gecode::Int::IntView> >::notice() const (4x)
          .                 home.notice(*this,AP_DISPOSE,true);
          .             }
          .           
          .             template<class View, int n, class Val, unsigned int a,
          .                      class Filter, class Print>
          .             forceinline void
          .             ViewValBrancher<View,n,Val,a,Filter,Print>::
          .             post(Home home, ViewArray<View>& x,
-- line 243 ----------------------------------------
-- line 250 ----------------------------------------
          .           
          .             template<class View, int n, class Val, unsigned int a,
          .                      class Filter, class Print>
          .             forceinline
          .             ViewValBrancher<View,n,Val,a,Filter,Print>::
          .             ViewValBrancher(Space& home,
          .                             ViewValBrancher<View,n,Val,a,Filter,Print>& b)
          .               : ViewBrancher<View,Filter,n>(home,b),
112,226,100 ( 0.13%)        vsc(b.vsc->copy(home)), p(b.p) {}
211,472,807 ( 0.24%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/val-sel-commit.hpp:Gecode::ValSelCommit<Gecode::Int::Branch::ValSelMin<Gecode::Int::IntView>, Gecode::Int::Branch::ValCommitEq<Gecode::Int::IntView> >::copy(Gecode::Space&) (16,032,300x)
          .           
          .             template<class View, int n, class Val, unsigned int a,
          .                      class Filter, class Print>
          .             Actor*
128,258,400 ( 0.14%)    ViewValBrancher<View,n,Val,a,Filter,Print>::copy(Space& home) {
          .               return new (home) ViewValBrancher<View,n,Val,a,Filter,Print>
          .                 (home,*this);
112,226,100 ( 0.13%)    }
          .           
          .             template<class View, int n, class Val, unsigned int a,
          .                      class Filter, class Print>
          .             const Choice*
 56,305,767 ( 0.06%)    ViewValBrancher<View,n,Val,a,Filter,Print>::choice(Space& home) {
          .               Pos p = ViewBrancher<View,Filter,n>::pos(home);
          .               View v = ViewBrancher<View,Filter,n>::view(p);
 48,262,086 ( 0.05%)      return new PosValChoice<Val>(*this,a,p,vsc->val(home,v,p.pos));
 24,131,043 ( 0.03%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/val-sel-commit.hpp:Gecode::ValSelCommit<Gecode::Int::Branch::ValSelMin<Gecode::Int::IntView>, Gecode::Int::Branch::ValCommitEq<Gecode::Int::IntView> >::val(Gecode::Space const&, Gecode::Int::IntView, int) (8,043,681x)
 40,218,405 ( 0.04%)    }
          .           
          .             template<class View, int n, class Val, unsigned int a,
          .                      class Filter, class Print>
          .             const Choice*
          .             ViewValBrancher<View,n,Val,a,Filter,Print>::choice(const Space& home,
          .                                                                Archive& e) {
          .               (void) home;
          .               int p; e >> p;
          .               Val v; e >> v;
          .               return new PosValChoice<Val>(*this,a,p,v);
          .             }
          .           
          .             template<class View, int n, class Val, unsigned int a,
          .                      class Filter, class Print>
          .             ExecStatus
110,179,524 ( 0.12%)    ViewValBrancher<View,n,Val,a,Filter,Print>
          .             ::commit(Space& home, const Choice& c, unsigned int b) {
          .               const PosValChoice<Val>& pvc
          .                 = static_cast<const PosValChoice<Val>&>(c);
165,269,286 ( 0.18%)      return me_failed(vsc->commit(home,b,
4,518,183,761 ( 5.05%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/val-sel-commit.hpp:Gecode::ValSelCommit<Gecode::Int::Branch::ValSelMin<Gecode::Int::IntView>, Gecode::Int::Branch::ValCommitEq<Gecode::Int::IntView> >::commit(Gecode::Space&, unsigned int, Gecode::Int::IntView, int, int) (27,544,881x)
          .                                            ViewBrancher<View,Filter,n>::view(pvc.pos()),
 55,089,762 ( 0.06%)                                   pvc.pos().pos,
          .                                            pvc.val()))
 27,544,881 ( 0.03%)        ? ES_FAILED : ES_OK;
 55,089,762 ( 0.06%)    }
          .           
          .             template<class View, int n, class Val, unsigned int a,
          .                      class Filter, class Print>
          .             NGL*
          .             ViewValBrancher<View,n,Val,a,Filter,Print>
          .             ::ngl(Space& home, const Choice& c, unsigned int b) const {
          .               const PosValChoice<Val>& pvc
          .                 = static_cast<const PosValChoice<Val>&>(c);
-- line 308 ----------------------------------------
-- line 323 ----------------------------------------
          .                 p(home,*this,b,xi,pvc.pos().pos,pvc.val(),o);
          .               else
          .                 vsc->print(home,b,xi,pvc.pos().pos,pvc.val(),o);
          .             }
          .           
          .             template<class View, int n, class Val, unsigned int a,
          .                      class Filter, class Print>
          .             forceinline size_t
 96,193,740 ( 0.11%)    ViewValBrancher<View,n,Val,a,Filter,Print>::dispose(Space& home) {
 48,096,870 ( 0.05%)      if (vsc->notice() || f.notice() || p.notice())
 48,096,870 ( 0.05%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/val-sel-commit.hpp:Gecode::ValSelCommit<Gecode::Int::Branch::ValSelMin<Gecode::Int::IntView>, Gecode::Int::Branch::ValCommitEq<Gecode::Int::IntView> >::notice() const (16,032,290x)
          .                 home.ignore(*this,AP_DISPOSE,true);
 64,129,160 ( 0.07%)      vsc->dispose(home);
 32,064,580 ( 0.04%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/val-sel-commit.hpp:Gecode::ValSelCommit<Gecode::Int::Branch::ValSelMin<Gecode::Int::IntView>, Gecode::Int::Branch::ValCommitEq<Gecode::Int::IntView> >::dispose(Gecode::Space&) (16,032,290x)
          .               (void) ViewBrancher<View,Filter,n>::dispose(home);
          .               return sizeof(ViewValBrancher<View,n,Val,a,Filter,Print>);
 80,161,450 ( 0.09%)    }
          .           
          .             template<class View, int n, class Val, unsigned int a>
          .             forceinline void
          .             postviewvalbrancher(Home home,
          .                                 ViewArray<View>& x,
          .                                 ViewSel<View>* vs[n],
          .                                 ValSelCommitBase<View,Val>* vsc,
          .                                 BranchFilter<typename View::VarType> bf,
          .                                 VarValPrint<typename View::VarType,Val> vvp) {
          8 ( 0.00%)      if (bf) {
          .                 if (vvp) {
          .                   ViewValBrancher<View,n,Val,a,
          .                     BrancherFilter<View>,BrancherPrint<View,Val> >
          .                     ::post(home,x,vs,vsc,bf,vvp);
          .                 } else {
          .                   ViewValBrancher<View,n,Val,a,
          .                     BrancherFilter<View>,BrancherNoPrint<View,Val> >
          .                     ::post(home,x,vs,vsc,bf,vvp);
          .                   }
          .               } else {
          8 ( 0.00%)        if (vvp)
          .                   ViewValBrancher<View,n,Val,a,
          .                     BrancherNoFilter<View>,BrancherPrint<View,Val> >
          .                     ::post(home,x,vs,vsc,bf,vvp);
          .                 else
          .                   ViewValBrancher<View,n,Val,a,
          .                     BrancherNoFilter<View>,BrancherNoPrint<View,Val> >
          .                     ::post(home,x,vs,vsc,bf,vvp);
          .               }
-- line 366 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/basic_string.h
--------------------------------------------------------------------------------
Ir                  

-- line 157 ----------------------------------------
         .                 // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
         .                 struct _Alloc_hider : allocator_type // TODO check __is_final
         .                 {
         .           #if __cplusplus < 201103L
         .           	_Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())
         .           	: allocator_type(__a), _M_p(__dat) { }
         .           #else
         .           	_Alloc_hider(pointer __dat, const _Alloc& __a)
     1,268 ( 0.00%)  	: allocator_type(__a), _M_p(__dat) { }
         .           
         .           	_Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())
31,984,364 ( 0.04%)  	: allocator_type(std::move(__a)), _M_p(__dat) { }
         .           #endif
         .           
         .           	pointer _M_p; // The actual data.
         .                 };
         .           
         .                 _Alloc_hider	_M_dataplus;
         .                 size_type		_M_string_length;
         .           
-- line 176 ----------------------------------------
-- line 179 ----------------------------------------
         .                 union
         .                 {
         .           	_CharT           _M_local_buf[_S_local_capacity + 1];
         .           	size_type        _M_allocated_capacity;
         .                 };
         .           
         .                 void
         .                 _M_data(pointer __p)
     1,266 ( 0.00%)        { _M_dataplus._M_p = __p; }
         .           
         .                 void
         .                 _M_length(size_type __length)
15,974,316 ( 0.02%)        { _M_string_length = __length; }
         .           
         .                 pointer
         .                 _M_data() const
15,975,457 ( 0.02%)        { return _M_dataplus._M_p; }
         .           
         .                 pointer
        44 ( 0.00%)        _M_local_data()
         .                 {
         .           #if __cplusplus >= 201103L
     1,874 ( 0.00%)  	return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);
         .           #else
         .           	return pointer(_M_local_buf);
         .           #endif
         .                 }
         .           
         .                 const_pointer
         .                 _M_local_data() const
         .                 {
         .           #if __cplusplus >= 201103L
     1,360 ( 0.00%)  	return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);
         .           #else
         .           	return const_pointer(_M_local_buf);
         .           #endif
         .                 }
         .           
         .                 void
         .                 _M_capacity(size_type __capacity)
       840 ( 0.00%)        { _M_allocated_capacity = __capacity; }
         .           
         .                 void
         .                 _M_set_length(size_type __n)
         .                 {
         .           	_M_length(__n);
         .           	traits_type::assign(_M_data()[__n], _CharT());
        11 ( 0.00%)        }
         .           
         .                 bool
         .                 _M_is_local() const
         .                 { return _M_data() == _M_local_data(); }
         .           
         .                 // Create & Destroy
         .                 pointer
         .                 _M_create(size_type&, size_type);
         .           
         .                 void
         .                 _M_dispose()
         .                 {
31,946,818 ( 0.04%)  	if (!_M_is_local())
         .           	  _M_destroy(_M_allocated_capacity);
         .                 }
         .           
         .                 void
         .                 _M_destroy(size_type __size) throw()
     1,462 ( 0.00%)        { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }
         .           
         .                 // _M_construct_aux is used to implement the 21.3.1 para 15 which
         .                 // requires special behaviour if _InIterator is an integral type
         .                 template<typename _InIterator>
         .                   void
         .                   _M_construct_aux(_InIterator __beg, _InIterator __end,
         .           			 std::__false_type)
         .           	{
         .                     typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
        81 ( 0.00%)            _M_construct(__beg, __end, _Tag());
       380 ( 0.00%)  => /usr/include/c++/11/bits/basic_string.tcc:void std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_construct<char*>(char*, char*, std::forward_iterator_tag) [clone .constprop.0] (8x)
         .           	}
         .           
         .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .                 // 438. Ambiguity in the "do the right thing" clause
         .                 template<typename _Integer>
         .                   void
         .                   _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
         .           	{ _M_construct_aux_2(static_cast<size_type>(__beg), __end); }
-- line 263 ----------------------------------------
-- line 322 ----------------------------------------
         .           				       "this->size() (which is %zu)"),
         .           				   __s, __pos, this->size());
         .           	return __pos;
         .                 }
         .           
         .                 void
         .                 _M_check_length(size_type __n1, size_type __n2, const char* __s) const
         .                 {
     1,952 ( 0.00%)  	if (this->max_size() - (this->size() - __n1) < __n2)
         .           	  __throw_length_error(__N(__s));
         .                 }
         .           
         .           
         .                 // NB: _M_limit doesn't check for a bad __pos value.
         .                 size_type
         .                 _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT
         .                 {
-- line 338 ----------------------------------------
-- line 348 ----------------------------------------
         .           		|| less<const _CharT*>()(_M_data() + this->size(), __s));
         .                 }
         .           
         .                 // When __n = 1 way faster than the general multichar
         .                 // traits_type::copy/move/assign.
         .                 static void
         .                 _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
         .                 {
     1,098 ( 0.00%)  	if (__n == 1)
         .           	  traits_type::assign(*__d, *__s);
         .           	else
         .           	  traits_type::copy(__d, __s, __n);
         .                 }
         .           
         .                 static void
         .                 _S_move(_CharT* __d, const _CharT* __s, size_type __n)
         .                 {
-- line 364 ----------------------------------------
-- line 403 ----------------------------------------
         .                 static void
         .                 _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
         .                 _GLIBCXX_NOEXCEPT
         .                 { _S_copy(__p, __k1, __k2 - __k1); }
         .           
         .                 static int
         .                 _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
         .                 {
     1,150 ( 0.00%)  	const difference_type __d = difference_type(__n1 - __n2);
         .           
     1,848 ( 0.00%)  	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
         .           	  return __gnu_cxx::__numeric_traits<int>::__max;
     1,848 ( 0.00%)  	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
         .           	  return __gnu_cxx::__numeric_traits<int>::__min;
         .           	else
       759 ( 0.00%)  	  return int(__d);
         .                 }
         .           
         .                 void
         .                 _M_assign(const basic_string&);
         .           
         .                 void
         .                 _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
         .           		size_type __len2);
-- line 426 ----------------------------------------
-- line 451 ----------------------------------------
         .           
         .                 /**
         .                  *  @brief  Construct string with copy of value of @a __str.
         .                  *  @param  __str  Source string.
         .                  */
         .                 basic_string(const basic_string& __str)
         .                 : _M_dataplus(_M_local_data(),
         .           		    _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
       124 ( 0.00%)        { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
         .           
         .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .                 // 2583. no way to supply an allocator for basic_string(str, pos)
         .                 /**
         .                  *  @brief  Construct string as copy of a substring.
         .                  *  @param  __str  Source string.
         .                  *  @param  __pos  Index of first character to copy from.
         .                  *  @param  __a  Allocator to use.
-- line 467 ----------------------------------------
-- line 525 ----------------------------------------
         .                  *  @param  __s  Source C string.
         .                  *  @param  __a  Allocator to use (default is default allocator).
         .                  */
         .           #if __cpp_deduction_guides && ! defined _GLIBCXX_DEFINING_STRING_INSTANTIATIONS
         .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .                 // 3076. basic_string CTAD ambiguity
         .                 template<typename = _RequireAllocator<_Alloc>>
         .           #endif
     2,513 ( 0.00%)        basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
         .                 : _M_dataplus(_M_local_data(), __a)
         .                 {
     1,130 ( 0.00%)  	const _CharT* __end = __s ? __s + traits_type::length(__s)
         .           	  // We just need a non-null pointer here to get an exception:
         .           	  : reinterpret_cast<const _CharT*>(__alignof__(_CharT));
         .           	_M_construct(__s, __end, random_access_iterator_tag());
     2,826 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief  Construct string as multiple characters.
         .                  *  @param  __n  Number of characters.
         .                  *  @param  __c  Character to use.
         .                  *  @param  __a  Allocator to use (default is default allocator).
         .                  */
         .           #if __cpp_deduction_guides && ! defined _GLIBCXX_DEFINING_STRING_INSTANTIATIONS
-- line 548 ----------------------------------------
-- line 560 ----------------------------------------
         .                  *  @param  __str  Source string.
         .                  *
         .                  *  The newly-created string contains the exact contents of @a __str.
         .                  *  @a __str is a valid, but unspecified string.
         .                  */
         .                 basic_string(basic_string&& __str) noexcept
         .                 : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
         .                 {
     1,238 ( 0.00%)  	if (__str._M_is_local())
         .           	  {
         .           	    traits_type::copy(_M_local_buf, __str._M_local_buf,
         .           			      _S_local_capacity + 1);
         .           	  }
         .           	else
         .           	  {
         .           	    _M_data(__str._M_data());
         .           	    _M_capacity(__str._M_allocated_capacity);
-- line 576 ----------------------------------------
-- line 664 ----------------------------------------
         .           	basic_string(const _Tp& __t, const _Alloc& __a = _Alloc())
         .           	: basic_string(__sv_wrapper(_S_to_string_view(__t)), __a) { }
         .           #endif // C++17
         .           
         .                 /**
         .                  *  @brief  Destroy the string instance.
         .                  */
         .                 ~basic_string()
         2 ( 0.00%)        { _M_dispose(); }
         .           
         .                 /**
         .                  *  @brief  Assign the value of @a str to this string.
         .                  *  @param  __str  Source string.
         .                  */
         .                 basic_string&
         .                 operator=(const basic_string& __str)
         .                 {
-- line 680 ----------------------------------------
-- line 724 ----------------------------------------
         .           	    // Destroy existing storage before replacing allocator.
         .           	    _M_destroy(_M_allocated_capacity);
         .           	    _M_data(_M_local_data());
         .           	    _M_set_length(0);
         .           	  }
         .           	// Replace allocator if POCMA is true.
         .           	std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());
         .           
        22 ( 0.00%)  	if (__str._M_is_local())
         .           	  {
         .           	    // We've always got room for a short string, just copy it
         .           	    // (unless this is a self-move, because that would violate the
         .           	    // char_traits::copy precondition that the ranges don't overlap).
        16 ( 0.00%)  	    if (__builtin_expect(std::__addressof(__str) != this, true))
         .           	      {
        22 ( 0.00%)  		if (__str.size())
         .           		  this->_S_copy(_M_data(), __str._M_data(), __str.size());
         .           		_M_set_length(__str.size());
         .           	      }
         .           	  }
         .           	else if (_Alloc_traits::_S_propagate_on_move_assign()
         .           	    || _Alloc_traits::_S_always_equal()
         .           	    || _M_get_allocator() == __str._M_get_allocator())
         .           	  {
-- line 747 ----------------------------------------
-- line 913 ----------------------------------------
         .           #endif
         .           
         .               public:
         .                 // Capacity:
         .                 ///  Returns the number of characters in the string, not including any
         .                 ///  null-termination.
         .                 size_type
         .                 size() const _GLIBCXX_NOEXCEPT
       104 ( 0.00%)        { return _M_string_length; }
         .           
         .                 ///  Returns the number of characters in the string, not including any
         .                 ///  null-termination.
         .                 size_type
         .                 length() const _GLIBCXX_NOEXCEPT
       415 ( 0.00%)        { return _M_string_length; }
         .           
         .                 ///  Returns the size() of the largest possible %string.
         .                 size_type
         .                 max_size() const _GLIBCXX_NOEXCEPT
         .                 { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
         .           
         .                 /**
         .                  *  @brief  Resizes the %string to the specified number of characters.
-- line 935 ----------------------------------------
-- line 1206 ----------------------------------------
         .           
         .                 /**
         .                  *  @brief  Append a string to this string.
         .                  *  @param __str  The string to append.
         .                  *  @return  Reference to this string.
         .                  */
         .                 basic_string&
         .                 append(const basic_string& __str)
     1,936 ( 0.00%)        { return _M_append(__str._M_data(), __str.size()); }
    22,765 ( 0.00%)  => ???:0x0000000004867130 (484x)
         .           
         .                 /**
         .                  *  @brief  Append a substring.
         .                  *  @param __str  The string to append.
         .                  *  @param __pos  Index of the first character of str to append.
         .                  *  @param __n  The number of characters to append.
         .                  *  @return  Reference to this string.
         .                  *  @throw  std::out_of_range if @a __pos is not a valid index.
-- line 1222 ----------------------------------------
-- line 1238 ----------------------------------------
         .                  *  @param __n  The number of characters to append.
         .                  *  @return  Reference to this string.
         .                  */
         .                 basic_string&
         .                 append(const _CharT* __s, size_type __n)
         .                 {
         .           	__glibcxx_requires_string_len(__s, __n);
         .           	_M_check_length(size_type(0), __n, "basic_string::append");
     1,936 ( 0.00%)  	return _M_append(__s, __n);
    26,531 ( 0.00%)  => ???:0x0000000004867130 (484x)
         .                 }
         .           
         .                 /**
         .                  *  @brief  Append a C string.
         .                  *  @param __s  The C string to append.
         .                  *  @return  Reference to this string.
         .                  */
         .                 basic_string&
         .                 append(const _CharT* __s)
         .                 {
         .           	__glibcxx_requires_string(__s);
         .           	const size_type __n = traits_type::length(__s);
         .           	_M_check_length(size_type(0), __n, "basic_string::append");
        16 ( 0.00%)  	return _M_append(__s, __n);
       212 ( 0.00%)  => ???:0x0000000004867130 (4x)
         .                 }
         .           
         .                 /**
         .                  *  @brief  Append multiple characters.
         .                  *  @param __n  The number of characters to append.
         .                  *  @param __c  The character to use.
         .                  *  @return  Reference to this string.
         .                  *
-- line 1268 ----------------------------------------
-- line 1379 ----------------------------------------
         .           		    _M_data(__ptr);
         .           		    _M_capacity(__len);
         .           		    _M_set_length(__len);
         .           		  }
         .           	      }
         .           	    std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
         .           	  }
         .           #endif
        48 ( 0.00%)  	this->_M_assign(__str);
    11,447 ( 0.00%)  => ???:0x0000000004867d60 (44x)
         .           	return *this;
         .                 }
         .           
         .           #if __cplusplus >= 201103L
         .                 /**
         .                  *  @brief  Set value to contents of another string.
         .                  *  @param  __str  Source string to use.
         .                  *  @return  Reference to this string.
-- line 1395 ----------------------------------------
-- line 1952 ----------------------------------------
         .                  *  thrown.  The value of the string doesn't change if an error
         .                  *  is thrown.
         .                 */
         .                 basic_string&
         .                 replace(size_type __pos, size_type __n1, const _CharT* __s,
         .           	      size_type __n2)
         .                 {
         .           	__glibcxx_requires_string_len(__s, __n2);
       100 ( 0.00%)  	return _M_replace(_M_check(__pos, "basic_string::replace"),
     1,407 ( 0.00%)  => ???:0x0000000004866ab0 (22x)
         .           			  _M_limit(__pos, __n1), __s, __n2);
         .                 }
         .           
         .                 /**
         .                  *  @brief  Replace characters with value of a C string.
         .                  *  @param __pos  Index of first character to replace.
         .                  *  @param __n1  Number of characters to be replaced.
         .                  *  @param __s  C string to insert.
-- line 1968 ----------------------------------------
-- line 2865 ----------------------------------------
         .                  *  string is ordered after @a __str.  Determines the effective
         .                  *  length rlen of the strings to compare as the smallest of
         .                  *  size() and str.size().  The function then compares the two
         .                  *  strings by calling traits::compare(data(), str.data(),rlen).
         .                  *  If the result of the comparison is nonzero returns it,
         .                  *  otherwise the shorter one is ordered first.
         .                 */
         .                 int
    36,116 ( 0.00%)        compare(const basic_string& __str) const
         .                 {
         .           	const size_type __size = this->size();
         .           	const size_type __osize = __str.size();
         .           	const size_type __len = std::min(__size, __osize);
         .           
         .           	int __r = traits_type::compare(_M_data(), __str.data(), __len);
    20,296 ( 0.00%)  	if (!__r)
         .           	  __r = _S_compare(__size, __osize);
         .           	return __r;
         .                 }
         .           
         .           #if __cplusplus >= 201703L
         .                 /**
         .                  *  @brief  Compare to a string_view.
         .                  *  @param __svt An object convertible to string_view to compare against.
-- line 2888 ----------------------------------------
-- line 6229 ----------------------------------------
         .               { return __lhs.compare(__rhs) == 0; }
         .           
         .             template<typename _CharT>
         .               inline
         .               typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
         .               operator==(const basic_string<_CharT>& __lhs,
         .           	       const basic_string<_CharT>& __rhs) _GLIBCXX_NOEXCEPT
         .               { return (__lhs.size() == __rhs.size()
       298 ( 0.00%)  	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
         .           						    __lhs.size())); }
         .           
         .             /**
         .              *  @brief  Test equivalence of string and C string.
         .              *  @param __lhs  String.
         .              *  @param __rhs  C string.
         .              *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.
         .              */
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               inline bool
         .               operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
         .           	       const _CharT* __rhs)
       586 ( 0.00%)      { return __lhs.compare(__rhs) == 0; }
     7,188 ( 0.00%)  => ???:0x00000000048675b0 (102x)
         .           
         .           #if __cpp_lib_three_way_comparison
         .             /**
         .              *  @brief  Three-way comparison of a string and a C string.
         .              *  @param __lhs  A string.
         .              *  @param __rhs  A null-terminated string.
         .              *  @return  A value indicating whether `__lhs` is less than, equal to,
         .              *	       greater than, or incomparable with `__rhs`.
-- line 6258 ----------------------------------------
-- line 6332 ----------------------------------------
         .             /**
         .              *  @brief  Test if string precedes string.
         .              *  @param __lhs  First string.
         .              *  @param __rhs  Second string.
         .              *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
         .              */
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               inline bool
     8,264 ( 0.00%)      operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
         .           	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
         .               _GLIBCXX_NOEXCEPT
         .               { return __lhs.compare(__rhs) < 0; }
         .           
         .             /**
         .              *  @brief  Test if string precedes C string.
         .              *  @param __lhs  String.
         .              *  @param __rhs  C string.
-- line 6348 ----------------------------------------
-- line 6528 ----------------------------------------
         .              */
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               inline basic_ostream<_CharT, _Traits>&
         .               operator<<(basic_ostream<_CharT, _Traits>& __os,
         .           	       const basic_string<_CharT, _Traits, _Alloc>& __str)
         .               {
         .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .                 // 586. string inserter not a formatted function
       154 ( 0.00%)        return __ostream_insert(__os, __str.data(), __str.size());
     5,177 ( 0.00%)  => ???:0x0000000004867900 (22x)
         .               }
         .           
         .             /**
         .              *  @brief  Read a line from stream into a string.
         .              *  @param __is  Input stream.
         .              *  @param __str  Buffer to store into.
         .              *  @param __delim  Character marking end of line.
         .              *  @return  Reference to the input stream.
-- line 6544 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 620 ----------------------------------------
          .               template<class T> static const ActorLink* cast(const T* a);
          .             };
          .           
          .           
          .             /**
          .              * \brief Base-class for both propagators and branchers
          .              * \ingroup TaskActor
          .              */
 96,847,998 ( 0.11%)    class GECODE_VTABLE_EXPORT Actor : private ActorLink {
          .               friend class ActorLink;
          .               friend class Space;
          .               friend class Propagator;
          .               friend class Advisor;
          .               friend class Brancher;
          .               friend class LocalObject;
          .               template<class VIC> friend class VarImp;
          .               template<class A> friend class Council;
-- line 636 ----------------------------------------
-- line 2821 ----------------------------------------
          .             /*
          .              * Memory management
          .              *
          .              */
          .           
          .             // Space allocation: general space heaps and free lists
          .             forceinline void*
          .             Space::ralloc(size_t s) {
208,761,933 ( 0.23%)      return mm.alloc(ssd.data().sm,s);
          .             }
          .             forceinline void
          .             Space::rfree(void* p, size_t s) {
          .               return mm.reuse(p,s);
          .             }
          .             forceinline void*
          .             Space::rrealloc(void* _b, size_t n, size_t m) {
          .               char* b = static_cast<char*>(_b);
-- line 2837 ----------------------------------------
-- line 2844 ----------------------------------------
          .                 rfree(b+m,m-n);
          .                 return b;
          .               }
          .             }
          .           
          .             template<size_t s>
          .             forceinline void*
          .             Space::fl_alloc(void) {
  8,638,115 ( 0.01%)      return mm.template fl_alloc<s>(ssd.data().sm);
          .             }
          .             template<size_t s>
          .             forceinline void
          .             Space::fl_dispose(FreeList* f, FreeList* l) {
          .               mm.template fl_dispose<s>(f,l);
          .             }
          .           
          .             /*
          .              * Typed allocation routines
          .              *
          .              */
          .             template<class T>
          .             forceinline T*
          .             Space::alloc(long unsigned int n) {
143,800,440 ( 0.16%)      T* p = static_cast<T*>(ralloc(sizeof(T)*n));
267,564,931 ( 0.30%)      for (long unsigned int i=0; i<n; i++)
         21 ( 0.00%)  => ???:0x0000000004866660 (1x)
          .                 (void) new (p+i) T();
          .               return p;
          .             }
          .             template<class T>
          .             forceinline T*
          .             Space::alloc(long int n) {
          .               assert(n >= 0);
          .               return alloc<T>(static_cast<long unsigned int>(n));
          .             }
          .             template<class T>
          .             forceinline T*
          .             Space::alloc(unsigned int n) {
  8,016,189 ( 0.01%)      return alloc<T>(static_cast<long unsigned int>(n));
          .             }
          .             template<class T>
          .             forceinline T*
          .             Space::alloc(int n) {
          .               assert(n >= 0);
  9,710,323 ( 0.01%)      return alloc<T>(static_cast<long unsigned int>(n));
          .             }
          .           
          .             template<class T>
          .             forceinline void
          .             Space::free(T* b, long unsigned int n) {
          .               for (long unsigned int i=0; i<n; i++)
          .                 b[i].~T();
 28,658,419 ( 0.03%)      rfree(b,n*sizeof(T));
          .             }
          .             template<class T>
          .             forceinline void
          .             Space::free(T* b, long int n) {
          .               assert(n >= 0);
          .               free<T>(b,static_cast<long unsigned int>(n));
          .             }
          .             template<class T>
          .             forceinline void
          .             Space::free(T* b, unsigned int n) {
 28,658,380 ( 0.03%)      free<T>(b,static_cast<long unsigned int>(n));
          .             }
          .             template<class T>
          .             forceinline void
          .             Space::free(T* b, int n) {
          .               assert(n >= 0);
          .               free<T>(b,static_cast<long unsigned int>(n));
          .             }
          .           
-- line 2914 ----------------------------------------
-- line 3074 ----------------------------------------
          .           
          .           
          .             /*
          .              * No-goods
          .              *
          .              */
          .             forceinline
          .             NoGoods::NoGoods(void)
          7 ( 0.00%)      : n(0) {}
          .             forceinline unsigned long int
          .             NoGoods::ng(void) const {
          .               return n;
          .             }
          .             forceinline void
          .             NoGoods::ng(unsigned long int n0) {
     20,483 ( 0.00%)      n=n0;
          .             }
          .             forceinline
          2 ( 0.00%)    NoGoods::~NoGoods(void) {}
          .           
          .           
          .             /*
          .              * Information from meta search engines
          .              */
          .             forceinline
          1 ( 0.00%)    MetaInfo::MetaInfo(unsigned long int r0,
          .                                RestartReason rr0,
          .                                unsigned long long int s0,
          .                                unsigned long long int f0,
          .                                const Space* l0,
          .                                NoGoods& ng0)
    122,908 ( 0.00%)      : t(RESTART), r(r0), rr(rr0), s(s0), f(f0), l(l0), ng(ng0), a(0) {}
          .           
          .             forceinline
          .             MetaInfo::MetaInfo(unsigned int a0)
          .               : t(PORTFOLIO), r(0), rr(RR_NO), s(0), f(0), l(nullptr), ng(NoGoods::eng), a(a0) {}
          .           
          .             forceinline MetaInfo::Type
          .             MetaInfo::type(void) const {
     20,483 ( 0.00%)      return t;
          .             }
          .             forceinline unsigned long int
          .             MetaInfo::restart(void) const {
          .               assert(type() == RESTART);
          .               return r;
          .             }
          .             forceinline MetaInfo::RestartReason
          .             MetaInfo::reason(void) const {
-- line 3121 ----------------------------------------
-- line 3129 ----------------------------------------
          .             forceinline unsigned long long int
          .             MetaInfo::fail(void) const {
          .               assert(type() == RESTART);
          .               return f;
          .             }
          .             forceinline const Space*
          .             MetaInfo::last(void) const {
          .               assert(type() == RESTART);
     40,966 ( 0.00%)      return l;
          .             }
          .             forceinline const NoGoods&
          .             MetaInfo::nogoods(void) const {
          .               assert(type() == RESTART);
     20,483 ( 0.00%)      return ng;
          .             }
          .             forceinline unsigned int
          .             MetaInfo::asset(void) const {
          .               assert(type() == PORTFOLIO);
          .               return a;
          .             }
          .           
          .           
          .           
          .             /*
          .              * ActorLink
          .              *
          .              */
          .             forceinline ActorLink*
          .             ActorLink::prev(void) const {
114,247,090 ( 0.13%)      return _prev;
          .             }
          .           
          .             forceinline ActorLink*
          .             ActorLink::next(void) const {
220,655,931 ( 0.25%)      return _next;
          .             }
          .           
          .             forceinline ActorLink**
          .             ActorLink::next_ref(void) {
          .               return &_next;
          .             }
          .           
          .             forceinline void
          .             ActorLink::prev(ActorLink* al) {
 80,597,640 ( 0.09%)      _prev = al;
          .             }
          .           
          .             forceinline void
          .             ActorLink::next(ActorLink* al) {
 48,314,974 ( 0.05%)      _next = al;
          .             }
          .           
          .             forceinline void
          .             ActorLink::unlink(void) {
185,916,224 ( 0.21%)      ActorLink* p = _prev; ActorLink* n = _next;
185,916,224 ( 0.21%)      p->_next = n; n->_prev = p;
          .             }
          .           
          .             forceinline void
          .             ActorLink::init(void) {
  8,016,178 ( 0.01%)      _next = this; _prev =this;
          .             }
          .           
          .             forceinline void
          .             ActorLink::head(ActorLink* a) {
          .               // Inserts al at head of link-chain (that is, after this)
 25,764,387 ( 0.03%)      ActorLink* n = _next;
 25,764,387 ( 0.03%)      this->_next = a; a->_prev = this;
128,671,035 ( 0.14%)      a->_next = n; n->_prev = a;
          .             }
          .           
          .             forceinline void
          .             ActorLink::tail(ActorLink* a) {
          .               // Inserts al at tail of link-chain (that is, before this)
 62,634,381 ( 0.07%)      ActorLink* p = _prev;
125,268,758 ( 0.14%)      a->_next = this; this->_prev = a;
125,268,758 ( 0.14%)      p->_next = a; a->_prev = p;
          .             }
          .           
          .             forceinline bool
          .             ActorLink::empty(void) const {
          2 ( 0.00%)      return _next == this;
          .             }
          .           
          .             template<class T>
          .             forceinline ActorLink*
          .             ActorLink::cast(T* a) {
          .               // Turning al into a reference is for gcc, assume is for MSVC
          .               GECODE_NOT_NULL(a);
 63,466,513 ( 0.07%)      ActorLink& t = *a;
          .               return static_cast<ActorLink*>(&t);
          .             }
          .           
          .             template<class T>
          .             forceinline const ActorLink*
          .             ActorLink::cast(const T* a) {
          .               // Turning al into a reference is for gcc, assume is for MSVC
          .               GECODE_NOT_NULL(a);
-- line 3226 ----------------------------------------
-- line 3233 ----------------------------------------
          .              * Actor
          .              *
          .              */
          .             forceinline Actor*
          .             Actor::cast(ActorLink* al) {
          .               // Turning al into a reference is for gcc, assume is for MSVC
          .               GECODE_NOT_NULL(al);
          .               ActorLink& t = *al;
 64,347,266 ( 0.07%)      return static_cast<Actor*>(&t);
          .             }
          .           
          .             forceinline const Actor*
          .             Actor::cast(const ActorLink* al) {
          .               // Turning al into a reference is for gcc, assume is for MSVC
          .               GECODE_NOT_NULL(al);
          .               const ActorLink& t = *al;
          .               return static_cast<const Actor*>(&t);
-- line 3249 ----------------------------------------
-- line 3254 ----------------------------------------
          .               s.notice(a,p,duplicate);
          .             }
          .           
          .             forceinline Space*
          .             Space::clone(CloneStatistics&) const {
          .               // Clone is only const for search engines. During cloning, several data
          .               // structures are updated (e.g. forwarding pointers), so we have to
          .               // cast away the constness.
 26,088,919 ( 0.03%)      return const_cast<Space*>(this)->_clone();
      9,838 ( 0.00%)  => ???:0x0000000004df15d0 (1x)
          .             }
          .           
          .             forceinline void
          .             Space::commit(const Choice& c, unsigned int a, CommitStatistics&) {
110,407,274 ( 0.12%)      _commit(c,a);
4,371,933,126 ( 4.89%)  => ???:0x0000000004df1740 (19,529,773x)
          .             }
          .           
          .             forceinline void
          .             Space::trycommit(const Choice& c, unsigned int a, CommitStatistics&) {
          .               _trycommit(c,a);
          .             }
          .           
          .             forceinline double
-- line 3275 ----------------------------------------
-- line 3288 ----------------------------------------
          .             }
          .           
          .           
          .             /*
          .              * Home for posting actors
          .              *
          .              */
          .             forceinline
     20,485 ( 0.00%)    Home::Home(Space& s0, Propagator* p0,
          .                        PropagatorGroup pg0, BrancherGroup bg0)
    696,606 ( 0.00%)      : s(s0), p(p0), pg(pg0), bg(bg0) {}
          .             forceinline
          8 ( 0.00%)    Home::Home(const Home& h)
    277,566 ( 0.00%)      : s(h.s), p(h.p), pg(h.pg), bg(h.bg) {}
          .             forceinline Home&
          .             Home::operator =(const Home& h) {
          .               s=h.s; p=h.p; pg=h.pg; bg=h.bg;
          .               return *this;
          .             }
          .             forceinline
          .             Home::operator Space&(void) {
    108,952 ( 0.00%)      return s;
          .             }
          .             forceinline Home
          .             Home::operator ()(Propagator& p) {
          .               return Home(s,&p);
          .             }
          .             forceinline Home
          .             Home::operator ()(PropagatorGroup pg) {
          .               return Home(s,nullptr,pg,BrancherGroup::def);
-- line 3317 ----------------------------------------
-- line 3354 ----------------------------------------
          .               who = reinterpret_cast<ptrdiff_t>(&p) | PROPAGATOR;
          .             }
          .             forceinline void
          .             ViewTraceInfo::brancher(Brancher& b) {
          .               who = reinterpret_cast<ptrdiff_t>(&b) | BRANCHER;
          .             }
          .             forceinline void
          .             ViewTraceInfo::post(PropagatorGroup g) {
    326,838 ( 0.00%)      who = (g.id() << 2) | POST;
          .             }
          .             forceinline void
          .             ViewTraceInfo::other(void) {
 16,141,255 ( 0.02%)      who = OTHER;
    108,946 ( 0.00%)    }
          .             forceinline ViewTraceInfo::What
          .             ViewTraceInfo::what(void) const {
    217,892 ( 0.00%)      return static_cast<What>(who & 3);
          .             }
          .             forceinline const Propagator&
          .             ViewTraceInfo::propagator(void) const {
          .               assert(what() == PROPAGATOR);
          .               // Because PROPAGATOR == 0
          .               return *reinterpret_cast<Propagator*>(who);
          .             }
          .             forceinline const Brancher&
-- line 3378 ----------------------------------------
-- line 3386 ----------------------------------------
          .               return PropagatorGroup(static_cast<unsigned int>(who >> 2));
          .             }
          .           
          .             /*
          .              * Post information
          .              */
          .             forceinline
          .             PostInfo::PostInfo(Home home)
    108,952 ( 0.00%)      : h(home), pg(home.propagatorgroup()),
    108,946 ( 0.00%)        pid(h.ssd.data().gpi.pid()),
    347,323 ( 0.00%)        nested(h.pc.p.vti.what() != ViewTraceInfo::OTHER) {
          .               h.pc.p.vti.post(pg);
          .             }
          .           
          .             forceinline
          .             PostInfo::~PostInfo(void) {
    217,895 ( 0.00%)      if (!nested) {
    326,838 ( 0.00%)        if (h.pc.p.bid_sc & Space::sc_trace)
          .                   h.post(*this);
          .                 h.pc.p.vti.other();
          .               }
          .             }
          .           
          .           
          .             /*
          .              * Propagate trace information
-- line 3411 ----------------------------------------
-- line 3488 ----------------------------------------
          .              * Propagator
          .              *
          .              */
          .             forceinline Propagator*
          .             Propagator::cast(ActorLink* al) {
          .               // Turning al into a reference is for gcc, assume is for MSVC
          .               GECODE_NOT_NULL(al);
          .               ActorLink& t = *al;
122,163,094 ( 0.14%)      return static_cast<Propagator*>(&t);
          .             }
          .           
          .             forceinline const Propagator*
          .             Propagator::cast(const ActorLink* al) {
          .               // Turning al into a reference is for gcc, assume is for MSVC
          .               GECODE_NOT_NULL(al);
          .               const ActorLink& t = *al;
          .               return static_cast<const Propagator*>(&t);
-- line 3504 ----------------------------------------
-- line 3523 ----------------------------------------
          .             forceinline void
          .             Propagator::enable(Space& home) {
          .               (void) home;
          .               gpi_disabled = Support::funmark(gpi_disabled);
          .             }
          .           
          .             forceinline Kernel::GPI::Info&
          .             Propagator::gpi(void) {
 68,871,572 ( 0.08%)      return *static_cast<Kernel::GPI::Info*>(Support::funmark(gpi_disabled));
          .             }
          .           
          .             forceinline
          .             Propagator::Propagator(Home home)
    201,196 ( 0.00%)      : gpi_disabled((home.propagator() != nullptr) ?
          .                              // Inherit propagator information
          .                              home.propagator()->gpi_disabled :
          .                              // New propagator information
          .                              static_cast<Space&>(home).ssd.data().gpi.allocate
    150,900 ( 0.00%)                     (home.propagatorgroup().gid)) {
     50,300 ( 0.00%)      u.advisors = nullptr;
          .               assert((u.med == 0) && (u.size == 0));
    150,900 ( 0.00%)      static_cast<Space&>(home).pl.head(this);
          .             }
          .           
          .             forceinline
          .             Propagator::Propagator(Space&, Propagator& p)
 32,500,732 ( 0.04%)      : gpi_disabled(p.gpi_disabled) {
 16,250,366 ( 0.02%)      u.advisors = nullptr;
          .               assert((u.med == 0) && (u.size == 0));
          .               // Set forwarding pointer
 32,500,732 ( 0.04%)      p.prev(this);
          .             }
          .           
          .             forceinline ModEventDelta
          .             Propagator::modeventdelta(void) const {
          .               return u.med;
          .             }
          .           
          .             forceinline double
-- line 3561 ----------------------------------------
-- line 3587 ----------------------------------------
          .           
          .             forceinline void
          .             Propagator::group(PropagatorGroup g) {
          .               gpi().gid = g.id();
          .             }
          .           
          .             forceinline ExecStatus
          .             Space::ES_SUBSUMED_DISPOSED(Propagator& p, size_t s) {
     50,296 ( 0.00%)      p.u.size = s;
          .               return ES_SUBSUMED_;
          .             }
          .           
          .             forceinline ExecStatus
          .             Space::ES_SUBSUMED(Propagator& p) {
 27,356,124 ( 0.03%)      p.u.size = p.dispose(*this);
 38,404,148 ( 0.04%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/int/linear/int-nary.hpp:Gecode::Int::Linear::Lin<int, Gecode::Int::ScaleView<int, unsigned int>, Gecode::Int::ScaleView<int, unsigned int>, 1>::dispose(Gecode::Space&) (612,755x)
          .               return ES_SUBSUMED_;
          .             }
          .           
          .             forceinline ExecStatus
          .             Space::ES_FIX_PARTIAL(Propagator& p, const ModEventDelta& med) {
  4,876,845 ( 0.01%)      p.u.med = med;
          .               assert(p.u.med != 0);
          .               return ES_PARTIAL_;
          .             }
          .           
          .             forceinline ExecStatus
          .             Space::ES_NOFIX_PARTIAL(Propagator& p, const ModEventDelta& med) {
          .               p.u.med = AllVarConf::med_combine(p.u.med,med);
          .               assert(p.u.med != 0);
-- line 3615 ----------------------------------------
-- line 3622 ----------------------------------------
          .              * Brancher
          .              *
          .              */
          .             forceinline Brancher*
          .             Brancher::cast(ActorLink* al) {
          .               // Turning al into a reference is for gcc, assume is for MSVC
          .               GECODE_NOT_NULL(al);
          .               ActorLink& t = *al;
136,617,019 ( 0.15%)      return static_cast<Brancher*>(&t);
          .             }
          .           
          .             forceinline const Brancher*
          .             Brancher::cast(const ActorLink* al) {
          .               // Turning al into a reference is for gcc, assume is for MSVC
          .               GECODE_NOT_NULL(al);
          .               const ActorLink& t = *al;
          .               return static_cast<const Brancher*>(&t);
          .             }
          .           
          .             forceinline
          .             Brancher::Brancher(Home _home) :
         20 ( 0.00%)      gid(_home.branchergroup().gid) {
          .               Space& home = static_cast<Space&>(_home);
         12 ( 0.00%)      bid = home.pc.p.bid_sc >> Space::sc_bits;
         12 ( 0.00%)      home.pc.p.bid_sc += (1 << Space::sc_bits);
          8 ( 0.00%)      if ((home.pc.p.bid_sc >> Space::sc_bits) == 0U)
          .                 throw TooManyBranchers("Brancher::Brancher");
          .               // If no brancher available, make it the first one
         28 ( 0.00%)      if (home.b_status == &static_cast<Space&>(home).bl) {
          2 ( 0.00%)        home.b_status = this;
         12 ( 0.00%)        if (home.b_commit == &static_cast<Space&>(home).bl)
          4 ( 0.00%)          home.b_commit = this;
          .               }
          4 ( 0.00%)      home.bl.tail(this);
          .             }
          .           
          .             forceinline
          .             Brancher::Brancher(Space&, Brancher& b)
 32,064,600 ( 0.04%)      : bid(b.bid), gid(b.gid) {
          .               // Set forwarding pointer
 32,064,600 ( 0.04%)      b.prev(this);
          .             }
          .           
          .             forceinline unsigned int
          .             Brancher::id(void) const {
          .               return bid;
          .             }
          .           
          .             forceinline BrancherGroup
-- line 3670 ----------------------------------------
-- line 3720 ----------------------------------------
          .                * can be used together, possibly interleaved with
          .                * choices for other branchers. That means all branchers
          .                * must be scanned to find the matching brancher for the choice.
          .                *
          .                * b_commit tries to optimize scanning as it is most likely that
          .                * recomputation does not generate new choices during recomputation
          .                * and hence b_commit is moved from newer to older branchers.
          .                */
 55,089,762 ( 0.06%)      Brancher* b_old = b_commit;
          .               // Try whether we are lucky
110,179,524 ( 0.12%)      while (b_commit != Brancher::cast(&bl))
137,724,405 ( 0.15%)        if (id != b_commit->id())
          .                   b_commit = Brancher::cast(b_commit->next());
          .                 else
          .                   return b_commit;
          .               if (b_commit == Brancher::cast(&bl)) {
          .                 // We did not find the brancher, start at the beginning
          .                 b_commit = Brancher::cast(bl.next());
          .                 while (b_commit != b_old)
          .                   if (id != b_commit->id())
-- line 3739 ----------------------------------------
-- line 3808 ----------------------------------------
          .           
          .           
          .             /*
          .              * Choices
          .              *
          .              */
          .             forceinline
          .             Choice::Choice(const Brancher& b, const unsigned int a)
 24,131,043 ( 0.03%)      : bid(b.id()), alt(a) {}
          .           
          .             forceinline unsigned int
          .             Choice::alternatives(void) const {
 21,913,664 ( 0.02%)      return alt;
          .             }
          .           
          .             forceinline unsigned int
          .             Choice::id(void) const {
          .               return bid;
          .             }
          .           
          .             forceinline
-- line 3828 ----------------------------------------
-- line 3854 ----------------------------------------
          .             NGL::add(NGL* n, bool l) {
          .               nl = Support::marked(nl) ? Support::mark(n) : n;
          .               n->leaf(l);
          .               return n;
          .             }
          .           
          .             forceinline
          .             NGL::NGL(void)
     20,483 ( 0.00%)      : nl(nullptr) {}
          .             forceinline
          .             NGL::NGL(Space&)
          .               : nl(nullptr) {}
          .             forceinline
          .             NGL::NGL(Space&, NGL&)
          .               : nl(nullptr) {}
          .             forceinline size_t
          .             NGL::dispose(Space&) {
-- line 3870 ----------------------------------------
-- line 4064 ----------------------------------------
          .           
          .             /*
          .              * Space
          .              *
          .              */
          .             forceinline void
          .             Space::enqueue(Propagator* p) {
          .               ActorLink::cast(p)->unlink();
603,123,656 ( 0.67%)      ActorLink* c = &pc.p.queue[p->cost(*this,p->u.med).ac];
 68,275,830 ( 0.08%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/int/distinct/bnd.hpp:Gecode::Int::Distinct::Bnd<Gecode::Int::IntView>::cost(Gecode::Space const&, int const&) const (4,876,845x)
          .               c->tail(ActorLink::cast(p));
130,145,597 ( 0.15%)      if (c > pc.p.active)
 25,391,103 ( 0.03%)        pc.p.active = c;
          .             }
          .           
          .             forceinline void
          .             Space::fail(void) {
 31,887,078 ( 0.04%)      pc.p.active = &pc.p.queue[PropCost::AC_MAX+1]+1;
          .               /*
          .                * Now active points beyond the last queue. This is essential as
          .                * enqueuing a propagator in a failed space keeps the space
          .                * failed.
          .                */
          .             }
          .             forceinline void
          .             Home::fail(void) {
          .               s.fail();
          .             }
          .           
          .             forceinline bool
          .             Space::failed(void) const {
112,613,205 ( 0.13%)      return pc.p.active > &pc.p.queue[PropCost::AC_MAX+1];
          .             }
          .             forceinline bool
          .             Home::failed(void) const {
    285,873 ( 0.00%)      return s.failed();
          .             }
          .           
          .             forceinline bool
          .             Space::stable(void) const {
 56,223,194 ( 0.06%)      return ((pc.p.active < &pc.p.queue[0]) ||
  8,043,683 ( 0.01%)              (pc.p.active > &pc.p.queue[PropCost::AC_MAX+1]));
          .             }
          .           
          .             forceinline void
          .             Space::notice(Actor& a, ActorProperty p, bool d) {
          .               if (p & AP_DISPOSE) {
         16 ( 0.00%)        ap_notice_dispose(&a,d);
      1,292 ( 0.00%)  => ???:0x0000000004e94f70 (4x)
          .               }
          .               if (p & AP_VIEW_TRACE) {
          .                 pc.p.bid_sc |= sc_trace;
          .               }
          .               if (p & AP_TRACE) {
          .                 pc.p.bid_sc |= sc_trace;
          .               }
          .               // Currently unused
-- line 4118 ----------------------------------------
-- line 4120 ----------------------------------------
          .                 // Nothing to do
          .               }
          .             }
          .           
          .             forceinline void
          .             Space::ignore(Actor& a, ActorProperty p, bool d) {
          .               // Check whether array has already been discarded as space
          .               // deletion is already in progress
 32,064,580 ( 0.04%)      if ((p & AP_DISPOSE) && (d_fst != nullptr))
         16 ( 0.00%)        ap_ignore_dispose(&a,d);
      1,203 ( 0.00%)  => ???:0x0000000004e95360 (4x)
          .               if (p & AP_VIEW_TRACE) {
          .                 // Nothing to do
          .               }
          .               if (p & AP_TRACE) {
          .                 // Nothing to do
          .               }
          .               // Currently unused
          .               if (p & AP_WEAKLY) {
-- line 4137 ----------------------------------------
-- line 4142 ----------------------------------------
          .           
          .           
          .             /*
          .              * Variable implementation
          .              *
          .              */
          .             template<class VIC>
          .             forceinline ActorLink**
         80 ( 0.00%)    VarImp<VIC>::actor(PropCond pc) {
          .               assert((pc >= 0)  && (pc < pc_max+2));
265,216,749 ( 0.30%)      return (pc == 0) ? b.base : b.base+u.idx[pc-1];
          .             }
          .           
          .             template<class VIC>
          .             forceinline ActorLink**
          .             VarImp<VIC>::actorNonZero(PropCond pc) {
          .               assert((pc > 0)  && (pc < pc_max+2));
568,543,694 ( 0.64%)      return b.base+u.idx[pc-1];
          .             }
          .           
          .             template<class VIC>
          .             forceinline unsigned int&
          .             VarImp<VIC>::idx(PropCond pc) {
          .               assert((pc > 0)  && (pc < pc_max+2));
          .               return u.idx[pc-1];
          .             }
-- line 4167 ----------------------------------------
-- line 4178 ----------------------------------------
          .             VarImp<VIC>::VarImp(Space& home)
          .           #ifdef GECODE_HAS_CBS
          .             : var_id(++home.var_id_counter)
          .           #endif
          .             {
          .           #ifndef GECODE_HAS_CBS
          .               (void) home;
          .           #endif
         66 ( 0.00%)      b.base = nullptr; entries = 0;
          .               for (PropCond pc=1; pc<pc_max+2; pc++)
         22 ( 0.00%)        idx(pc) = 0;
          .               free_and_bits = 0;
          .             }
          .           
          .             template<class VIC>
          .             forceinline
          2 ( 0.00%)    VarImp<VIC>::VarImp(void)
          .           #ifdef GECODE_HAS_CBS
          .             : var_id(0)
          .           #endif
          .             {
          7 ( 0.00%)      b.base = nullptr; entries = 0;
          .               for (PropCond pc=1; pc<pc_max+2; pc++)
          .                 idx(pc) = 0;
          .               free_and_bits = 0;
          .             }
          .           
          .           #ifdef GECODE_HAS_CBS
          .             template<class VIC>
          .             forceinline unsigned int
-- line 4207 ----------------------------------------
-- line 4209 ----------------------------------------
          .               return var_id;
          .             }
          .           #endif
          .           
          .             template<class VIC>
          .             forceinline unsigned int
          .             VarImp<VIC>::degree(void) const {
          .               assert(!copied());
         39 ( 0.00%)      return entries;
          .             }
          .           
          .             template<class VIC>
          .             forceinline double
          .             VarImp<VIC>::afc(void) const {
 77,460,331 ( 0.09%)      double d = 0.0;
          .               // Count the afc of each propagator
          .               {
          .                 ActorLink** a = const_cast<VarImp<VIC>*>(this)->actor(0);
          .                 ActorLink** e = const_cast<VarImp<VIC>*>(this)->actorNonZero(pc_max+1);
241,868,119 ( 0.27%)        while (a < e) {
137,743,144 ( 0.15%)          d += Propagator::cast(*a)->afc(); a++;
          .                 }
          .               }
          .               // Count the afc of each advisor's propagator
          .               {
          .                 ActorLink** a = const_cast<VarImp<VIC>*>(this)->actorNonZero(pc_max+1);
 69,416,650 ( 0.08%)        ActorLink** e = const_cast<VarImp<VIC>*>(this)->b.base+entries;
 69,416,650 ( 0.08%)        while (a < e) {
          .                   d += Advisor::cast(static_cast<ActorLink*>(Support::funmark(*a)))
          .                     ->propagator().afc();
          .                   a++;
          .                 }
          .               }
          .               return d;
          .             }
          .           
-- line 4244 ----------------------------------------
-- line 4284 ----------------------------------------
          .             forceinline VarImp<VIC>*
          .             VarImp<VIC>::forward(void) const {
          .               assert(copied());
          .               return static_cast<VarImp<VIC>*>(Support::unmark(b.fwd));
          .             }
          .           
          .             template<class VIC>
          .             forceinline VarImp<VIC>*
176,355,388 ( 0.20%)    VarImp<VIC>::next(void) const {
          .               assert(copied());
176,355,388 ( 0.20%)      return u.next;
          .             }
          .           
          .             template<class VIC>
          .             forceinline
          .             VarImp<VIC>::VarImp(Space& home, VarImp<VIC>& x)
          .           #ifdef GECODE_HAS_CBS
          .             : var_id(x.var_id)
          .           #endif
          .             {
          .               VarImpBase** reg;
176,355,388 ( 0.20%)      free_and_bits = x.free_and_bits & ((1 << free_bits) - 1);
176,355,388 ( 0.20%)      if (x.b.base == nullptr) {
          .                 // Variable implementation needs no index structure
737,486,168 ( 0.82%)        reg = &home.pc.c.vars_noidx;
          .                 assert(x.degree() == 0);
          .               } else {
          .                 reg = &home.pc.c.vars_u[idx_c];
          .               }
          .               // Save subscriptions in copy
176,355,388 ( 0.20%)      b.base = x.b.base;
352,710,776 ( 0.39%)      entries = x.entries;
          .               for (PropCond pc=1; pc<pc_max+2; pc++)
705,421,552 ( 0.79%)        idx(pc) = x.idx(pc);
          .           
          .               // Set forwarding pointer
          .               x.b.fwd = static_cast<VarImp<VIC>*>(Support::mark(this));
          .               // Register original
529,066,164 ( 0.59%)      x.u.next = static_cast<VarImp<VIC>*>(*reg); *reg = &x;
          .             }
          .           
          .             template<class VIC>
          .             forceinline ModEvent
          .             VarImp<VIC>::me(const ModEventDelta& med) {
128,302,407 ( 0.14%)      return static_cast<ModEvent>((med & VIC::med_mask) >> VIC::med_fst);
          .             }
          .           
          .             template<class VIC>
          .             forceinline ModEventDelta
          .             VarImp<VIC>::med(ModEvent me) {
          .               return static_cast<ModEventDelta>(me << VIC::med_fst);
          .             }
          .           
-- line 4336 ----------------------------------------
-- line 4339 ----------------------------------------
          .             VarImp<VIC>::me_combine(ModEvent me1, ModEvent me2) {
          .               return VIC::me_combine(me1,me2);
          .             }
          .           
          .             template<class VIC>
          .             forceinline void
          .             VarImp<VIC>::schedule(Space& home, Propagator& p, ModEvent me,
          .                                   bool force) {
 78,720,872 ( 0.09%)      if (VIC::med_update(p.u.med,me) || force)
          .                 home.enqueue(&p);
          .             }
          .           
          .             template<class VIC>
          .             forceinline void
          .             VarImp<VIC>::schedule(Space& home, PropCond pc1, PropCond pc2, ModEvent me) {
          .               ActorLink** b = actor(pc1);
          .               ActorLink** p = actorNonZero(pc2+1);
660,915,959 ( 0.74%)      while (p-- > b)
149,750,391 ( 0.17%)        schedule(home,*Propagator::cast(*p),me);
          .             }
          .           
          .             template<class VIC>
          .             forceinline void
          .             VarImp<VIC>::resize(Space& home) {
    100,794 ( 0.00%)      if (b.base == nullptr) {
          .                 assert((free_and_bits >> free_bits) == 0);
          .                 // Create fresh dependency array with four entries
         22 ( 0.00%)        free_and_bits += 4 << free_bits;
         22 ( 0.00%)        b.base = home.alloc<ActorLink*>(4);
         22 ( 0.00%)        for (int i=0; i<pc_max+1; i++)
         44 ( 0.00%)          u.idx[i] = 0;
          .               } else {
          .                 // Resize dependency array
          .                 unsigned int n = degree();
          .                 // Find out whether the area is most likely in the special area
          .                 // reserved for subscriptions. If yes, just resize mildly otherwise
          .                 // more agressively
          .                 ActorLink** s = static_cast<ActorLink**>(home.mm.subscriptions());
          .                 unsigned int m =
        234 ( 0.00%)          ((s <= b.base) && (b.base < s+home.pc.p.n_sub)) ?
          .                   (n+4) : ((n+1)*3>>1);
          .                 ActorLink** prop = home.alloc<ActorLink*>(m);
        156 ( 0.00%)        free_and_bits += (m-n) << free_bits;
          .                 // Copy entries
         39 ( 0.00%)        Heap::copy<ActorLink*>(prop, b.base, n);
         39 ( 0.00%)        home.free<ActorLink*>(b.base,n);
         39 ( 0.00%)        b.base = prop;
          .               }
          .             }
          .           
          .             template<class VIC>
          .             forceinline void
    100,672 ( 0.00%)    VarImp<VIC>::enter(Space& home, Propagator* p, PropCond pc) {
          .               assert(pc <= pc_max);
          .               // Count one new subscription
    402,688 ( 0.00%)      home.pc.p.n_sub += 1;
    302,016 ( 0.00%)      if ((free_and_bits >> free_bits) == 0)
          .                 resize(home);
    201,444 ( 0.00%)      free_and_bits -= 1 << free_bits;
          .           
          .               // Enter subscription
    302,016 ( 0.00%)      b.base[entries] = *actorNonZero(pc_max+1);
    100,672 ( 0.00%)      entries++;
    603,784 ( 0.00%)      for (PropCond j = pc_max; j > pc; j--) {
    402,440 ( 0.00%)        *actorNonZero(j+1) = *actorNonZero(j);
    201,220 ( 0.00%)        idx(j+1)++;
          .               }
    201,344 ( 0.00%)      *actorNonZero(pc+1) = *actor(pc);
    100,672 ( 0.00%)      idx(pc+1)++;
    100,752 ( 0.00%)      *actor(pc) = ActorLink::cast(p);
          .           
          .           #ifdef GECODE_AUDIT
          .               ActorLink** f = actor(pc);
          .               while (f < (pc == pc_max+1 ? b.base+entries : actorNonZero(pc+1)))
          .                 if (*f == p)
          .                   goto found;
          .                 else
          .                   f++;
-- line 4416 ----------------------------------------
-- line 4433 ----------------------------------------
          .               b.base[entries++] = *actorNonZero(pc_max+1);
          .               *actorNonZero(pc_max+1) = a;
          .             }
          .           
          .             template<class VIC>
          .             forceinline void
          .             VarImp<VIC>::subscribe(Space& home, Propagator& p, PropCond pc,
          .                                    bool assigned, ModEvent me, bool schedule) {
    302,016 ( 0.00%)      if (assigned) {
          .                 // Do not subscribe, just schedule the propagator
          .                 if (schedule)
          .                   VarImp<VIC>::schedule(home,p,ME_GEN_ASSIGNED);
          .               } else {
          .                 enter(home,&p,pc);
          .                 // Schedule propagator
        160 ( 0.00%)        if (schedule && (pc != PC_GEN_ASSIGNED))
          .                   VarImp<VIC>::schedule(home,p,me);
          .               }
          .             }
          .           
          .             template<class VIC>
          .             forceinline void
          .             VarImp<VIC>::subscribe(Space& home, Advisor& a, bool assigned, bool fail) {
          .               if (!assigned) {
-- line 4456 ----------------------------------------
-- line 4466 ----------------------------------------
          .               if (assigned)
          .                 VarImp<VIC>::schedule(home,p,ME_GEN_ASSIGNED);
          .               else if (pc != PC_GEN_ASSIGNED)
          .                 VarImp<VIC>::schedule(home,p,me);
          .             }
          .           
          .             template<class VIC>
          .             void
  4,436,023 ( 0.00%)    VarImp<VIC>::remove(Space& home, Propagator* p, PropCond pc) {
          .               assert(pc <= pc_max);
          .               ActorLink* a = ActorLink::cast(p);
          .               // Find actor in dependency array
          .               ActorLink** f = actor(pc);
          .           #ifdef GECODE_AUDIT
          .               while (f < actorNonZero(pc+1))
          .                 if (*f == a)
          .                   goto found;
          .                 else
          .                   f++;
          .               GECODE_NEVER;
          .             found: ;
          .           #else
  9,386,129 ( 0.01%)      while (*f != a) f++;
          .           #endif
          .               // Remove actor
  8,895,668 ( 0.01%)      *f = *(actorNonZero(pc+1)-1);
          .               for (PropCond j = pc+1; j< pc_max+1; j++) {
    435,446 ( 0.00%)        *(actorNonZero(j)-1) = *(actorNonZero(j+1)-1);
    217,723 ( 0.00%)        idx(j)--;
          .               }
 22,239,170 ( 0.02%)      *(actorNonZero(pc_max+1)-1) = b.base[entries-1];
  4,447,834 ( 0.00%)      idx(pc_max+1)--;
  4,447,834 ( 0.00%)      entries--;
  4,447,834 ( 0.00%)      free_and_bits += 1 << free_bits;
  4,447,834 ( 0.00%)      home.pc.p.n_sub -= 1;
  4,436,023 ( 0.00%)    }
          .           
          .             template<class VIC>
          .             forceinline void
     93,270 ( 0.00%)    VarImp<VIC>::cancel(Space& home, Propagator& p, PropCond pc) {
 53,707,008 ( 0.06%)      if (b.base != nullptr)
 13,308,069 ( 0.01%)        remove(home,&p,pc);
  3,118,352 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/core.hpp:Gecode::VarImp<Gecode::Int::IntVarImpConf>::remove(Gecode::Space&, Gecode::Propagator*, int) [clone .constprop.1] (100,592x)
          .             }
          .           
          .             template<class VIC>
          .             void
          .             VarImp<VIC>::remove(Space& home, Advisor* a) {
          .               // Note that a might be a marked pointer
          .               // Find actor in dependency array
          .               ActorLink** f = actorNonZero(pc_max+1);
-- line 4515 ----------------------------------------
-- line 4538 ----------------------------------------
          .                 remove(home,ma);
          .               }
          .             }
          .           
          .             template<class VIC>
          .             forceinline void
          .             VarImp<VIC>::cancel(Space& home) {
          .               unsigned int n_sub = degree();
 28,658,380 ( 0.03%)      home.pc.p.n_sub -= n_sub;
          .               unsigned int n = (free_and_bits >> free_bits) + n_sub;
 28,658,380 ( 0.03%)      home.free<ActorLink*>(b.base,n);
          .               // Must be nullptr such that cloning works
 28,658,380 ( 0.03%)      b.base = nullptr;
          .               // Must be 0 such that degree works
 57,316,760 ( 0.06%)      entries = 0;
          .               // Must be nullptr such that afc works
          .               for (PropCond pc=1; pc<pc_max+2; pc++)
 28,658,380 ( 0.03%)        idx(pc) = 0;
          .               free_and_bits &= (1 << free_bits) - 1;
  4,243,069 ( 0.00%)    }
          .           
          .             template<class VIC>
          .             forceinline bool
          .             VarImp<VIC>::advise(Space& home, ModEvent me, Delta& d) {
          .               /*
          .                * An advisor that is executed might remove itself due to subsumption.
          .                * As entries are removed from front to back, the advisors must
          .                * be iterated in forward direction.
          .                */
          .               ActorLink** la = actorNonZero(pc_max+1);
240,315,414 ( 0.27%)      ActorLink** le = b.base+entries;
182,998,654 ( 0.20%)      if (la == le)
          .                 return true;
          .               d.me = me;
          .               // An advisor that is run, might be removed during execution.
          .               // As removal is done from the back the advisors have to be executed
          .               // in inverse order.
          .               do {
          .                 Advisor* a = Advisor::cast
          .                   (static_cast<ActorLink*>(Support::funmark(*la)));
-- line 4577 ----------------------------------------
-- line 4600 ----------------------------------------
          .             void
          .             VarImp<VIC>::_fail(Space& home) {
          .               /*
          .                * An advisor that is executed might remove itself due to subsumption.
          .                * As entries are removed from front to back, the advisors must
          .                * be iterated in forward direction.
          .                */
          .               ActorLink** la = actorNonZero(pc_max+1);
  8,763,974 ( 0.01%)      ActorLink** le = b.base+entries;
  8,763,974 ( 0.01%)      if (la == le)
          .                 return;
          .               // An advisor that is run, might be removed during execution.
          .               // As removal is done from the back the advisors have to be executed
          .               // in inverse order.
          .               do {
          .                 if (Support::marked(*la)) {
          .                   Advisor* a = Advisor::cast(static_cast<ActorLink*>
          .                                              (Support::unmark(*la)));
          .                   assert(!a->disposed());
          .                   Propagator& p = a->propagator();
          .                   p.advise(home,*a);
          .                 }
          7 ( 0.00%)      } while (++la < le);
          .             }
          .           
          .             template<class VIC>
          .             ModEvent
          .             VarImp<VIC>::fail(Space& home) {
          .               _fail(home);
          .               return ME_GEN_FAILED;
          .             }
-- line 4630 ----------------------------------------
-- line 4635 ----------------------------------------
          .           #pragma clang diagnostic ignored "-Warray-bounds"
          .           
          .             template<class VIC>
          .             forceinline void
          .             VarImp<VIC>::update(VarImp<VIC>* x, ActorLink**& sub) {
          .               // this refers to the variable to be updated (clone)
          .               // x refers to the original
          .               // Recover from copy
 98,214,790 ( 0.11%)      x->b.base = b.base;
 98,214,790 ( 0.11%)      x->u.idx[0] = u.idx[0];
          .               if (pc_max > 0 && sizeof(ActorLink**) > sizeof(unsigned int))
 98,214,790 ( 0.11%)        x->u.idx[1] = u.idx[1];
          .           
 49,107,395 ( 0.05%)      unsigned int np =
          .                 static_cast<unsigned int>(x->actorNonZero(pc_max+1) - x->actor(0));
 49,107,395 ( 0.05%)      unsigned int na =
147,322,185 ( 0.16%)        static_cast<unsigned int >(x->b.base + x->entries -
          .                                            x->actorNonZero(pc_max+1));
          .               unsigned int n  = na + np;
          .               assert(n == x->degree());
          .           
 98,214,790 ( 0.11%)      ActorLink** f = x->b.base;
          .               ActorLink** t = sub;
          .           
 98,214,790 ( 0.11%)      sub += n;
 49,107,395 ( 0.05%)      b.base = t;
          .               // Process propagator subscriptions
 98,214,790 ( 0.11%)      while (np >= 4) {
          .                 ActorLink* p3 = f[3]->prev();
          .                 ActorLink* p0 = f[0]->prev();
          .                 ActorLink* p1 = f[1]->prev();
          .                 ActorLink* p2 = f[2]->prev();
          .                 t[0] = p0; t[1] = p1; t[2] = p2; t[3] = p3;
          .                 np -= 4; t += 4; f += 4;
          .               }
 98,214,790 ( 0.11%)      if (np >= 2) {
          .                 ActorLink* p0 = f[0]->prev();
          .                 ActorLink* p1 = f[1]->prev();
119,624,325 ( 0.13%)        t[0] = p0; t[1] = p1;
119,624,325 ( 0.13%)        np -= 2; t += 2; f += 2;
          .               }
 98,214,790 ( 0.11%)      if (np > 0) {
          .                 ActorLink* p0 = f[0]->prev();
  9,232,620 ( 0.01%)        t[0] = p0;
 18,465,240 ( 0.02%)        t += 1; f += 1;
          .               }
          .               // Process advisor subscriptions
196,429,580 ( 0.22%)      while (na >= 4) {
          .                 ptrdiff_t m0, m1, m2, m3;
          .                 ActorLink* p3 =
          .                   static_cast<ActorLink*>(Support::ptrsplit(f[3],m3))->prev();
          .                 ActorLink* p0 =
          .                   static_cast<ActorLink*>(Support::ptrsplit(f[0],m0))->prev();
          .                 ActorLink* p1 =
          .                   static_cast<ActorLink*>(Support::ptrsplit(f[1],m1))->prev();
          .                 ActorLink* p2 =
          .                   static_cast<ActorLink*>(Support::ptrsplit(f[2],m2))->prev();
          .                 t[0] = static_cast<ActorLink*>(Support::ptrjoin(p0,m0));
          .                 t[1] = static_cast<ActorLink*>(Support::ptrjoin(p1,m1));
          .                 t[2] = static_cast<ActorLink*>(Support::ptrjoin(p2,m2));
          .                 t[3] = static_cast<ActorLink*>(Support::ptrjoin(p3,m3));
          .                 na -= 4; t += 4; f += 4;
          .               }
 98,214,790 ( 0.11%)      if (na >= 2) {
          .                 ptrdiff_t m0, m1;
          .                 ActorLink* p0 =
          .                   static_cast<ActorLink*>(Support::ptrsplit(f[0],m0))->prev();
          .                 ActorLink* p1 =
          .                   static_cast<ActorLink*>(Support::ptrsplit(f[1],m1))->prev();
          .                 t[0] = static_cast<ActorLink*>(Support::ptrjoin(p0,m0));
          .                 t[1] = static_cast<ActorLink*>(Support::ptrjoin(p1,m1));
          .                 na -= 2; t += 2; f += 2;
          .               }
 98,214,790 ( 0.11%)      if (na > 0) {
          .                 ptrdiff_t m0;
          .                 ActorLink* p0 =
          .                   static_cast<ActorLink*>(Support::ptrsplit(f[0],m0))->prev();
          .                 t[0] = static_cast<ActorLink*>(Support::ptrjoin(p0,m0));
          .               }
          .             }
          .           #pragma clang diagnostic pop
          .           
          .             template<class VIC>
          .             forceinline void
          .             VarImp<VIC>::update(Space& home, ActorLink**& sub) {
 64,129,232 ( 0.07%)      VarImp<VIC>* x = static_cast<VarImp<VIC>*>(home.pc.c.vars_u[idx_c]);
186,392,480 ( 0.21%)      while (x != nullptr) {
          .                 VarImp<VIC>* n = x->next(); x->forward()->update(x,sub); x = n;
          .               }
          .             }
          .           
          .           
          .           
          .             /*
          .              * Variable disposer
-- line 4729 ----------------------------------------
-- line 4746 ----------------------------------------
          .             }
          .           
          .             /*
          .              * Statistics
          .              */
          .           
          .             forceinline void
          .             StatusStatistics::reset(void) {
     81,954 ( 0.00%)      propagate = 0;
          .             }
          .             forceinline
          .             StatusStatistics::StatusStatistics(void) {
          .               reset();
          .             }
          .             forceinline StatusStatistics&
          .             StatusStatistics::operator +=(const StatusStatistics& s) {
 93,640,580 ( 0.10%)      propagate += s.propagate;
          .               return *this;
          .             }
          .             forceinline StatusStatistics
          .             StatusStatistics::operator +(const StatusStatistics& s) {
          .               StatusStatistics t(s);
          .               return t += *this;
          .             }
          .           
-- line 4770 ----------------------------------------
-- line 4811 ----------------------------------------
          .             PropCost::PropCost(PropCost::ActualCost ac0) : ac(ac0) {}
          .           
          .             forceinline PropCost
          .             PropCost::cost(PropCost::Mod m,
          .                            PropCost::ActualCost lo, PropCost::ActualCost hi,
          .                            unsigned int n) {
          .               if (n < 2)
          .                 return (m == LO) ? AC_UNARY_LO : AC_UNARY_HI;
125,035,841 ( 0.14%)      else if (n == 2)
 62,517,918 ( 0.07%)        return (m == LO) ? AC_BINARY_LO : AC_BINARY_HI;
          8 ( 0.00%)      else if (n == 3)
 37,320,612 ( 0.04%)        return (m == LO) ? AC_TERNARY_LO : AC_TERNARY_HI;
          .               else
211,541,688 ( 0.24%)        return (m == LO) ? lo : hi;
          .             }
          .           
          .             forceinline PropCost
          .             PropCost::record(void) {
          .               return AC_RECORD;
          .             }
          .             forceinline PropCost
          .             PropCost::crazy(PropCost::Mod m, unsigned int n) {
-- line 4832 ----------------------------------------
-- line 4848 ----------------------------------------
          .             }
          .             forceinline PropCost
          .             PropCost::quadratic(PropCost::Mod m, unsigned int n) {
          .               return cost(m,AC_QUADRATIC_LO,AC_QUADRATIC_HI,n);
          .             }
          .             forceinline PropCost
          .             PropCost::quadratic(PropCost::Mod m, int n) {
          .               assert(n >= 0);
  9,330,153 ( 0.01%)      return quadratic(m,static_cast<unsigned int>(n));
          .             }
          .             forceinline PropCost
          .             PropCost::linear(PropCost::Mod m, unsigned int n) {
          .               return cost(m,AC_LINEAR_LO,AC_LINEAR_HI,n);
          .             }
          .             forceinline PropCost
          .             PropCost::linear(PropCost::Mod m, int n) {
          .               assert(n >= 0);
 24,318,780 ( 0.03%)      return linear(m,static_cast<unsigned int>(n));
          .             }
          .             forceinline PropCost
          .             PropCost::ternary(PropCost::Mod m) {
          .               return (m == LO) ? AC_TERNARY_LO : AC_TERNARY_HI;
          .             }
          .             forceinline PropCost
          .             PropCost::binary(PropCost::Mod m) {
          .               return (m == LO) ? AC_BINARY_LO : AC_BINARY_HI;
-- line 4873 ----------------------------------------
-- line 4879 ----------------------------------------
          .           
          .             /*
          .              * Iterators for propagators and branchers of a space
          .              *
          .              */
          .             forceinline
          .             Space::Propagators::Propagators(Space& home0)
          .               : home(home0), q(home.pc.p.active) {
          6 ( 0.00%)      while (q >= &home.pc.p.queue[0]) {
          .                 if (q->next() != q) {
          .                   c = q->next(); e = q; q--;
          .                   return;
          .                 }
          .                 q--;
          .               }
          2 ( 0.00%)      q = nullptr;
          6 ( 0.00%)      if (!home.pl.empty()) {
          .                 c = Propagator::cast(home.pl.next());
          .                 e = Propagator::cast(&home.pl);
          .               } else {
          .                 c = e = nullptr;
          .               }
          .             }
          .             forceinline bool
          .             Space::Propagators::operator ()(void) const {
          .               return c != nullptr;
          .             }
          .             forceinline void
          .             Space::Propagators::operator ++(void) {
          .               c = c->next();
         12 ( 0.00%)      if (c == e) {
          6 ( 0.00%)        if (q == nullptr) {
          .                   c = nullptr;
          .                 } else {
          .                   while (q >= &home.pc.p.queue[0]) {
          .                     if (q->next() != q) {
          .                       c = q->next(); e = q; q--;
          .                       return;
          .                     }
          .                     q--;
          .                   }
          .                   q = nullptr;
          2 ( 0.00%)          if (!home.pl.empty()) {
          .                     c = Propagator::cast(home.pl.next());
          .                     e = Propagator::cast(&home.pl);
          .                   } else {
          .                     c = nullptr;
          .                   }
          .                 }
          .               }
          .             }
-- line 4929 ----------------------------------------
-- line 5008 ----------------------------------------
          .               return *Brancher::cast(c);
          .             }
          .           
          .           
          .             /*
          .              * Groups of actors
          .              */
          .             forceinline
         12 ( 0.00%)    Group::Group(unsigned int gid0) : gid(gid0) {}
          .           
          .             forceinline bool
          .             Group::in(Group actor) const {
         34 ( 0.00%)      return (gid == GROUPID_ALL) || (gid == actor.gid);
          .             }
          .           
          .             forceinline bool
          .             Group::in(void) const {
          .               return (gid != GROUPID_ALL) && (gid != GROUPID_DEF);
          .             }
          .           
          .             forceinline
  4,807,358 ( 0.01%)    Group::Group(const Group& g) : gid(g.gid) {}
          .           
          .             forceinline Group&
          .             Group::operator =(const Group& g) {
          .               gid=g.gid; return *this;
          .             }
          .           
          .             forceinline unsigned int
          .             Group::id(void) const {
-- line 5037 ----------------------------------------
-- line 5073 ----------------------------------------
          .             PropagatorGroup::move(Space& , Propagator& p) {
          .               if (id() != GROUPID_ALL)
          .                 p.group(*this);
          .               return *this;
          .             }
          .           
          .           
          .             forceinline
         10 ( 0.00%)    BrancherGroup::BrancherGroup(void) {}
      1,325 ( 0.00%)  => ???:0x0000000004866840 (4x)
          .           
          .             forceinline
          .             BrancherGroup::BrancherGroup(unsigned int gid)
          .               : Group(gid) {}
          .           
          .             forceinline
          .             BrancherGroup::BrancherGroup(const BrancherGroup& g)
          .               : Group(g) {}
-- line 5089 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/manager.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 179 ----------------------------------------
          .           
          .             /*
          .              * Shared memory area
          .              *
          .              */
          .           
          .             forceinline
          .             SharedMemory::SharedMemory(void) {
          1 ( 0.00%)      heap.n_hc = 0;
          1 ( 0.00%)      heap.hc = nullptr;
          .             }
          .             forceinline
          .             SharedMemory::~SharedMemory(void) {
          .               while (heap.hc != nullptr) {
          .                 HeapChunk* hc = heap.hc;
          .                 heap.hc = static_cast<HeapChunk*>(hc->next);
          .                 Gecode::heap.rfree(hc);
          .               }
          .             }
          .           
          .             forceinline HeapChunk*
          .             SharedMemory::alloc(size_t s, size_t l) {
          .               // To protect from exceptions from heap.ralloc()
 32,064,640 ( 0.04%)      Support::Lock guard(m());
 64,129,232 ( 0.07%)  => ???:0x0000000004954710 (8,016,154x)
 80,341,627 ( 0.09%)      while ((heap.hc != nullptr) && (heap.hc->size < l)) {
 32,123,981 ( 0.04%)        heap.n_hc--;
          .                 HeapChunk* hc = heap.hc;
    120,686 ( 0.00%)        heap.hc = static_cast<HeapChunk*>(hc->next);
          .                 Gecode::heap.rfree(hc);
          .               }
          .               HeapChunk* hc;
          .               if (heap.hc == nullptr) {
          .                 assert(heap.n_hc == 0);
          .                 hc = static_cast<HeapChunk*>(Gecode::heap.ralloc(s));
     61,335 ( 0.00%)        hc->size = s;
          .               } else {
 15,971,476 ( 0.02%)        heap.n_hc--;
          .                 hc = heap.hc;
 47,914,428 ( 0.05%)        heap.hc = static_cast<HeapChunk*>(hc->next);
          .               }
          .               return hc;
          .             }
          .             forceinline void
          .             SharedMemory::free(HeapChunk* hc) {
 32,064,604 ( 0.04%)      Support::Lock guard(m());
128,258,416 ( 0.14%)  => ???:0x0000000004954710 (16,032,302x)
 48,096,906 ( 0.05%)      if (heap.n_hc == MemoryConfig::n_hc_cache) {
          .                 Gecode::heap.rfree(hc);
          .               } else {
 32,063,670 ( 0.04%)        heap.n_hc++;
 48,095,505 ( 0.05%)        hc->next = heap.hc; heap.hc = hc;
          .               }
          .             }
          .           
          .           
          .           }}
          .           
          .           namespace Gecode {
          .           
-- line 236 ----------------------------------------
-- line 243 ----------------------------------------
          .             FreeList::FreeList(void) {}
          .           
          .             forceinline
          .             FreeList::FreeList(FreeList* n)
          .               : _next(n) {}
          .           
          .             forceinline FreeList*
          .             FreeList::next(void) const {
  9,440,677 ( 0.01%)      return _next;
          .             }
          .           
          .             forceinline FreeList**
          .             FreeList::nextRef(void) {
          .               return &_next;
          .             }
          .           
          .             forceinline void
          .             FreeList::next(FreeList* n) {
 47,161,258 ( 0.05%)      _next = n;
          .             }
          .           
          .           }
          .           
          .           namespace Gecode { namespace Kernel {
          .           
          .             /*
          .              * The active memory manager
          .              *
          .              */
          .           
          .             forceinline size_t
          .             MemoryManager::sz2i(size_t s) {
          .               assert(s >= (MemoryConfig::fl_size_min << MemoryConfig::fl_unit_size));
          .               assert(s <= (MemoryConfig::fl_size_max << MemoryConfig::fl_unit_size));
 28,388,934 ( 0.03%)      return (s >> MemoryConfig::fl_unit_size) - MemoryConfig::fl_size_min;
          .             }
          .           
          .             forceinline size_t
          .             MemoryManager::i2sz(size_t i) {
          .               return (i + MemoryConfig::fl_size_min) << MemoryConfig::fl_unit_size;
          .             }
          .           
          .           
          .             forceinline void*
          .             MemoryManager::alloc(SharedMemory& sm, size_t sz) {
          .               assert(sz > 0);
          .               // Perform alignment
          .               MemoryConfig::align(sz);
          .               // Check whether sufficient memory left
987,755,115 ( 1.10%)      if (sz > lsz)
 23,706,659 ( 0.03%)        alloc_refill(sm,sz);
      4,593 ( 0.00%)  => ???:0x0000000004867650 (11x)
677,207,815 ( 0.76%)      lsz -= sz;
342,611,966 ( 0.38%)      return start + lsz;
          .             }
          .           
          .             forceinline void*
          .             MemoryManager::subscriptions(void) const {
 32,064,694 ( 0.04%)      return &cur_hc->area[0];
          .             }
          .           
          .             forceinline void
          .             MemoryManager::alloc_fill(SharedMemory& sm, size_t sz, bool first) {
          .               // Adjust current heap chunk size
 48,096,990 ( 0.05%)      if (((requested > MemoryConfig::hcsz_inc_ratio*cur_hcsz) ||
          .                    (sz > cur_hcsz)) &&
          .                   (cur_hcsz < MemoryConfig::hcsz_max) &&
          .                   !first) {
          .                 cur_hcsz <<= 1;
          .               }
          .               // Increment the size that it caters for the initial overhead
          .               size_t overhead = sizeof(HeapChunk) - sizeof(double);
 24,048,473 ( 0.03%)      sz += overhead;
          .               // Round size to next multiple of current heap chunk size
 40,080,792 ( 0.04%)      size_t allocate = ((sz > cur_hcsz) ?
 32,064,616 ( 0.04%)                         (static_cast<size_t>(sz / cur_hcsz) + 1) * cur_hcsz 
          .                                  : cur_hcsz);
          .               // Request a chunk of preferably size allocate, but at least size sz
          .               HeapChunk* hc = sm.alloc(allocate,sz);
 16,032,332 ( 0.02%)      start = ptr_cast<char*>(&hc->area[0]);
 40,080,806 ( 0.04%)      lsz   = hc->size - overhead;
          .               // Link heap chunk, where the first heap chunk is kept in place
          .               if (first) {
  8,016,155 ( 0.01%)        requested = hc->size;
 16,032,310 ( 0.02%)        hc->next = nullptr; cur_hc = hc;
          .               } else {
 16,032,330 ( 0.02%)        requested += hc->size;
 40,080,825 ( 0.04%)        hc->next = cur_hc->next; cur_hc->next = hc;
          .               }
          .           #ifdef GECODE_MEMORY_CHECK
          .               for (char* c = start; c < (start+lsz); c++)
          .                 *c = 0;
          .           #endif
          .             }
          .           
          .             forceinline
          .             MemoryManager::MemoryManager(SharedMemory& sm)
          3 ( 0.00%)      : cur_hcsz(MemoryConfig::hcsz_min), requested(0), slack(nullptr) {
          .               alloc_fill(sm,cur_hcsz,true);
          .               for (size_t i = 0; i<MemoryConfig::fl_size_max-MemoryConfig::fl_size_min+1;
          .                    i++)
          2 ( 0.00%)        fl[i] = nullptr;
          .             }
          .           
          .             forceinline
          .             MemoryManager::MemoryManager(SharedMemory& sm, MemoryManager& mm,
          .                                          size_t s_sub)
 32,064,616 ( 0.04%)      : cur_hcsz(mm.cur_hcsz), requested(0), slack(nullptr) {
          .               MemoryConfig::align(s_sub);
 40,080,770 ( 0.04%)      if ((mm.requested < MemoryConfig::hcsz_dec_ratio*mm.cur_hcsz) &&
          .                   (cur_hcsz > MemoryConfig::hcsz_min) &&
          .                   (s_sub*2 < cur_hcsz))
          .                 cur_hcsz >>= 1;
          .               alloc_fill(sm,cur_hcsz+s_sub,true);
          .               // Skip the memory area at the beginning for subscriptions
 32,064,616 ( 0.04%)      lsz   -= s_sub;
 16,032,308 ( 0.02%)      start += s_sub;
          .               for (size_t i = 0; i<MemoryConfig::fl_size_max-MemoryConfig::fl_size_min+1;
          .                    i++)
 16,032,308 ( 0.02%)        fl[i] = nullptr;
          .             }
          .           
          .             forceinline void
          .             MemoryManager::release(SharedMemory& sm) {
          .               // Release all allocated heap chunks
 16,032,292 ( 0.02%)      HeapChunk* hc = cur_hc;
          .               do {
 16,032,302 ( 0.02%)        HeapChunk* t = hc; hc = static_cast<HeapChunk*>(hc->next);
          .                 sm.free(t);
 32,064,604 ( 0.04%)      } while (hc != nullptr);
          .             }
          .           
          .           
          .           
          .             /*
          .              * Slack memory management
          .              *
          .              */
-- line 379 ----------------------------------------
-- line 389 ----------------------------------------
          .               }
          .           #endif
          .           
          .               size_t aligned_s = s;
          .               void* aligned_p = std::align(std::min(static_cast<size_t>(GECODE_MEMORY_ALIGNMENT), s),
          .                                            MemoryConfig::fl_size_min<<MemoryConfig::fl_unit_size,
          .                                            p, aligned_s);
          .           
149,132,392 ( 0.17%)      if (aligned_p==nullptr ||
          .                   aligned_s < (MemoryConfig::fl_size_min<<MemoryConfig::fl_unit_size))
          .                 return;
 74,566,196 ( 0.08%)      if (aligned_s > (MemoryConfig::fl_size_max<<MemoryConfig::fl_unit_size)) {
          .                 MemoryChunk* rc = static_cast<MemoryChunk*>(aligned_p);
 17,788,328 ( 0.02%)        rc->next = slack;
  8,894,164 ( 0.01%)        rc->size = aligned_s;
 17,788,328 ( 0.02%)        slack = rc;
          .               } else {
          .                 size_t i = sz2i(aligned_s);
          .                 FreeList* f = static_cast<FreeList*>(aligned_p);
113,555,736 ( 0.13%)        f->next(fl[i]); fl[i]=f;
          .               }
          .             }
          .           
          .           
          .             /*
          .              * Freelist management
          .              *
          .              */
          .           
          .             template<size_t s>
          .             forceinline void*
          .             MemoryManager::fl_alloc(SharedMemory& sm) {
          .               size_t i = sz2i(s);
  9,440,677 ( 0.01%)      FreeList* f = fl[i];
 18,881,354 ( 0.02%)      if (f == nullptr) {
 10,683,364 ( 0.01%)        fl_refill<s>(sm); f = fl[i];
 51,019,622 ( 0.06%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/manager.hpp:void Gecode::Kernel::MemoryManager::fl_refill<16ul>(Gecode::Kernel::SharedMemory&) (1,808,214x)
          .               }
          .               FreeList* n = f->next();
  9,440,677 ( 0.01%)      fl[i] = n;
          .               return f;
          .             }
          .           
          .             template<size_t s>
          .             forceinline void
          .             MemoryManager::fl_dispose(FreeList* f, FreeList* l) {
          .               size_t i = sz2i(s);
          .           #ifdef GECODE_AUDIT
          .               FreeList* cur = f;
          .               while (cur != l) {
          .                 assert(cur->next());
          .                 cur = cur->next();
          .               }
          .           #endif
 27,879,224 ( 0.03%)      l->next(fl[i]); fl[i] = f;
          .             }
          .           
          .             template<size_t sz>
          .             void
  2,863,304 ( 0.00%)    MemoryManager::fl_refill(SharedMemory& sm) {
          .               // Try to acquire memory from slack
  5,424,642 ( 0.01%)      if (slack != nullptr) {
          .                 MemoryChunk* m = slack;
  1,506,248 ( 0.00%)        slack = nullptr;
          .                 do {
          .                   char*  block = ptr_cast<char*>(m);
  1,522,744 ( 0.00%)          size_t s     = m->size;
          .                   assert(s >= sz);
    761,372 ( 0.00%)          m = m->next;
    761,372 ( 0.00%)          fl[sz2i(sz)] = ptr_cast<FreeList*>(block);
  7,194,386 ( 0.01%)          while (s >= 2*sz) {
  1,313,077 ( 0.00%)            ptr_cast<FreeList*>(block)->next(ptr_cast<FreeList*>(block+sz));
          .                     block += sz;
          .                     s     -= sz;
          .                   }
          .                   ptr_cast<FreeList*>(block)->next(nullptr);
  2,275,868 ( 0.00%)        } while (m != nullptr);
          .               } else {
          .                 char* block = static_cast<char*>(alloc(sm,MemoryConfig::fl_refill*sz));
  1,055,090 ( 0.00%)        fl[sz2i(sz)] = ptr_cast<FreeList*>(block);
          .                 int i = MemoryConfig::fl_refill-2;
          .                 do {
 12,661,080 ( 0.01%)          ptr_cast<FreeList*>(block+static_cast<unsigned int>(i)*sz)
  2,110,180 ( 0.00%)            ->next(ptr_cast<FreeList*>(block+
          .                                                (static_cast<unsigned int>(i)+1)*sz));
          .                 } while (--i >= 0);
          .                 ptr_cast<FreeList*>(block+
          .                                     (MemoryConfig::fl_refill-1)*sz)->next
          .                   (ptr_cast<FreeList*>(nullptr));
          .               }
  2,110,180 ( 0.00%)    }
          .           
          .           }}
          .           
          .           // STATISTICS: kernel-memory

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/int/branch/val-commit.hpp
--------------------------------------------------------------------------------
Ir                  

-- line 40 ----------------------------------------
         .               : ValCommit<View,int>(home,vb) {}
         .             template<class View>
         .             forceinline
         .             ValCommitEq<View>::ValCommitEq(Space& home, ValCommitEq& vc)
         .               : ValCommit<View,int>(home,vc) {}
         .             template<class View>
         .             forceinline ModEvent
         .             ValCommitEq<View>::commit(Space& home, unsigned int a, View x, int, int n) {
55,089,762 ( 0.06%)      return (a == 0) ? x.eq(home,n) : x.nq(home,n);
         .             }
         .             template<class View>
         .             forceinline NGL*
         .             ValCommitEq<View>::ngl(Space& home, unsigned int a, View x, int n) const {
         .               if (a == 0)
         .                 return new (home) EqNGL<View>(home,x,n);
         .               else
         .                 return nullptr;
-- line 56 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/search/worker.hh
--------------------------------------------------------------------------------
Ir                  

-- line 63 ----------------------------------------
         .               /// Return steal depth
         .               unsigned long int steal_depth(unsigned long int d) const;
         .             };
         .           
         .           
         .           
         .             forceinline
         .             Worker::Worker(void)
         4 ( 0.00%)      : _stopped(false), root_depth(0) {}
         .           
         .             forceinline void
         .             Worker::start(void) {
    20,486 ( 0.00%)      _stopped = false;
         .             }
         .           
         .             forceinline bool
         .             Worker::stop(const Options& o) {
47,974,677 ( 0.05%)      if (o.stop == nullptr)
         .                 return false;
79,998,767 ( 0.09%)      _stopped |= o.stop->stop(*this,o);
905,028,357 ( 1.01%)  => /home/dexter/master-thesis/gecode-dexter/gecode/search/seq/rbs.cpp:Gecode::Search::Seq::RestartStop::stop(Gecode::Search::Statistics const&, Gecode::Search::Options const&) (10,418,163x)
         .               return _stopped;
         .             }
         .           
         .             forceinline bool
         .             Worker::stopped(void) const {
         .               return _stopped;
         .             }
         .           
         .             forceinline void
         .             Worker::reset(unsigned long int d) {
         .               Statistics::reset();
    20,483 ( 0.00%)      root_depth = d;
         .               if (depth < d)
         .                 depth = d;
         .             }
         .           
         .             forceinline void
         .             Worker::stack_depth(unsigned long int d) {
24,131,043 ( 0.03%)      if (depth < root_depth + d)
   300,492 ( 0.00%)        depth = root_depth + d;
         .             }
         .           
         .             forceinline unsigned long int
         .             Worker::steal_depth(unsigned long int d) const {
         .               return root_depth + d;
         .             }
         .           
         .           }}
-- line 110 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/int/count/int-base.hpp
--------------------------------------------------------------------------------
Ir                  

-- line 32 ----------------------------------------
         .            */
         .           
         .           namespace Gecode { namespace Int { namespace Count {
         .           
         .             template<class VX, class VY>
         .             forceinline
         .             IntBase<VX,VY>::IntBase(Home home,
         .                                     ViewArray<VX>& x0, int n_s0, VY y0, int c0)
         6 ( 0.00%)      : Propagator(home), x(x0), n_s(n_s0), y(y0), c(c0) {
         .               if (isintset(y))
         .                 home.notice(*this,AP_DISPOSE);
        15 ( 0.00%)      for (int i=0; i<n_s; i++)
         .                 x[i].subscribe(home,*this,PC_INT_DOM);
         .               subscribe(home,*this,y);
         .             }
         .           
         .             template<class VX, class VY>
         .             forceinline size_t
         .             IntBase<VX,VY>::dispose(Space& home) {
         .               if (isintset(y))
         .                 home.ignore(*this,AP_DISPOSE);
56,326,275 ( 0.06%)      for (int i=0; i<n_s; i++)
         .                 x[i].cancel(home,*this,PC_INT_DOM);
         .               cancel(home,*this,y);
         .               (void) Propagator::dispose(home);
         .               return sizeof(*this);
         .             }
         .           
         .             template<class VX, class VY>
         .             forceinline
         .             IntBase<VX,VY>::IntBase(Space& home, IntBase<VX,VY>& p)
37,985,437 ( 0.04%)      : Propagator(home,p), n_s(p.n_s), c(p.c) {
16,279,473 ( 0.02%)      x.update(home,p.x);
1,219,797,483 ( 1.36%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/data/array.hpp:Gecode::ViewArray<Gecode::Int::IntView>::update(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&) (5,426,491x)
         .               update(y,home,p.y);
         .             }
         .           
         .             template<class VX, class VY>
         .             PropCost
18,397,138 ( 0.02%)    IntBase<VX,VY>::cost(const Space&, const ModEventDelta&) const {
         .               return PropCost::linear(PropCost::LO,x.size());
18,397,138 ( 0.02%)    }
         .           
         .             template<class VX, class VY>
         .             void
         .             IntBase<VX,VY>::reschedule(Space& home) {
         .               for (int i=0; i<n_s; i++)
         .                 x[i].reschedule(home,*this,PC_INT_DOM);
         .               Gecode::Int::Count::reschedule(home,*this,y);
         .             }
-- line 80 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/data/array.hpp
--------------------------------------------------------------------------------
Ir                     

-- line 300 ----------------------------------------
            .               /**
            .                * \brief Initialize from variable argument array \a a (copy elements)
            .                *
            .                * Note that the view type \a View must provide a constructor
            .                * for the associated \a Var type.
            .                */
            .               template<class Var>
            .               ViewArray(Space& home, const VarArgArray<Var>& a)
            2 ( 0.00%)        : n(a.size()) {
            .                 // This may not be in the hpp file (to satisfy the MS compiler)
           12 ( 0.00%)        if (n>0) {
            7 ( 0.00%)          x = home.alloc<View>(n);
          174 ( 0.00%)          for (int i=0; i<n; i++)
           58 ( 0.00%)            x[i]=a[i];
            .                 } else {
            4 ( 0.00%)          x = nullptr;
            .                 }
            .               }
            .               /**
            .                * \brief Initialize from variable argument array \a a (copy elements)
            .                *
            .                * Note that the view type \a View must provide a constructor
            .                * for the associated \a Var type.
            .                */
-- line 323 ----------------------------------------
-- line 903 ----------------------------------------
            .              * Variable arrays
            .              *
            .              * These arrays are allocated in the space.
            .              *
            .              */
            .           
            .             template<class Var>
            .             forceinline
  232,468,495 ( 0.26%)    VarArray<Var>::VarArray(void) : n(0), x(nullptr) {}
            .           
            .             template<class Var>
            .             forceinline
            .             VarArray<Var>::VarArray(Space& home, int n0)
            1 ( 0.00%)      : n(n0) {
            .               // Allocate from space
           11 ( 0.00%)      x = (n>0) ? home.alloc<Var>(n) : nullptr;
            .             }
            .           
            .             template<class Var>
            .             forceinline
            .             VarArray<Var>::VarArray(const VarArray<Var>& a) {
            .               n = a.n; x = a.x;
            .             }
            .           
            .             template<class Var>
            .             inline const VarArray<Var>&
            1 ( 0.00%)    VarArray<Var>::operator =(const VarArray<Var>& a) {
   64,129,268 ( 0.07%)      n = a.n; x = a.x;
            .               return *this;
            .             }
            .           
            .             template<class Var>
            .             forceinline int
            .             VarArray<Var>::size(void) const {
   32,085,154 ( 0.04%)      return n;
            .             }
            .           
            .             template<class Var>
            .             forceinline Var&
            .             VarArray<Var>::operator [](int i) {
            .               assert((i >= 0) && (i < size()));
       41,025 ( 0.00%)      return x[i];
            .             }
            .           
            .             template<class Var>
            .             forceinline const Var&
            .             VarArray<Var>::operator [](int i) const {
            .               assert((i >= 0) && (i < size()));
       88,479 ( 0.00%)      return x[i];
            .             }
            .           
            .             template<class Var>
            .             typename ArrayTraits<VarArgArray<Var>>::ArgsType
            .             VarArray<Var>::slice(int start, int inc, int maxN) {
            .               assert(n==0 || start < n);
            .               if (n==0 || maxN<0)
            .                 maxN = n;
-- line 959 ----------------------------------------
-- line 1016 ----------------------------------------
            .             forceinline typename VarArray<Var>::const_reverse_iterator
            .             VarArray<Var>::rend(void) const {
            .               return const_reverse_iterator(x);
            .             }
            .           
            .             template<class Var>
            .             forceinline void
            .             VarArray<Var>::update(Space& home, VarArray<Var>& a) {
  160,323,080 ( 0.18%)      n = a.n;
  160,323,080 ( 0.18%)      if (n > 0) {
   24,048,460 ( 0.03%)        x = home.alloc<Var>(n);
  961,938,430 ( 1.08%)        for (int i=0; i<n; i++)
  553,114,600 ( 0.62%)          x[i].update(home, a.x[i]);
            .               } else {
   88,177,696 ( 0.10%)        x = nullptr;
            .               }
            .             }
            .           
            .             template<class Var>
            .             forceinline bool
            .             VarArray<Var>::assigned(void) const {
            .               for (int i=0; i<n; i++)
            .                 if (!x[i].assigned())
-- line 1038 ----------------------------------------
-- line 1096 ----------------------------------------
            .           
            .             /*
            .              * View arrays
            .              *
            .              */
            .           
            .             template<class View>
            .             forceinline
   85,993,158 ( 0.10%)    ViewArray<View>::ViewArray(void) : n(0), x(nullptr) {}
            .           
            .             template<class View>
            .             forceinline
            .             ViewArray<View>::ViewArray(Space& home, int n0)
            8 ( 0.00%)      : n(n0) {
           12 ( 0.00%)      x = (n>0) ? home.alloc<View>(n) : nullptr;
            .             }
            .             template<class View>
            .             forceinline
            .             ViewArray<View>::ViewArray(Region& r, int n0)
            .               : n(n0) {
            .               x = (n>0) ? r.alloc<View>(n) : nullptr;
            .             }
            .           
            .             template<class View>
            .             ViewArray<View>::ViewArray(Space& home, const ViewArray<View>& a)
            1 ( 0.00%)      : n(a.size()) {
            2 ( 0.00%)      if (n>0) {
            1 ( 0.00%)        x = home.alloc<View>(n);
           27 ( 0.00%)        for (int i=0; i<n; i++)
           21 ( 0.00%)          x[i] = a[i];
            .               } else {
            .                 x = nullptr;
            .               }
            .             }
            .             template<class View>
            .             ViewArray<View>::ViewArray(Region& r, const ViewArray<View>& a)
            .               : n(a.size()) {
            .               if (n>0) {
-- line 1133 ----------------------------------------
-- line 1137 ----------------------------------------
            .               } else {
            .                 x = nullptr;
            .               }
            .             }
            .           
            .             template<class View>
            .             forceinline
            .             ViewArray<View>::ViewArray(const ViewArray<View>& a)
        1,666 ( 0.00%)      : n(a.n), x(a.x) {}
            .           
            .             template<class View>
            .             forceinline const ViewArray<View>&
            .             ViewArray<View>::operator =(const ViewArray<View>& a) {
            .               n = a.n; x = a.x;
            .               return *this;
            .             }
            .           
            .             template<class View>
            .             forceinline int
            1 ( 0.00%)    ViewArray<View>::size(void) const {
  318,625,695 ( 0.36%)      return n;
            .             }
            .           
            .             template<class View>
            .             forceinline void
            .             ViewArray<View>::size(int n0) {
   57,791,244 ( 0.06%)      n = n0;
            .             }
            .           
            .             template<class View>
            .             forceinline View&
    1,997,082 ( 0.00%)    ViewArray<View>::operator [](int i) {
            .               assert((i >= 0) && (i < size()));
1,717,337,126 ( 1.92%)      return x[i];
            .             }
            .           
            .             template<class View>
            .             forceinline const View&
            .             ViewArray<View>::operator [](int i) const {
            .               assert((i >= 0) && (i < size()));
   26,642,183 ( 0.03%)      return x[i];
            .             }
            .           
            .             template<class View>
            .             forceinline typename ViewArray<View>::iterator
            .             ViewArray<View>::begin(void) {
            .               return x;
            .             }
            .           
-- line 1185 ----------------------------------------
-- line 1320 ----------------------------------------
            .               assert(i<n);
            .               for (int j=i+1; j<n; j++)
            .                 x[j].cancel(home,a);
            .               n = i+1;
            .             }
            .           
            .             template<class View>
            .             void
  376,037,240 ( 0.42%)    ViewArray<View>::update(Space& home, ViewArray<View>& y) {
   85,993,158 ( 0.10%)      n = y.n;
   85,993,158 ( 0.10%)      if (n > 0) {
   42,996,579 ( 0.05%)        x = home.alloc<View>(n);
1,030,665,288 ( 1.15%)        for (int i=0; i<n; i++)
  725,885,649 ( 0.81%)          x[i].update(home, y.x[i]);
            .               } else {
            .                 x = nullptr;
            .               }
  290,044,082 ( 0.32%)    }
            .           
            .             template<class View>
            .             void
            .             ViewArray<View>::subscribe(Space& home, Propagator& p, PropCond pc,
            .                                        bool schedule) {
          126 ( 0.00%)      for (int i=0; i<n; i++)
           13 ( 0.00%)        x[i].subscribe(home,p,pc,schedule);
            .             }
            .           
            .             template<class View>
            .             void
            .             ViewArray<View>::cancel(Space& home, Propagator& p, PropCond pc) {
   14,635,718 ( 0.02%)      for (int i=0; i<n; i++)
      150,888 ( 0.00%)        x[i].cancel(home,p,pc);
            .             }
            .           
            .             template<class View>
            .             void
            .             ViewArray<View>::subscribe(Space& home, Advisor& a) {
            .               for (int i=0; i<n; i++)
            .                 x[i].subscribe(home,a);
            .             }
-- line 1359 ----------------------------------------
-- line 1509 ----------------------------------------
            .             /*
            .              * Argument arrays: base class
            .              *
            .              */
            .           
            .             template<class T>
            .             forceinline T*
            .             ArgArrayBase<T>::allocate(int n) {
       82,037 ( 0.00%)      return (n > onstack_size) ?
            .                 heap.alloc<T>(static_cast<unsigned int>(n)) : &onstack[0];
            .             }
            .           
            .             template<class T>
            .             forceinline void
            .             ArgArrayBase<T>::resize(int i) {
            .               if (n+i >= capacity) {
            .                 assert(n+i >= onstack_size);
-- line 1525 ----------------------------------------
-- line 1533 ----------------------------------------
            .                 capacity = newCapacity;
            .                 a = newA;
            .               }
            .             }
            .           
            .             template<class T>
            .             forceinline
            .             ArgArrayBase<T>::ArgArrayBase(void)
  128,258,464 ( 0.14%)      : n(0), capacity(onstack_size), a(allocate(0)) {}
            .           
            .             template<class T>
            .             forceinline
            .             ArgArrayBase<T>::ArgArrayBase(int n0)
      164,060 ( 0.00%)      : n(n0), capacity(n < onstack_size ? onstack_size : n), a(allocate(n)) {}
            .           
            .             template<class T>
            .             inline
            .             ArgArrayBase<T>::ArgArrayBase(const ArgArrayBase<T>& aa)
           51 ( 0.00%)      : n(aa.n), capacity(n < onstack_size ? onstack_size : n), a(allocate(n)) {
            5 ( 0.00%)      heap.copy<T>(a,aa.a,n);
            .             }
            .           
            .             template<class T>
            .             inline
            .             ArgArrayBase<T>::ArgArrayBase(const std::vector<T>& aa)
            .               : n(static_cast<int>(aa.size())),
            .                 capacity(n < onstack_size ? onstack_size : n), a(allocate(n)) {
            .               heap.copy<T>(a,&aa[0],n);
-- line 1560 ----------------------------------------
-- line 1568 ----------------------------------------
            .               int i=0;
            .               for (const T& x : aa)
            .                 a[i++]=x;
            .             }
            .           
            .             template<class T>
            .             forceinline
            .             ArgArrayBase<T>::~ArgArrayBase(void) {
   64,170,258 ( 0.07%)      if (capacity > onstack_size)
            .                 heap.free(a,capacity);
            .             }
            .           
            .             template<class T>
            .             forceinline const ArgArrayBase<T>&
            .             ArgArrayBase<T>::operator =(const ArgArrayBase<T>& aa) {
            .               if (&aa != this) {
            .                 if (capacity > onstack_size)
-- line 1584 ----------------------------------------
-- line 1589 ----------------------------------------
            .                 heap.copy<T>(a,aa.a,n);
            .               }
            .               return *this;
            .             }
            .           
            .             template<class T>
            .             forceinline int
            .             ArgArrayBase<T>::size(void) const {
           66 ( 0.00%)      return n;
            .             }
            .           
            .             template<class T>
            .             forceinline T&
            1 ( 0.00%)    ArgArrayBase<T>::operator [](int i) {
            .               assert((i>=0) && (i < n));
           87 ( 0.00%)      return a[i];
            .             }
            .           
            .             template<class T>
            .             forceinline const T&
            .             ArgArrayBase<T>::operator [](int i) const {
            .               assert((i>=0) && (i < n));
            .               return a[i];
            .             }
-- line 1612 ----------------------------------------
-- line 1849 ----------------------------------------
            .             template<class Var>
            .             template<class InputIterator>
            .             forceinline
            .             VarArgArray<Var>::VarArgArray(InputIterator first, InputIterator last)
            .               : ArgArrayBase<Var>(first,last) {}
            .           
            .             template<class Var>
            .             inline
      122,904 ( 0.00%)    VarArgArray<Var>::VarArgArray(const VarArray<Var>& x)
            .               : ArgArrayBase<Var>(x.size()) {
      512,100 ( 0.00%)      for (int i=0; i<x.size(); i++)
      573,552 ( 0.00%)        a[i]=x[i];
       81,936 ( 0.00%)    }
            .           
            .             template<class Var>
            .             forceinline typename ArrayTraits<VarArgArray<Var>>::ArgsType
            .             VarArgArray<Var>::slice(int start, int inc, int maxN) {
            .               return ArgArrayBase<Var>::template slice
            .                 <typename ArrayTraits<VarArgArray<Var>>::ArgsType>
            .                   (start,inc,maxN);
            .             }
-- line 1869 ----------------------------------------
-- line 1958 ----------------------------------------
            .             template<class Var>
            .             forceinline bool
            .             same(Var x, VarArgArray<Var> y) {
            .               return same(y,x);
            .             }
            .           
            .             template<class Var>
            .             bool
            8 ( 0.00%)    same(VarArgArray<Var> x) {
            3 ( 0.00%)      if (x.size() < 2)
            .                 return false;
            .               Region r;
            .               void** px = r.alloc<void*>(x.size());
            1 ( 0.00%)      int j=0;
           25 ( 0.00%)      for (int i=0; i<x.size(); i++)
           21 ( 0.00%)        if (!x[i].assigned())
           26 ( 0.00%)          px[j++] = x[i].varimp();
            5 ( 0.00%)      return (j > 1) && Kernel::duplicates(px,j);
        1,380 ( 0.00%)  => ???:0x0000000004e95630 (1x)
            9 ( 0.00%)    }
            .           
            .           
            .           
            .             /*
            .              * Interdependent code
            .              *
            .              */
            .           
            .             template<class Var>
            .             inline
            .             VarArray<Var>::VarArray(Space& home, const VarArgArray<Var>& a)
            .               : n(a.size()) {
   64,129,248 ( 0.07%)      if (n>0) {
            .                 x = home.alloc<Var>(n);
            .                 for (int i=0; i<n; i++)
            .                   x[i] = a[i];
            .               } else {
   32,064,632 ( 0.04%)        x = nullptr;
            .               }
            .             }
            .           
            .           
            .             /*
            .              * Printing of arrays
            .              *
            .              */
-- line 2002 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/int/linear/int-nary.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 54 ----------------------------------------
          .           
          .             /*
          .              * Linear propagators
          .              *
          .              */
          .             template<class Val, class P, class N, PropCond pc>
          .             forceinline
          .             Lin<Val,P,N,pc>::Lin(Home home, ViewArray<P>& x0, ViewArray<N>& y0, Val c0)
          6 ( 0.00%)      : Propagator(home), x(x0), y(y0), c(c0) {
          .               x.subscribe(home,*this,pc);
          .               y.subscribe(home,*this,pc);
          .             }
          .           
          .             template<class Val, class P, class N, PropCond pc>
          .             forceinline
          .             Lin<Val,P,N,pc>::Lin(Space& home, Lin<Val,P,N,pc>& p)
 48,096,912 ( 0.05%)      : Propagator(home,p), c(p.c) {
 24,048,456 ( 0.03%)      x.update(home,p.x);
881,776,720 ( 0.99%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/data/array.hpp:Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >::update(Gecode::Space&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&) (8,016,152x)
 32,064,608 ( 0.04%)      y.update(home,p.y);
1,958,541,113 ( 2.19%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/data/array.hpp:Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >::update(Gecode::Space&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&) (8,016,152x)
          .             }
          .           
          .             template<class Val, class P, class N, PropCond pc>
          .             PropCost
 28,868,988 ( 0.03%)    Lin<Val,P,N,pc>::cost(const Space&, const ModEventDelta&) const {
 57,737,972 ( 0.06%)      return PropCost::linear(PropCost::LO, x.size()+y.size());
 57,737,974 ( 0.06%)    }
          .           
          .             template<class Val, class P, class N, PropCond pc>
          .             void
          .             Lin<Val,P,N,pc>::reschedule(Space& home) {
          .               x.reschedule(home,*this,pc);
          .               y.reschedule(home,*this,pc);
          .             }
          .           
          .             template<class Val, class P, class N, PropCond pc>
          .             forceinline size_t
  3,676,533 ( 0.00%)    Lin<Val,P,N,pc>::dispose(Space& home) {
          .               x.cancel(home,*this,pc);
          .               y.cancel(home,*this,pc);
          .               (void) Propagator::dispose(home);
          .               return sizeof(*this);
  3,063,777 ( 0.00%)    }
          .           
          .             /*
          .              * Reified linear propagators
          .              *
          .              */
          .             template<class Val, class P, class N, PropCond pc, class Ctrl>
          .             forceinline
          .             ReLin<Val,P,N,pc,Ctrl>::ReLin
-- line 103 ----------------------------------------
-- line 132 ----------------------------------------
          .           
          .             /*
          .              * Computing bounds
          .              *
          .              */
          .           
          .             template<class Val, class View>
          .             void
152,342,374 ( 0.17%)    bounds_p(ModEventDelta med, ViewArray<View>& x, Val& c, Val& sl, Val& su) {
          .               int n = x.size();
 35,826,596 ( 0.04%)      if (IntView::me(med) == ME_INT_VAL) {
104,555,969 ( 0.12%)        for (int i=n; i--; ) {
          .                   Val m = x[i].min();
 29,873,142 ( 0.03%)          if (x[i].assigned()) {
         56 ( 0.00%)            c -= m; x[i] = x[--n];
          .                   } else {
 29,873,128 ( 0.03%)            sl -= m; su -= x[i].max();
          .                   }
          .                 }
          .                 x.size(n);
          .               } else {
 44,703,922 ( 0.05%)        for (int i=0; i<n; i++) {
  5,953,480 ( 0.01%)          sl -= x[i].min(); su -= x[i].max();
          .                 }
          .               }
 44,809,692 ( 0.05%)    }
          .           
          .             template<class Val, class View>
          .             void
152,342,373 ( 0.17%)    bounds_n(ModEventDelta med, ViewArray<View>& y, Val& c, Val& sl, Val& su) {
          .               int n = y.size();
 35,826,594 ( 0.04%)      if (IntView::me(med) == ME_INT_VAL) {
267,877,004 ( 0.30%)        for (int i=n; i--; ) {
          .                   Val m = y[i].max();
138,753,832 ( 0.16%)          if (y[i].assigned()) {
199,974,408 ( 0.22%)            c += m; y[i] = y[--n];
          .                   } else {
 88,760,230 ( 0.10%)            sl += m; su += y[i].min();
          .                   }
          .                 }
          .                 y.size(n);
          .               } else {
 80,744,112 ( 0.09%)        for (int i=0; i<n; i++) {
 29,980,278 ( 0.03%)          sl += y[i].max(); su += y[i].min();
          .                 }
          .               }
 44,809,692 ( 0.05%)    }
          .           
          .           
          .             template<class Val, class P, class N>
          .             ExecStatus
304,526,065 ( 0.34%)    prop_bnd(Space& home, ModEventDelta med, Propagator& p,
          .                      ViewArray<P>& x, ViewArray<N>& y, Val& c) {
          .               // Eliminate singletons
 17,913,298 ( 0.02%)      Val sl = 0;
 17,913,298 ( 0.02%)      Val su = 0;
          .           
143,306,382 ( 0.16%)      bounds_p<Val,P>(med, x, c, sl, su);
692,771,062 ( 0.77%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/int/linear/int-nary.hpp:void Gecode::Int::Linear::bounds_p<int, Gecode::Int::ScaleView<int, unsigned int> >(int, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, int&, int&, int&) (17,913,297x)
107,479,782 ( 0.12%)      bounds_n<Val,N>(med, y, c, sl, su);
1,927,888,744 ( 2.16%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/int/linear/int-nary.hpp:void Gecode::Int::Linear::bounds_n<int, Gecode::Int::ScaleView<int, unsigned int> >(int, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, int&, int&, int&) (17,913,297x)
          .           
 80,636,288 ( 0.09%)      if ((IntView::me(med) == ME_INT_VAL) && ((x.size() + y.size()) <= 1)) {
  6,997,866 ( 0.01%)        if (x.size() == 1) {
  7,875,934 ( 0.01%)          GECODE_ME_CHECK(x[0].eq(home,c));
          .                   return home.ES_SUBSUMED(p);
          .                 }
          .                 if (y.size() == 1) {
          4 ( 0.00%)          GECODE_ME_CHECK(y[0].eq(home,-c));
          .                   return home.ES_SUBSUMED(p);
          .                 }
          .                 return (c == static_cast<Val>(0)) ?
          .                   home.ES_SUBSUMED(p) : ES_FAILED;
          .               }
          .           
 43,243,095 ( 0.05%)      sl += c; su += c;
          .           
          .               const int mod_sl = 1;
          .               const int mod_su = 2;
          .           
 28,828,730 ( 0.03%)      int mod = mod_sl | mod_su;
          .           
          .               do {
 49,040,872 ( 0.05%)        if (mod & mod_sl) {
 24,520,436 ( 0.03%)          mod -= mod_sl;
          .                   // Propagate upper bound for positive variables
122,602,199 ( 0.14%)          for (int i=0; i<x.size(); i++) {
          .                     const Val xi_max = x[i].max();
 24,520,444 ( 0.03%)            ModEvent me = x[i].lq(home,sl + x[i].min());
    479,206 ( 0.00%)            if (me_failed(me))
          .                       return ES_FAILED;
    479,206 ( 0.00%)            if (me_modified(me)) {
    479,206 ( 0.00%)              su += xi_max - x[i].max();
    239,603 ( 0.00%)              mod |= mod_su;
          .                     }
          .                   }
          .                   // Propagate lower bound for negative variables
405,869,800 ( 0.45%)          for (int i=0; i<y.size(); i++) {
          .                     const Val yi_min = y[i].min();
225,198,195 ( 0.25%)            ModEvent me = y[i].gq(home,y[i].max() - sl);
          .                     if (me_failed(me))
          .                       return ES_FAILED;
          .                     if (me_modified(me)) {
          .                       su += y[i].min() - yi_min;
          .                       mod |= mod_su;
          .                     }
          .                   }
          .                 }
 49,040,872 ( 0.05%)        if (mod & mod_su) {
 14,653,941 ( 0.02%)          mod -= mod_su;
          .                   // Propagate lower bound for positive variables
 70,635,514 ( 0.08%)          for (int i=0; i<x.size(); i++) {
          .                     const Val xi_min = x[i].min();
 14,653,949 ( 0.02%)            ModEvent me = x[i].gq(home,su + x[i].max());
 20,212,140 ( 0.02%)            if (me_failed(me))
          .                       return ES_FAILED;
 20,212,140 ( 0.02%)            if (me_modified(me)) {
 20,212,140 ( 0.02%)              sl += xi_min - x[i].min();
 10,106,070 ( 0.01%)              mod |= mod_sl;
          .                     }
          .                   }
          .                   // Propagate upper bound for negative variables
243,117,973 ( 0.27%)          for (int i=0; i<y.size(); i++) {
          .                     const Val yi_max = y[i].max();
228,122,182 ( 0.26%)            ModEvent me = y[i].lq(home,y[i].min() - su);
 50,606,008 ( 0.06%)            if (me_failed(me))
          .                       return ES_FAILED;
 50,606,008 ( 0.06%)            if (me_modified(me)) {
 50,606,008 ( 0.06%)              sl += y[i].max() - yi_max;
 25,303,004 ( 0.03%)              mod |= mod_sl;
          .                     }
          .                   }
          .                 }
 47,284,732 ( 0.05%)      } while (mod);
          .           
 81,217,774 ( 0.09%)      return (sl == su) ? home.ES_SUBSUMED(p) : ES_FIX;
197,046,278 ( 0.22%)    }
          .           
          .             /*
          .              * Bound consistent linear equation
          .              *
          .              */
          .           
          .             template<class Val, class P, class N>
          .             forceinline
          .             Eq<Val,P,N>::Eq(Home home, ViewArray<P>& x, ViewArray<N>& y, Val c)
          5 ( 0.00%)      : Lin<Val,P,N,PC_INT_BND>(home,x,y,c) {}
          .           
          .             template<class Val, class P, class N>
          .             ExecStatus
         20 ( 0.00%)    Eq<Val,P,N>::post(Home home, ViewArray<P>& x, ViewArray<N>& y, Val c) {
          .               ViewArray<NoView> nva;
          6 ( 0.00%)      if (y.size() == 0) {
          .                 (void) new (home) Eq<Val,P,NoView>(home,x,nva,c);
          4 ( 0.00%)      } else if (x.size() == 0) {
          .                 (void) new (home) Eq<Val,N,NoView>(home,y,nva,-c);
          .               } else {
          .                 (void) new (home) Eq<Val,P,N>(home,x,y,c);
          .               }
          .               return ES_OK;
         18 ( 0.00%)    }
          .           
          .           
          .             template<class Val, class P, class N>
          .             forceinline
          .             Eq<Val,P,N>::Eq(Space& home, Eq<Val,P,N>& p)
 16,032,304 ( 0.02%)      : Lin<Val,P,N,PC_INT_BND>(home,p) {}
          .           
          .             /**
          .              * \brief Rewriting of equality to binary propagators
          .              *
          .              */
          .             template<class Val, class P, class N>
          .             forceinline Actor*
          .             eqtobin(Space&, Propagator&, ViewArray<P>&, ViewArray<N>&, Val) {
-- line 304 ----------------------------------------
-- line 373 ----------------------------------------
          .                 return new (home) EqTer<Val,IntView,IntView,MinusView>
          .                   (home,p,y[0],y[1],MinusView(x[0]),-c);
          .               return new (home) EqTer<Val,IntView,IntView,IntView>
          .                 (home,p,y[0],y[1],y[2],-c);
          .             }
          .           
          .             template<class Val, class P, class N>
          .             Actor*
 64,129,216 ( 0.07%)    Eq<Val,P,N>::copy(Space& home) {
          .               if (isunit(x,y)) {
          .                 // Check whether rewriting is possible
          .                 if (x.size() + y.size() == 2)
          .                   return eqtobin(home,*this,x,y,c);
          .                 if (x.size() + y.size() == 3)
          .                   return eqtoter(home,*this,x,y,c);
          .               }
          .               return new (home) Eq<Val,P,N>(home,*this);
 56,113,064 ( 0.06%)    }
          .           
          .             template<class Val, class P, class N>
          .             ExecStatus
 71,653,192 ( 0.08%)    Eq<Val,P,N>::propagate(Space& home, const ModEventDelta& med) {
107,479,788 ( 0.12%)      return prop_bnd<Val,P,N>(home,med,*this,x,y,c);
      2,777 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/int/linear/int-nary.hpp:Gecode::ExecStatus Gecode::Int::Linear::prop_bnd<int, Gecode::Int::ScaleView<int, unsigned int>, Gecode::Int::Linear::NoView>(Gecode::Space&, int, Gecode::Propagator&, Gecode::ViewArray<Gecode::Int::ScaleView<int, unsigned int> >&, Gecode::ViewArray<Gecode::Int::Linear::NoView>&, int&) (1x)
          .             }
          .           
          .             /*
          .              * Reified bound consistent linear equation
          .              *
          .              */
          .           
          .             template<class Val, class P, class N, class Ctrl, ReifyMode rm>
-- line 403 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/int/count/rel.hpp
--------------------------------------------------------------------------------
Ir                  

-- line 163 ----------------------------------------
         .             post_true(Home home, VX x, const IntSet& y) {
         .               IntSetRanges ry(y);
         .               GECODE_ME_CHECK(x.inter_r(home,ry,false));
         .               return ES_OK;
         .             }
         .             template<class VX>
         .             forceinline ExecStatus
         .             post_true(Home home, ViewArray<VX>& x, ConstIntView y) {
29,542,275 ( 0.03%)      for (int i=0; i<x.size(); i++)
19,694,850 ( 0.02%)        GECODE_ME_CHECK(x[i].eq(home,y.val()));
         .               return ES_OK;
         .             }
         .             template<class VX>
         .             forceinline ExecStatus
         .             post_true(Home home, ViewArray<VX>& x, ZeroIntView) {
         .               for (int i=0; i<x.size(); i++)
         .                 GECODE_ME_CHECK(x[i].eq(home,0));
         .               return ES_OK;
-- line 180 ----------------------------------------
-- line 206 ----------------------------------------
         .             post_false(Home home, VX x, const IntSet& y) {
         .               IntSetRanges ry(y);
         .               GECODE_ME_CHECK(x.minus_r(home,ry,false));
         .               return ES_OK;
         .             }
         .             template<class VX>
         .             forceinline ExecStatus
         .             post_false(Home home, ViewArray<VX>& x, ConstIntView y) {
    54,580 ( 0.00%)      for (int i=0; i<x.size(); i++)
    15,504 ( 0.00%)        GECODE_ME_CHECK(x[i].nq(home,y.val()));
         .               return ES_OK;
         .             }
         .             template<class VX>
         .             forceinline ExecStatus
         .             post_false(Home home, ViewArray<VX>& x, ZeroIntView) {
         .               for (int i=0; i<x.size(); i++)
         .                 GECODE_ME_CHECK(x[i].nq(home,0));
         .               return ES_OK;
-- line 223 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/int/div.hpp
--------------------------------------------------------------------------------
Ir                  

-- line 37 ----------------------------------------
         .             forceinline IntType
         .             ceil_div_pp(IntType x, IntType y) {
         .               assert((x >= 0) && (y >= 0));
         .               /*
         .                * This is smarter than it looks: for many cpus, % and / are
         .                * implemented by the same instruction and an optimizing compiler
         .                * will generate the instruction only once.
         .                */
87,873,120 ( 0.10%)      return ((x % y) == 0) ? x/y : (x/y + 1);
         .             }
         .             template<class IntType>
         .             forceinline IntType
         .             floor_div_pp(IntType x, IntType y) {
         .               assert((x >= 0) && (y >= 0));
51,085,214 ( 0.06%)      return x / y;
         .             }
         .           
         .             template<class IntType>
         .             forceinline IntType
         .             ceil_div_px(IntType x, IntType y) {
         .               assert(x >= 0);
         .               return (y >= 0) ? ceil_div_pp(x,y) : -floor_div_pp(x,-y);
         .             }
-- line 59 ----------------------------------------
-- line 69 ----------------------------------------
         .             ceil_div_xp(IntType x, IntType y) {
         .               assert(y >= 0);
         .               return (x >= 0) ? ceil_div_pp(x,y) : -floor_div_pp(-x,y);
         .             }
         .             template<class IntType>
         .             forceinline IntType
         .             floor_div_xp(IntType x, IntType y) {
         .               assert(y >= 0);
51,085,214 ( 0.06%)      return (x >= 0) ? floor_div_pp(x,y) : -ceil_div_pp(-x,y);
         .             }
         .           
         .             template<class IntType>
         .             forceinline IntType
         .             ceil_div_xx(IntType x, IntType y) {
         .               return (x >= 0) ? ceil_div_px(x,y) : -floor_div_px(-x,y);
         .             }
         .             template<class IntType>
-- line 85 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/shared-object.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 86 ----------------------------------------
          .               SharedHandle::Object* object(void) const;
          .               /// Modify shared object
          .               void object(SharedHandle::Object* n);
          .             };
          .           
          .           
          .             forceinline
          .             SharedHandle::Object::Object(void)
        108 ( 0.00%)      : rc(0) {}
          .             forceinline
          .             SharedHandle::Object::~Object(void) {
          .               assert(!rc);
          .             }
          .           
          .           
          .             forceinline SharedHandle::Object*
          .             SharedHandle::object(void) const {
 56,331,643 ( 0.06%)      return o;
          .             }
          .             forceinline void
          .             SharedHandle::subscribe(void) {
112,267,526 ( 0.13%)      if (o != nullptr) o->rc.inc();
          .             }
          .             forceinline void
          .             SharedHandle::cancel(void) {
232,571,896 ( 0.26%)      if ((o != nullptr) && o->rc.dec())
        140 ( 0.00%)        delete o;
      6,470 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/gecode/int/int-set.cpp:Gecode::IntSet::IntSetObject::~IntSetObject() (22x)
         12 ( 0.00%)      o=nullptr;
          .             }
          .             forceinline void
          .             SharedHandle::object(SharedHandle::Object* n) {
         93 ( 0.00%)      if (n != o) {
         29 ( 0.00%)        cancel(); o=n; subscribe();
          .               }
          .             }
          .             forceinline
  8,016,297 ( 0.01%)    SharedHandle::SharedHandle(void) : o(nullptr) {}
          .             forceinline
  8,016,162 ( 0.01%)    SharedHandle::SharedHandle(SharedHandle::Object* so) : o(so) {
          .               subscribe();
          .             }
          .             forceinline
 80,202,886 ( 0.09%)    SharedHandle::SharedHandle(const SharedHandle& sh) : o(sh.o) {
          .               subscribe();
          .             }
          .             forceinline SharedHandle&
          .             SharedHandle::operator =(const SharedHandle& sh) {
 32,064,640 ( 0.04%)      if (&sh != this) {
 32,064,640 ( 0.04%)        cancel(); o=sh.o; subscribe();
          .               }
          .               return *this;
          .             }
          .             forceinline
          .             SharedHandle::operator bool(void) const {
          .               return o != nullptr;
          .             }
          .             forceinline
-- line 142 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/gpi.hpp
--------------------------------------------------------------------------------
Ir                  

-- line 98 ----------------------------------------
         .               bool unshare(void);
         .               /// Delete
         .               ~GPI(void);
         .             };
         .           
         .           
         .             forceinline void
         .             GPI::Info::init(unsigned int pid0, unsigned int gid0) {
        36 ( 0.00%)      pid=pid0; gid=gid0; afc=1.0;
         .             }
         .           
         .           
         .             forceinline
         .             GPI::Block::Block(void)
         2 ( 0.00%)      : next(nullptr), free(n_info) {}
         .           
         .             forceinline void
         .             GPI::Block::rescale(void) {
     9,048 ( 0.00%)      for (int i=free; i < n_info; i++)
     6,786 ( 0.00%)        info[i].afc *= Kernel::Config::rescale;
         .             }
         .           
         .           
         .             forceinline
         .             GPI::GPI(void)
         5 ( 0.00%)      : b(&fst), invd(1.0), npid(0U), us(false) {}
         .           
         .             forceinline void
         .             GPI::fail(Info& c) {
         .               m.acquire();
31,709,572 ( 0.04%)      c.afc = invd * (c.afc + 1.0);
15,854,786 ( 0.02%)      if (c.afc > Kernel::Config::rescale_limit)
     2,262 ( 0.00%)        for (Block* i = b; i != nullptr; i = i->next)
         .                   i->rescale();
         .               m.release();
         .             }
         .           
         .             forceinline double
         .             GPI::decay(void) const {
         .               double d;
         .               const_cast<GPI&>(*this).m.acquire();
-- line 138 ----------------------------------------
-- line 153 ----------------------------------------
         .               u = us; us = true;
         .               m.release();
         .               return u;
         .             }
         .           
         .             forceinline void
         .             GPI::decay(double d) {
         .               m.acquire();
         6 ( 0.00%)      invd = 1.0 / d;
         .               m.release();
         .             }
         .           
         .             forceinline GPI::Info*
         .             GPI::allocate(unsigned int p, unsigned int gid) {
         .               Info* c;
         .               m.acquire();
         .               if (b->free == 0) {
-- line 169 ----------------------------------------
-- line 175 ----------------------------------------
         .               c->init(p,gid);
         .               return c;
         .             }
         .           
         .             forceinline GPI::Info*
         .             GPI::allocate(unsigned int gid) {
         .               Info* c;
         .               m.acquire();
        16 ( 0.00%)      if (b->free == 0) {
         .                 Block* n = new Block;
         .                 n->next = b; b = n;
         .               }
        33 ( 0.00%)      c = &b->info[--b->free];
         .               m.release();
         .               c->init(npid.fetch_add(1, std::memory_order_seq_cst),gid);
         2 ( 0.00%)      return c;
         .             }
         .           
         .             forceinline
         .             GPI::~GPI(void) {
         .               Block* n = b;
         .               while (n != &fst) {
         .                 Block* d = n;
         .                 n = n->next;
-- line 198 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/config.hpp
--------------------------------------------------------------------------------
Ir                  

-- line 144 ----------------------------------------
         .               void align(size_t& s, size_t a = GECODE_MEMORY_ALIGNMENT);
         .           
         .               /*
         .                * Alignment
         .                *
         .                */
         .               forceinline void
         .               align(size_t& s, size_t a) {
85,033,244 ( 0.10%)        s += ((a - (s & (a - 1))) & (a - 1));
         .               }
         .           
         .             }
         .           
         .           }}
         .           
         .           // STATISTICS: kernel-memory

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/std_mutex.h
--------------------------------------------------------------------------------
Ir                   

-- line 57 ----------------------------------------
          .             class __mutex_base
          .             {
          .             protected:
          .               typedef __gthread_mutex_t			__native_type;
          .           
          .           #ifdef __GTHREAD_MUTEX_INIT
          .               __native_type  _M_mutex = __GTHREAD_MUTEX_INIT;
          .           
         69 ( 0.00%)      constexpr __mutex_base() noexcept = default;
          .           #else
          .               __native_type  _M_mutex;
          .           
          .               __mutex_base() noexcept
          .               {
          .                 // XXX EAGAIN, ENOMEM, EPERM, EBUSY(may), EINVAL(may)
          .                 __GTHREAD_MUTEX_INIT_FUNCTION(&_M_mutex);
          .               }
-- line 73 ----------------------------------------
-- line 92 ----------------------------------------
          .               ~mutex() = default;
          .           
          .               mutex(const mutex&) = delete;
          .               mutex& operator=(const mutex&) = delete;
          .           
          .               void
          .               lock()
          .               {
 32,066,446 ( 0.04%)        int __e = __gthread_mutex_lock(&_M_mutex);
          .           
          .                 // EINVAL, EAGAIN, EBUSY, EINVAL, EDEADLK(may)
144,547,082 ( 0.16%)        if (__e)
          .           	__throw_system_error(__e);
          .               }
          .           
          .               bool
          .               try_lock() noexcept
          .               {
          .                 // XXX EINVAL, EAGAIN, EBUSY
          .                 return !__gthread_mutex_trylock(&_M_mutex);
          .               }
          .           
          .               void
          .               unlock()
          .               {
          .                 // XXX EINVAL, EAGAIN, EPERM
          2 ( 0.00%)        __gthread_mutex_unlock(&_M_mutex);
          .               }
          .           
          .               native_handle_type
          .               native_handle() noexcept
          .               { return &_M_mutex; }
          .             };
          .           
          .             // Implementation details for std::condition_variable
-- line 126 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/var-imp.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 254 ----------------------------------------
          .             }
          .             forceinline void
          .             IntVarImpBase::reschedule(Gecode::Space& home, Gecode::Propagator& p, Gecode::PropCond pc, bool assigned) {
          .               Gecode::VarImp<Gecode::Int::IntVarImpConf>::reschedule(home,p,pc,assigned,ME_INT_BND);
          .             }
          .           
          .             forceinline Gecode::ModEvent
          .             IntVarImpBase::notify(Gecode::Space& home, Gecode::ModEvent me, Gecode::Delta& d) {
 44,681,653 ( 0.05%)      switch (me) {
          .               case ME_INT_VAL:
          .                 // Conditions: VAL, BND, DOM
          .                 Gecode::VarImp<Gecode::Int::IntVarImpConf>::schedule(home,PC_INT_VAL,PC_INT_DOM,ME_INT_VAL);
          .                 if (!Gecode::VarImp<Gecode::Int::IntVarImpConf>::advise(home,ME_INT_VAL,d))
      9,972 ( 0.00%)          return ME_INT_FAILED;
          .                 cancel(home);
          .                 break;
          .               case ME_INT_BND:
          .                 // Conditions: BND, DOM
          .                 Gecode::VarImp<Gecode::Int::IntVarImpConf>::schedule(home,PC_INT_BND,PC_INT_DOM,ME_INT_BND);
          .                 if (!Gecode::VarImp<Gecode::Int::IntVarImpConf>::advise(home,ME_INT_BND,d))
          .                   return ME_INT_FAILED;
          .                 break;
-- line 275 ----------------------------------------
-- line 276 ----------------------------------------
          .               case ME_INT_DOM:
          .                 // Conditions: DOM
          .                 Gecode::VarImp<Gecode::Int::IntVarImpConf>::schedule(home,PC_INT_DOM,PC_INT_DOM,ME_INT_DOM);
          .                 if (!Gecode::VarImp<Gecode::Int::IntVarImpConf>::advise(home,ME_INT_DOM,d))
          .                   return ME_INT_FAILED;
          .                 break;
          .               default: GECODE_NEVER;
          .               }
154,340,274 ( 0.17%)      return me;
          .             }
          .           
          .           }}
          .           #endif
          .           #ifdef GECODE_HAS_INT_VARS
          .           namespace Gecode { namespace Int {
          .           
          .             forceinline
-- line 292 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_bvector.h
--------------------------------------------------------------------------------
Ir                  

-- line 79 ----------------------------------------
         .           
         .               _Bit_reference() _GLIBCXX_NOEXCEPT : _M_p(0), _M_mask(0) { }
         .           
         .           #if __cplusplus >= 201103L
         .               _Bit_reference(const _Bit_reference&) = default;
         .           #endif
         .           
         .               operator bool() const _GLIBCXX_NOEXCEPT
       348 ( 0.00%)      { return !!(*_M_p & _M_mask); }
         .           
         .               _Bit_reference&
         .               operator=(bool __x) _GLIBCXX_NOEXCEPT
         .               {
         .                 if (__x)
       924 ( 0.00%)  	*_M_p |= _M_mask;
         .                 else
        88 ( 0.00%)  	*_M_p &= ~_M_mask;
         .                 return *this;
         .               }
         .           
         .               _Bit_reference&
         .               operator=(const _Bit_reference& __x) _GLIBCXX_NOEXCEPT
         .               { return *this = bool(__x); }
         .           
         .               bool
-- line 103 ----------------------------------------
-- line 141 ----------------------------------------
         .           
         .             struct _Bit_iterator_base
         .             : public std::iterator<std::random_access_iterator_tag, bool>
         .             {
         .               _Bit_type * _M_p;
         .               unsigned int _M_offset;
         .           
         .               _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
96,193,884 ( 0.11%)      : _M_p(__x), _M_offset(__y) { }
         .           
         .               void
         .               _M_bump_up()
         .               {
       264 ( 0.00%)        if (_M_offset++ == int(_S_word_bit) - 1)
         .           	{
         .           	  _M_offset = 0;
         .           	  ++_M_p;
         .           	}
         .               }
         .           
         .               void
         .               _M_bump_down()
-- line 162 ----------------------------------------
-- line 167 ----------------------------------------
         .           	  --_M_p;
         .           	}
         .               }
         .           
         .               void
         .               _M_incr(ptrdiff_t __i)
         .               {
         .                 difference_type __n = __i + _M_offset;
     1,281 ( 0.00%)        _M_p += __n / int(_S_word_bit);
     1,105 ( 0.00%)        __n = __n % int(_S_word_bit);
       442 ( 0.00%)        if (__n < 0)
         .           	{
         .           	  __n += int(_S_word_bit);
         .           	  --_M_p;
         .           	}
         5 ( 0.00%)        _M_offset = static_cast<unsigned int>(__n);
         .               }
         .           
         .               friend _GLIBCXX20_CONSTEXPR bool
         .               operator==(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
         .               { return __x._M_p == __y._M_p && __x._M_offset == __y._M_offset; }
         .           
         .           #if __cpp_lib_three_way_comparison
         .               friend constexpr strong_ordering
-- line 190 ----------------------------------------
-- line 218 ----------------------------------------
         .               friend bool
         .               operator>=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
         .               { return !(__x < __y); }
         .           #endif // three-way comparison
         .           
         .               friend ptrdiff_t
         .               operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
         .               {
        24 ( 0.00%)        return (int(_S_word_bit) * (__x._M_p - __y._M_p)
        20 ( 0.00%)  	      + __x._M_offset - __y._M_offset);
         .               }
         .             };
         .           
         .             struct _Bit_iterator : public _Bit_iterator_base
         .             {
         .               typedef _Bit_reference  reference;
         .           #if __cplusplus > 201703L
         .               typedef void	    pointer;
-- line 235 ----------------------------------------
-- line 244 ----------------------------------------
         .               : _Bit_iterator_base(__x, __y) { }
         .           
         .               iterator
         .               _M_const_cast() const
         .               { return *this; }
         .           
         .               reference
         .               operator*() const
       660 ( 0.00%)      { return reference(_M_p, 1UL << _M_offset); }
         .           
         .               iterator&
         .               operator++()
         .               {
         .                 _M_bump_up();
         .                 return *this;
         .               }
         .           
-- line 260 ----------------------------------------
-- line 332 ----------------------------------------
         .               typedef _Bit_const_iterator  const_iterator;
         .           
         .               _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }
         .           
         .               _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
         .               : _Bit_iterator_base(__x, __y) { }
         .           
         .               _Bit_const_iterator(const _Bit_iterator& __x)
         8 ( 0.00%)      : _Bit_iterator_base(__x._M_p, __x._M_offset) { }
         .           
         .               _Bit_iterator
         .               _M_const_cast() const
         .               { return _Bit_iterator(_M_p, _M_offset); }
         .           
         .               const_reference
         .               operator*() const
       180 ( 0.00%)      { return _Bit_reference(_M_p, 1UL << _M_offset); }
         .           
         .               const_iterator&
         .               operator++()
         .               {
         .                 _M_bump_up();
         .                 return *this;
         .               }
         .           
-- line 356 ----------------------------------------
-- line 435 ----------------------------------------
         .           	  _Bit_type* _M_p;
         .           	  // Allow assignment from iterators (assume offset is zero):
         .           	  void operator=(_Bit_iterator __it) { _M_p = __it._M_p; }
         .           	} _M_start;
         .           #endif
         .           	_Bit_iterator	_M_finish;
         .           	_Bit_pointer	_M_end_of_storage;
         .           
        24 ( 0.00%)  	_Bvector_impl_data() _GLIBCXX_NOEXCEPT
32,064,632 ( 0.04%)  	: _M_start(), _M_finish(), _M_end_of_storage()
         .           	{ }
         .           
         .           #if __cplusplus >= 201103L
         .           	_Bvector_impl_data(const _Bvector_impl_data&) = default;
         .           	_Bvector_impl_data&
         .           	operator=(const _Bvector_impl_data&) = default;
         .           
         .           	_Bvector_impl_data(_Bvector_impl_data&& __x) noexcept
         .           	: _Bvector_impl_data(__x)
         .           	{ __x._M_reset(); }
         .           
         .           	void
         .           	_M_move_data(_Bvector_impl_data&& __x) noexcept
         .           	{
        24 ( 0.00%)  	  *this = __x;
         .           	  __x._M_reset();
         .           	}
         .           #endif
         .           
         .           	void
         .           	_M_reset() _GLIBCXX_NOEXCEPT
        10 ( 0.00%)  	{ *this = _Bvector_impl_data(); }
         .           
         .           	void
         .           	_M_swap_data(_Bvector_impl_data& __x) _GLIBCXX_NOEXCEPT
         .           	{
         .           	  // Do not use std::swap(_M_start, __x._M_start), etc as it loses
         .           	  // information used by TBAA.
         .           	  std::swap(*this, __x);
         .           	}
-- line 474 ----------------------------------------
-- line 496 ----------------------------------------
         .           	_Bvector_impl(_Bit_alloc_type&& __a, _Bvector_impl&& __x) noexcept
         .           	: _Bit_alloc_type(std::move(__a)), _Bvector_impl_data(std::move(__x))
         .           	{ }
         .           #endif
         .           
         .           	_Bit_type*
         .           	_M_end_addr() const _GLIBCXX_NOEXCEPT
         .           	{
         6 ( 0.00%)  	  if (this->_M_end_of_storage)
         .           	    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
         .           	  return 0;
         .           	}
         .                 };
         .           
         .               public:
         .                 typedef _Alloc allocator_type;
         .           
-- line 512 ----------------------------------------
-- line 535 ----------------------------------------
         .                 _Bvector_base(_Bvector_base&&) = default;
         .           
         .                 _Bvector_base(_Bvector_base&& __x, const allocator_type& __a) noexcept
         .                 : _M_impl(_Bit_alloc_type(__a), std::move(__x._M_impl))
         .                 { }
         .           #endif
         .           
         .                 ~_Bvector_base()
        16 ( 0.00%)        { this->_M_deallocate(); }
     1,192 ( 0.00%)  => ???:0x0000000004866920 (8x)
         .           
         .               protected:
         .                 _Bvector_impl _M_impl;
         .           
         .                 _Bit_pointer
         .                 _M_allocate(size_t __n)
         .                 { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }
         .           
         .                 void
        24 ( 0.00%)        _M_deallocate()
         .                 {
96,193,792 ( 0.11%)  	if (_M_impl._M_start._M_p)
         .           	  {
         6 ( 0.00%)  	    const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;
         .           	    _Bit_alloc_traits::deallocate(_M_impl,
         .           					  _M_impl._M_end_of_storage - __n,
         .           					  __n);
         .           	    _M_impl._M_reset();
         .           	  }
        16 ( 0.00%)        }
         .           
         .           #if __cplusplus >= 201103L
         .                 void
         .                 _M_move_data(_Bvector_base&& __x) noexcept
         .                 { _M_impl._M_move_data(std::move(__x._M_impl)); }
         .           #endif
         .           
         .                 static size_t
         .                 _S_nword(size_t __n)
        14 ( 0.00%)        { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
         .               };
         .           
         .             /**
         .              *  @brief  A specialization of vector for booleans which offers fixed time
         .              *  access to individual elements in any order.
         .              *
         .              *  @ingroup sequences
         .              *
-- line 581 ----------------------------------------
-- line 730 ----------------------------------------
         .           	}
         .           #endif
         .           
         .                 ~vector() _GLIBCXX_NOEXCEPT { }
         .           
         .                 vector&
         .                 operator=(const vector& __x)
         .                 {
        12 ( 0.00%)  	if (&__x == this)
         .           	  return *this;
         .           #if __cplusplus >= 201103L
         .           	if (_Bit_alloc_traits::_S_propagate_on_copy_assign())
         .           	  {
         .           	    if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator())
         .           	      {
         .           		this->_M_deallocate();
         .           		std::__alloc_on_copy(_M_get_Bit_allocator(),
-- line 746 ----------------------------------------
-- line 747 ----------------------------------------
         .           				     __x._M_get_Bit_allocator());
         .           		_M_initialize(__x.size());
         .           	      }
         .           	    else
         .           	      std::__alloc_on_copy(_M_get_Bit_allocator(),
         .           				   __x._M_get_Bit_allocator());
         .           	  }
         .           #endif
        12 ( 0.00%)  	if (__x.size() > capacity())
         .           	  {
         .           	    this->_M_deallocate();
         .           	    _M_initialize(__x.size());
         .           	  }
        18 ( 0.00%)  	this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
         .           						  begin());
         .           	return *this;
         .                 }
         .           
         .           #if __cplusplus >= 201103L
         .                 vector&
         .                 operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())
         .                 {
-- line 768 ----------------------------------------
-- line 824 ----------------------------------------
         .           #if __cplusplus >= 201103L
         .                 void
         .                 assign(initializer_list<bool> __l)
         .                 { _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag()); }
         .           #endif
         .           
         .                 iterator
         .                 begin() _GLIBCXX_NOEXCEPT
       134 ( 0.00%)        { return iterator(this->_M_impl._M_start._M_p, 0); }
         .           
         .                 const_iterator
         .                 begin() const _GLIBCXX_NOEXCEPT
        14 ( 0.00%)        { return const_iterator(this->_M_impl._M_start._M_p, 0); }
         .           
         .                 iterator
         .                 end() _GLIBCXX_NOEXCEPT
         .                 { return this->_M_impl._M_finish; }
         .           
         .                 const_iterator
         .                 end() const _GLIBCXX_NOEXCEPT
         .                 { return this->_M_impl._M_finish; }
-- line 844 ----------------------------------------
-- line 899 ----------------------------------------
         .           			 - begin()); }
         .           
         .                 _GLIBCXX_NODISCARD bool
         .                 empty() const _GLIBCXX_NOEXCEPT
         .                 { return begin() == end(); }
         .           
         .                 reference
         .                 operator[](size_type __n)
       128 ( 0.00%)        { return begin()[__n]; }
         .           
         .                 const_reference
         .                 operator[](size_type __n) const
         .                 { return begin()[__n]; }
         .           
         .               protected:
         .                 void
         .                 _M_range_check(size_type __n) const
-- line 915 ----------------------------------------
-- line 1129 ----------------------------------------
         .           		      iterator __result)
         .                 {
         .           	_Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
         .           	return std::copy(const_iterator(__last._M_p, 0), __last,
         .           			 iterator(__q, 0));
         .                 }
         .           
         .                 void
         2 ( 0.00%)        _M_initialize(size_type __n)
         .                 {
        26 ( 0.00%)  	if (__n)
         .           	  {
         .           	    _Bit_pointer __q = this->_M_allocate(__n);
        11 ( 0.00%)  	    this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
         .           	    iterator __start = iterator(std::__addressof(*__q), 0);
         7 ( 0.00%)  	    this->_M_impl._M_start = __start;
         5 ( 0.00%)  	    this->_M_impl._M_finish = __start + difference_type(__n);
         .           	  }
         2 ( 0.00%)        }
         .           
         .                 void
         .                 _M_initialize_value(bool __x)
         .                 {
         .           	if (_Bit_type* __p = this->_M_impl._M_start._M_p)
        11 ( 0.00%)  	  __builtin_memset(__p, __x ? ~0 : 0,
        17 ( 0.00%)  => ???:0x0000000004866660 (1x)
         .           			   (this->_M_impl._M_end_addr() - __p)
         .           			   * sizeof(_Bit_type));
         .                 }
         .           
         .                 void
         .                 _M_reallocate(size_type __n);
         .           
         .           #if __cplusplus >= 201103L
-- line 1161 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/flatzinc.hh
--------------------------------------------------------------------------------
Ir                  

-- line 146 ----------------------------------------
         .           #endif
         .           #ifdef GECODE_HAS_FLOAT_VARS
         .                                  ,
         .                                  const Gecode::FloatVarArray& fv1,
         .                                  const Gecode::FloatVarArray& fv2
         .           #endif
         .                                  ) const;
         .             public:
         1 ( 0.00%)      Printer(void) : _output(nullptr) {}
         .               void init(AST::Array* output);
         .           
         .               void print(std::ostream& out,
         .                          const Gecode::IntVarArray& iv,
         .                          const Gecode::BoolVarArray& bv
         .           #ifdef GECODE_HAS_SET_VARS
         .                          ,
         .                          const Gecode::SetVarArray& sv
-- line 162 ----------------------------------------
-- line 180 ----------------------------------------
         .                          const Gecode::FloatVarArray& fv2
         .           #endif
         .                          ) const;
         .           
         .           
         .               ~Printer(void);
         .           
         .               void addIntVarName(const std::string& n);
         2 ( 0.00%)      const std::string& intVarName(int i) const { return iv_names[i]; }
         .               void addBoolVarName(const std::string& n);
         .               const std::string& boolVarName(int i) const { return bv_names[i]; }
         .           #ifdef GECODE_HAS_FLOAT_VARS
         .               void addFloatVarName(const std::string& n);
         .               const std::string& floatVarName(int i) const { return fv_names[i]; }
         .           #endif
         .           #ifdef GECODE_HAS_SET_VARS
         .               void addSetVarName(const std::string& n);
-- line 196 ----------------------------------------
-- line 219 ----------------------------------------
         .               Printer(const Printer&);
         .               Printer& operator=(const Printer&);
         .             };
         .           
         .             /**
         .              * \brief %Options for running %FlatZinc models
         .              *
         .              */
        26 ( 0.00%)    class FlatZincOptions : public Gecode::BaseOptions {
     3,896 ( 0.00%)  => ???:0x000000000010b3c0 (2x)
     1,269 ( 0.00%)  => ???:0x000000000010b450 (1x)
       138 ( 0.00%)  => ???:0x000000000010b5e0 (1x)
         .             protected:
         .                 /// \name Search options
         .                 //@{
         .                 Gecode::Driver::IntOption         _solutions; ///< How many solutions
         .                 Gecode::Driver::BoolOption        _allSolutions; ///< Return all solutions
         .                 Gecode::Driver::DoubleOption      _threads;   ///< How many threads to use
         .                 Gecode::Driver::BoolOption        _free; ///< Use free search
         .                 Gecode::Driver::DoubleOption      _decay;       ///< Decay option
-- line 235 ----------------------------------------
-- line 261 ----------------------------------------
         .           
         .           #ifdef GECODE_HAS_CPPROFILER
         .                 Gecode::Driver::ProfilerOption    _profiler; ///< Use this execution id for the CP-profiler
         .           #endif
         .           
         .                 //@}
         .             public:
         .               /// Constructor
         9 ( 0.00%)      FlatZincOptions(const char* s)
         .               : Gecode::BaseOptions(s),
         .                 _solutions("n","number of solutions (0 = all, -1 = one/best)",-1),
         .                 _allSolutions("a", "return all solutions (equal to -n 0)"),
         .                 _threads("p","number of threads (0 = #processing units)",
         .                          Gecode::Search::Config::threads),
         .                 _free("f", "free search, no need to follow search-specification"),
         .                 _decay("decay","decay factor",0.99),
         .                 _c_d("c-d","recomputation commit distance",Gecode::Search::Config::c_d),
         .                 _a_d("a-d","recomputation adaption distance",Gecode::Search::Config::a_d),
         .                 _node("node","node cutoff (0 = none, solution mode)"),
         .                 _fail("fail","failure cutoff (0 = none, solution mode)"),
         .                 _time("time","time (in ms) cutoff (0 = none, solution mode)"),
         .                 _time_limit("t","time (in ms) cutoff (0 = none, solution mode)"),
         .                 _seed("r","random seed",0),
         1 ( 0.00%)        _restart("restart","restart sequence type",RM_NONE),
         .                 _r_base("restart-base","base for geometric restart sequence",1.5),
         .                 _r_scale("restart-scale","scale factor for restart sequence",250),
         .                 _r_limit("restart-limit","restart cutoff (0 = none, solution mode)"),
         .                 _nogoods("nogoods","whether to use no-goods from restarts",false),
         .                 _nogoods_limit("nogoods-limit","depth limit for no-good extraction",
         .                                Search::Config::nogoods_limit),
         .                 _interrupt("interrupt","whether to catch Ctrl-C (true) or not (false)",
         .                            true),
         .                 _step("step","step distance for float optimization",0.0),
         .                 _use_pbs("use-pbs", "whether to use portfolio-based-search or not", false), // ADDED
         .                 _full_s("full-s", "whether to print statistics of all assets", false), // ADDED
         .                 _assets("assets","the number of assets to use with portfolio-based search", 8), // ADDED
         .           
         1 ( 0.00%)        _mode("mode","how to execute script",Gecode::SM_SOLUTION),
         .                 _stat("s","emit statistics"),
         9 ( 0.00%)        _output("o","file to send output to")
     4,095 ( 0.00%)  => ???:0x000000000010b4f0 (1x)
     1,682 ( 0.00%)  => ???:0x000000000010b540 (1x)
         .           
         .           #ifdef GECODE_HAS_CPPROFILER
         .                 ,
         .                 _profiler("cp-profiler", "use this execution id and port (comma separated) with CP-profiler")
         .           #endif
         .               {
         5 ( 0.00%)        _mode.add(Gecode::SM_SOLUTION, "solution");
     1,352 ( 0.00%)  => ???:0x000000000010b480 (1x)
         5 ( 0.00%)        _mode.add(Gecode::SM_STAT, "stat");
       483 ( 0.00%)  => ???:0x000000000010b480 (1x)
         5 ( 0.00%)        _mode.add(Gecode::SM_GIST, "gist");
       483 ( 0.00%)  => ???:0x000000000010b480 (1x)
         5 ( 0.00%)        _restart.add(RM_NONE,"none");
       482 ( 0.00%)  => ???:0x000000000010b480 (1x)
         5 ( 0.00%)        _restart.add(RM_CONSTANT,"constant");
       487 ( 0.00%)  => ???:0x000000000010b480 (1x)
         5 ( 0.00%)        _restart.add(RM_LINEAR,"linear");
       483 ( 0.00%)  => ???:0x000000000010b480 (1x)
         5 ( 0.00%)        _restart.add(RM_LUBY,"luby");
       483 ( 0.00%)  => ???:0x000000000010b480 (1x)
         5 ( 0.00%)        _restart.add(RM_GEOMETRIC,"geometric");
       487 ( 0.00%)  => ???:0x000000000010b480 (1x)
         .           
        12 ( 0.00%)        add(_solutions); add(_threads); add(_c_d); add(_a_d);
        39 ( 0.00%)  => ???:0x000000000010b5f0 (4x)
         3 ( 0.00%)        add(_allSolutions);
        10 ( 0.00%)  => ???:0x000000000010b5f0 (1x)
         3 ( 0.00%)        add(_free);
        10 ( 0.00%)  => ???:0x000000000010b5f0 (1x)
         3 ( 0.00%)        add(_decay);
        10 ( 0.00%)  => ???:0x000000000010b5f0 (1x)
        15 ( 0.00%)        add(_node); add(_fail); add(_time); add(_time_limit); add(_interrupt);
        50 ( 0.00%)  => ???:0x000000000010b5f0 (5x)
         3 ( 0.00%)        add(_seed);
        10 ( 0.00%)  => ???:0x000000000010b5f0 (1x)
         3 ( 0.00%)        add(_step);
        10 ( 0.00%)  => ???:0x000000000010b5f0 (1x)
        12 ( 0.00%)        add(_restart); add(_r_base); add(_r_scale); add(_r_limit);
        40 ( 0.00%)  => ???:0x000000000010b5f0 (4x)
         6 ( 0.00%)        add(_nogoods); add(_nogoods_limit);
        20 ( 0.00%)  => ???:0x000000000010b5f0 (2x)
        15 ( 0.00%)        add(_mode); add(_stat); add(_use_pbs); add(_full_s); add(_assets);
        50 ( 0.00%)  => ???:0x000000000010b5f0 (5x)
         3 ( 0.00%)        add(_output); 
        10 ( 0.00%)  => ???:0x000000000010b5f0 (1x)
         .           #ifdef GECODE_HAS_CPPROFILER
         .                 add(_profiler);
         .           #endif
         8 ( 0.00%)      }
         .           
         .               void parse(int& argc, char* argv[]) {
         4 ( 0.00%)        Gecode::BaseOptions::parse(argc,argv);
     4,619 ( 0.00%)  => ???:0x000000000010b590 (1x)
         2 ( 0.00%)        if (_allSolutions.value() && _solutions.value()==-1) {
         .                   _solutions.value(0);
         .                 }
         2 ( 0.00%)        if (_time_limit.value()) {
         .                   _time.value(_time_limit.value());
         .                 }
         2 ( 0.00%)        if (_stat.value())
         .                   _mode.value(Gecode::SM_STAT);
         .               }
         .           
         .               virtual void help(void) {
         .                 std::cerr << "Gecode FlatZinc interpreter" << std::endl
         .                           << " - Supported FlatZinc version: " << GECODE_FLATZINC_VERSION
         .                           << std::endl << std::endl;
         .                 Gecode::BaseOptions::help();
-- line 348 ----------------------------------------
-- line 368 ----------------------------------------
         .               }
         .           
         .               double decay(void) const { return _decay.value(); }
         .               RestartMode restart(void) const {
         .                 return static_cast<RestartMode>(_restart.value());
         .               }
         .               void restart(RestartMode rm) {
         .                 _restart.value(rm);
         2 ( 0.00%)      }
         .               double restart_base(void) const { return _r_base.value(); }
         .               void restart_base(double d) { _r_base.value(d); }
         .               unsigned int restart_scale(void) const { return _r_scale.value(); }
         .               void restart_scale(int i) { _r_scale.value(i); }
         .               unsigned long long int restart_limit(void) const { return _r_limit.value(); }
         .               bool nogoods(void) const { return _nogoods.value(); }
         .               unsigned int nogoods_limit(void) const { return _nogoods_limit.value(); }
         .               bool interrupt(void) const { return _interrupt.value(); }
-- line 384 ----------------------------------------
-- line 412 ----------------------------------------
         .                          unsigned int a, int i, int n, std::ostream& o) const;
         .           #ifdef GECODE_HAS_FLOAT_VARS
         .               /// Output branch information
         .               void print(const Brancher& b,
         .                          unsigned int a, int i, const FloatNumBranch& nl,
         .                          std::ostream& o) const;
         .           #endif
         .               /// Assignment operator
 8,016,154 ( 0.01%)      BranchInformation& operator =(const BranchInformation&) = default;
         .             };
         .           
         .             /// Uninitialized default random number generator
         .             GECODE_FLATZINC_EXPORT
         .             extern Rnd defrnd;
         .           
         .             class FlatZincSpaceInitData;
         .             /**
-- line 428 ----------------------------------------
-- line 441 ----------------------------------------
         .                 PG, //< Propagation Guided LNS
         .                 rPG, //< Reversed Propagation Guided LNS
         .                 AFCLNS //< AFC guided LNS
         .               };
         .           
         .               int getintVarCount() const { return intVarCount; }
         .               int getboolVarCount() const { return boolVarCount; }
         .               int getsetVarCount() const { return setVarCount; }
         1 ( 0.00%)      void setLNSType(LNSType lns_type) { _lnsType = lns_type; }
         .             protected:
         .               /// Initialisation data (only used for posting constraints)
         .               FlatZincSpaceInitData* _initData;
         .               /// Number of integer variables
         .               int intVarCount;
         .               /// Number of Boolean variables
         .               int boolVarCount;
         .               /// Number of float variables
-- line 457 ----------------------------------------
-- line 544 ----------------------------------------
         .                   int on_restart_iv_sol = 0;
         .                   int on_restart_bv_sol = 0;
         .                   int on_restart_sv_sol = 0;
         .                   int on_restart_fv_sol = 0;
         .                   /// Whether the last on_restart_iv should be set to the restart status
         .                   bool on_restart_status = false;
         .                 };
         .               public:
         3 ( 0.00%)        OnRestartHandle() : SharedHandle() {}
24,048,462 ( 0.03%)        OnRestartHandle(const OnRestartHandle& handle): SharedHandle(handle) {}
         .                 OnRestartHandle& operator =(const OnRestartHandle& handle) {
         .                   return static_cast<OnRestartHandle&>(SharedHandle::operator =(handle));
         .                 }
24,048,438 ( 0.03%)        virtual ~OnRestartHandle() {};
         .           
         .                 void init() {
         .                   if (object() == nullptr) {
         .                     object(new OnRestartData());
         .                   }
         .                 }
         .                 bool initialized() const { return object() != nullptr; }
         .                 OnRestartData& operator ()() {
-- line 565 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/int/count/int-eq.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 31 ----------------------------------------
          .            *
          .            */
          .           
          .           namespace Gecode { namespace Int { namespace Count {
          .           
          .             template<class VX, class VY>
          .             forceinline
          .             EqInt<VX,VY>::EqInt(Home home, ViewArray<VX>& x, int n_s, VY y, int c)
          2 ( 0.00%)      : IntBase<VX,VY>(home,x,n_s,y,c) {}
          .           
          .             template<class VX, class VY>
          .             ExecStatus
         11 ( 0.00%)    EqInt<VX,VY>::post(Home home, ViewArray<VX>& x, VY y, int c) {
          .               // Eliminate decided views
          .               int n_x = x.size();
         31 ( 0.00%)      for (int i=n_x; i--; )
          .                 switch (holds(x[i],y)) {
          .                 case RT_FALSE:
          .                   x[i] = x[--n_x]; break;
          .                 case RT_TRUE:
          .                   x[i] = x[--n_x]; c--; break;
          .                 case RT_MAYBE:
          .                   break;
          .                 default:
          .                   GECODE_NEVER;
          .                 }
          .               x.size(n_x);
          .               // RHS too small or too large
          4 ( 0.00%)      if ((c < 0) || (c > n_x))
          .                 return ES_FAILED;
          .               // All views must be different
          1 ( 0.00%)      if (c == 0)
          .                 return post_false(home,x,y);
          .               // All views must be equal
          2 ( 0.00%)      if (c == n_x)
          .                 return post_true(home,x,y);
          .               // Compute how many subscriptions must be created
          7 ( 0.00%)      int n_s = std::max(c,n_x-c)+1;
          .               assert(n_s <= n_x);
          .               (void) new (home) EqInt<VX,VY>(home,x,n_s,y,c);
          1 ( 0.00%)      return ES_OK;
          8 ( 0.00%)    }
          .           
          .             template<class VX, class VY>
          .             forceinline
          .             EqInt<VX,VY>::EqInt(Space& home, EqInt<VX,VY>& p)
 10,852,982 ( 0.01%)      : IntBase<VX,VY>(home,p) {}
          .           
          .             template<class VX, class VY>
          .             Actor*
 32,558,946 ( 0.04%)    EqInt<VX,VY>::copy(Space& home) {
          .               return new (home) EqInt<VX,VY>(home,*this);
 27,132,455 ( 0.03%)    }
          .           
          .             template<class VX, class VY>
          .             ExecStatus
116,584,520 ( 0.13%)    EqInt<VX,VY>::propagate(Space& home, const ModEventDelta&) {
          .               // Eliminate decided views from subscribed views
          .               int n_x = x.size();
323,186,815 ( 0.36%)      for (int i=n_s; i--; )
          .                 switch (holds(x[i],y)) {
          .                 case RT_FALSE:
          .                   x[i].cancel(home,*this,PC_INT_DOM);
 96,406,192 ( 0.11%)          x[i]=x[--n_s]; x[n_s]=x[--n_x];
          .                   break;
          .                 case RT_TRUE:
          .                   x[i].cancel(home,*this,PC_INT_DOM);
  9,240,426 ( 0.01%)          x[i]=x[--n_s]; x[n_s]=x[--n_x]; c--;
  1,026,714 ( 0.00%)          break;
          .                 case RT_MAYBE:
          .                   break;
          .                 default:
          .                   GECODE_NEVER;
          .                 }
          .               x.size(n_x);
 72,865,325 ( 0.08%)      if ((c < 0) || (c > n_x))
  1,510,819 ( 0.00%)        return ES_FAILED;
          .               // Eliminate decided views from unsubscribed views
 64,118,307 ( 0.07%)      for (int i=n_x; i-- > n_s; )
          .                 switch (holds(x[i],y)) {
  4,816,395 ( 0.01%)        case RT_FALSE: x[i]=x[--n_x]; break;
    412,150 ( 0.00%)        case RT_TRUE:  x[i]=x[--n_x]; c--; break;
          .                 case RT_MAYBE: break;
          .                 default:       GECODE_NEVER;
          .                 }
          .               x.size(n_x);
  4,254,260 ( 0.00%)      if ((c < 0) || (c > n_x))
          .                 return ES_FAILED;
 26,124,492 ( 0.03%)      if (c == 0) {
          .                 // All views must be different
          .                 GECODE_ES_CHECK(post_false(home,x,y));
          .                 return home.ES_SUBSUMED(*this);
          .               }
 29,921,585 ( 0.03%)      if (c == n_x) {
          .                 // All views must be equal
          .                 GECODE_ES_CHECK(post_true(home,x,y));
  3,822,986 ( 0.00%)        return home.ES_SUBSUMED(*this);
          .               }
 36,957,040 ( 0.04%)      int m = std::max(c,n_x-c)+1;
          .               assert(m <= n_x);
          .               // Now, there must be new subscriptions from x[n_s] up to x[m-1]
 18,478,676 ( 0.02%)      while (n_s < m)
         78 ( 0.00%)        x[n_s++].subscribe(home,*this,PC_INT_DOM,false);
  9,239,260 ( 0.01%)      return ES_FIX;
 87,438,390 ( 0.10%)    }
          .           
          .           }}}
          .           
          .           // STATISTICS: int-prop

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/val-sel-commit.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 151 ----------------------------------------
          .           
          .           
          .           
          .           
          .             template<class ValSel, class ValCommit>
          .             forceinline
          .             ValSelCommit<ValSel,ValCommit>::ValSelCommit(Space& home,
          .                                                          const ValBranch<Var>& vb)
          8 ( 0.00%)      : ValSelCommitBase<View,Val>(home,vb), s(home,vb), c(home,vb) {}
          .           
          .             template<class ValSel, class ValCommit>
          .             forceinline
          .             ValSelCommit<ValSel,ValCommit>::ValSelCommit(Space& home,
          .                                                          ValSelCommit<ValSel,ValCommit>& vsc)
          .               : ValSelCommitBase<View,Val>(home,vsc),
 32,064,600 ( 0.04%)        s(home,vsc.s), c(home,vsc.c) {}
          .           
          .             template<class ValSel, class ValCommit>
          .             typename ValSelCommit<ValSel,ValCommit>::Val
  8,043,681 ( 0.01%)    ValSelCommit<ValSel,ValCommit>::val(const Space& home, View x, int i) {
  8,043,681 ( 0.01%)      return s.val(home,x,i);
  8,043,681 ( 0.01%)    }
          .           
          .             template<class ValSel, class ValCommit>
          .             ModEvent
137,724,405 ( 0.15%)    ValSelCommit<ValSel,ValCommit>::commit(Space& home, unsigned int a,
          .                                                    View x, int i, Val n) {
          .               return c.commit(home,a,x,i,n);
 82,634,643 ( 0.09%)    }
          .           
          .             template<class ValSel, class ValCommit>
          .             NGL*
          .             ValSelCommit<ValSel,ValCommit>::ngl(Space& home, unsigned int a,
          .                                                 View x, Val n) const {
          .               return c.ngl(home, a, x, n);
          .             }
          .           
-- line 187 ----------------------------------------
-- line 190 ----------------------------------------
          .             ValSelCommit<ValSel,ValCommit>::print(const Space& home, unsigned int a,
          .                                                   View x, int i, const Val& n,
          .                                                   std::ostream& o) const {
          .               c.print(home,a,x,i,n,o);
          .             }
          .           
          .             template<class ValSel, class ValCommit>
          .             ValSelCommit<ValSel,ValCommit>*
 48,096,900 ( 0.05%)    ValSelCommit<ValSel,ValCommit>::copy(Space& home) {
          .               return new (home) ValSelCommit<ValSel,ValCommit>(home,*this);
 32,064,600 ( 0.04%)    }
          .           
          .             template<class ValSel, class ValCommit>
          .             bool
 16,032,294 ( 0.02%)    ValSelCommit<ValSel,ValCommit>::notice(void) const {
          .               return s.notice() || c.notice();
 32,064,588 ( 0.04%)    }
          .           
          .             template<class ValSel, class ValCommit>
          .             void
 16,032,290 ( 0.02%)    ValSelCommit<ValSel,ValCommit>::dispose(Space& home) {
          .               s.dispose(home);
          .               c.dispose(home);
 16,032,290 ( 0.02%)    }
          .           
          .           }
          .           
          .           // STATISTICS: kernel-branch

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/gecode/search/seq/rbs.cpp
--------------------------------------------------------------------------------
Ir                   

-- line 32 ----------------------------------------
          .            */
          .           
          .           
          .           #include <gecode/search/seq/rbs.hh>
          .           
          .           namespace Gecode { namespace Search { namespace Seq {
          .           
          .             bool
 83,345,304 ( 0.09%)    RestartStop::stop(const Statistics& s, const Options& o) {
          .               // Stop if the fail limit for the engine says so
 31,254,489 ( 0.03%)      if (s.fail > l) {
     20,482 ( 0.00%)        e_stopped = true;
     20,482 ( 0.00%)        m_stat.restart++;
     40,964 ( 0.00%)        return true;
          .               }
          .               // Stop if the stop object for the meta engine says so
124,772,172 ( 0.14%)      if ((m_stop != nullptr) && m_stop->stop(m_stat+s,o)) {
374,316,503 ( 0.42%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/driver/script.hpp:Gecode::Driver::PBSCombinedStop::stop(Gecode::Search::Statistics const&, Gecode::Search::Options const&) (10,397,681x)
          1 ( 0.00%)        e_stopped = false;
          1 ( 0.00%)        return true;
          .               }
 10,397,680 ( 0.01%)      return false;
 62,508,978 ( 0.07%)    }
          .           
          .             Space*
         24 ( 0.00%)    RBS::next(void) {
          4 ( 0.00%)      if (restart) {
          1 ( 0.00%)        restart = false;
          1 ( 0.00%)        sslr++;
          5 ( 0.00%)        NoGoods& ng = e->nogoods();
          3 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/search/support.hh:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::DFS<Gecode::Search::NoTraceRecorder> >::nogoods() (1x)
          .                 // Reset number of no-goods found
          .                 ng.ng(0);
         12 ( 0.00%)        MetaInfo mi(stop->m_stat.restart,MetaInfo::RR_SOL,sslr,e->statistics().fail,last,ng);
          9 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/search/support.hh:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::DFS<Gecode::Search::NoTraceRecorder> >::statistics() const (1x)
          6 ( 0.00%)        bool r = master->master(mi);
      1,225 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/gecode/kernel/core.cpp:Gecode::Space::master(Gecode::MetaInfo const&) (1x)
          3 ( 0.00%)        stop->m_stat.nogood += ng.ng();
          6 ( 0.00%)        if (master->status(stop->m_stat) == SS_FAILED) {
      1,042 ( 0.00%)  => ???:0x0000000004df1910 (1x)
          1 ( 0.00%)          stop->update(e->statistics());
          .                   delete master;
          .                   master = nullptr;
          .                   e->reset(nullptr);
          .                   return nullptr;
          2 ( 0.00%)        } else if (r) {
          4 ( 0.00%)          stop->update(e->statistics());
          9 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/search/support.hh:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::DFS<Gecode::Search::NoTraceRecorder> >::statistics() const (1x)
          1 ( 0.00%)          Space* slave = master;
          1 ( 0.00%)          master = master->clone();
          5 ( 0.00%)          complete = slave->slave(mi);
        245 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/flatzinc.cpp:Gecode::FlatZinc::FlatZincSpace::slave(Gecode::MetaInfo const&) (1x)
          4 ( 0.00%)          e->reset(slave);
      2,590 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/search/support.hh:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::DFS<Gecode::Search::NoTraceRecorder> >::reset(Gecode::Space*) (1x)
          1 ( 0.00%)          sslr = 0;
          7 ( 0.00%)          stop->m_stat.restart++;
          .                 }
          .               }
          .               while (true) {
     61,452 ( 0.00%)        Space* n = e->next();
45,284,369,059 (50.65%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/search/support.hh:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::DFS<Gecode::Search::NoTraceRecorder> >::next() (20,484x)
     40,968 ( 0.00%)        if (n != nullptr) {
          .                   // The engine found a solution
          1 ( 0.00%)          restart = true;
          3 ( 0.00%)          delete last;
          1 ( 0.00%)          last = n->clone();
          1 ( 0.00%)          return n;
    286,755 ( 0.00%)        } else if ( (!complete && !e->stopped()) ||
     61,446 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/search/support.hh:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::DFS<Gecode::Search::NoTraceRecorder> >::stopped() const (20,482x)
    143,381 ( 0.00%)                    (e->stopped() && stop->enginestopped()) ) {
     61,449 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/search/support.hh:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::DFS<Gecode::Search::NoTraceRecorder> >::stopped() const (20,483x)
          .                   // The engine must perform a true restart
          .                   // The number of the restart has been incremented in the stop object
    225,294 ( 0.00%)          if (!complete && !e->stopped())
     61,443 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/search/support.hh:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::DFS<Gecode::Search::NoTraceRecorder> >::stopped() const (20,481x)
     20,481 ( 0.00%)            stop->m_stat.restart++;
     20,482 ( 0.00%)          sslr = 0;
     61,446 ( 0.00%)          NoGoods& ng = e->nogoods();
     61,446 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/search/support.hh:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::DFS<Gecode::Search::NoTraceRecorder> >::nogoods() (20,482x)
          .                   ng.ng(0);
    512,050 ( 0.00%)          MetaInfo mi(stop->m_stat.restart,e->stopped() ? MetaInfo::RR_LIM : MetaInfo::RR_CMPL,sslr,e->statistics().fail,last,ng);
    184,338 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/search/support.hh:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::DFS<Gecode::Search::NoTraceRecorder> >::statistics() const (20,482x)
     61,446 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/search/support.hh:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::DFS<Gecode::Search::NoTraceRecorder> >::stopped() const (20,482x)
    102,410 ( 0.00%)          (void) master->master(mi);
  4,321,702 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/gecode/kernel/core.cpp:Gecode::Space::master(Gecode::MetaInfo const&) (20,482x)
     61,446 ( 0.00%)          stop->m_stat.nogood += ng.ng();
     81,928 ( 0.00%)          unsigned long long int nl = ++(*co);
    204,822 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/gecode/search/cutoff.cpp:Gecode::Search::CutoffAppend::operator++() (20,482x)
    102,410 ( 0.00%)          stop->limit(e->statistics(),nl);
    184,338 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/search/support.hh:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::DFS<Gecode::Search::NoTraceRecorder> >::statistics() const (20,482x)
    122,892 ( 0.00%)          if (master->status(stop->m_stat) == SS_FAILED)
  1,126,510 ( 0.00%)  => ???:0x0000000004df1910 (20,482x)
          .                     return nullptr;
     20,482 ( 0.00%)          Space* slave = master;
     20,482 ( 0.00%)          master = master->clone();
    102,410 ( 0.00%)          complete = slave->slave(mi);
 44,293,538 ( 0.05%)  => /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/flatzinc.cpp:Gecode::FlatZinc::FlatZincSpace::slave(Gecode::MetaInfo const&) (20,482x)
    102,410 ( 0.00%)          e->reset(slave);
167,745,218 ( 0.19%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/search/support.hh:Gecode::Search::WorkerToEngine<Gecode::Search::Seq::DFS<Gecode::Search::NoTraceRecorder> >::reset(Gecode::Space*) (20,482x)
          .                 } else {
          .                   return nullptr;
          .                 }
          .               }
          .               GECODE_NEVER;
          .               return nullptr;
         24 ( 0.00%)    }
          .           
          .             Search::Statistics
          .             RBS::statistics(void) const {
          .               return stop->metastatistics()+e->statistics();
          .             }
          .           
          .             void
          .             RBS::constrain(const Space& b) {
-- line 124 ----------------------------------------
-- line 152 ----------------------------------------
          .             RBS::~RBS(void) {
          .               delete e;
          .               delete master;
          .               delete last;
          .               delete co;
          .               delete stop;
          .             }
          .           
          3 ( 0.00%)  }}}
          .           
          .           // STATISTICS: search-seq

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/search/seq/bab.hpp
--------------------------------------------------------------------------------
Ir                  

-- line 35 ----------------------------------------
         .            *
         .            */
         .           
         .           namespace Gecode { namespace Search { namespace Seq {
         .           
         .             template<class Tracer>
         .             forceinline
         .             BAB<Tracer>::BAB(Space* s, const Options& o)
        11 ( 0.00%)      : tracer(o.tracer), opt(o), path(opt.nogoods_limit), d(0), mark(0), 
         1 ( 0.00%)        best(nullptr) {
         .               if (tracer) {
         .                 tracer.engine(SearchTracer::EngineType::BAB, 1U);
         .                 tracer.worker();
         .               }
         7 ( 0.00%)      if ((s == nullptr) || (s->status(*this) == SS_FAILED)) {
     1,181 ( 0.00%)  => ???:0x0000000004df1910 (1x)
         .                 fail++;
         .                 cur = nullptr;
         .                 if (!o.clone)
         .                   delete s;
         .               } else {
         2 ( 0.00%)        cur = snapshot(s,opt);
         .               }
         .             }
         .           
         .             template<class Tracer>
         .             forceinline Space*
         .             BAB<Tracer>::next(void) {
         .               /*
         .                * The engine maintains the following invariant:
-- line 63 ----------------------------------------
-- line 72 ----------------------------------------
         .                * An additional invariant maintained by the engine is:
         .                *   For all nodes stored at a depth less than mark, there
         .                *   is no guarantee of betterness. For those above the mark,
         .                *   betterness is guaranteed.
         .                *
         .                */
         .               start();
         .               while (true) {
11,146,796 ( 0.01%)        if (stop(opt))
         1 ( 0.00%)          return nullptr;
         .                 // Recompute and add constraint if necessary
16,720,191 ( 0.02%)        while (cur == nullptr) {
 5,573,396 ( 0.01%)          if (path.empty())
         .                     return nullptr;
 8,360,092 ( 0.01%)          cur = path.recompute(d,opt.a_d,*this,*best,mark,tracer);
 2,654,564 ( 0.00%)          if (cur != nullptr)
         .                     break;
         .                   path.next();
         .                 }
 5,573,395 ( 0.01%)        node++;
         .                 SearchTracer::EdgeInfo ei;
         .                 if (tracer && (path.entries() > 0)) {
         .                   typename Path<Tracer>::Edge& top = path.top();
         .                   ei.init(tracer.wid(), top.nid(), top.truealt(), *cur, *top.choice());
         .                 }
         .                 unsigned int nid = tracer.nid();
44,587,155 ( 0.05%)        switch (cur->status(*this)) {
23,325,886,791 (26.09%)  => ???:0x0000000004df1910 (5,573,395x)
         .                 case SS_FAILED:
         .                   if (tracer) {
         .                     SearchTracer::NodeInfo ni(SearchTracer::NodeType::FAILED,
         .                                               tracer.wid(), nid, *cur);
         .                     tracer.node(ei,ni);
         .                   }
 2,786,696 ( 0.00%)          fail++;
13,933,480 ( 0.02%)          delete cur;
1,385,068,503 ( 1.55%)  => /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/flatzinc.cpp:Gecode::FlatZinc::FlatZincSpace::~FlatZincSpace() (2,786,696x)
 2,786,696 ( 0.00%)          cur = nullptr;
         .                   path.next();
         .                   break;
         .                 case SS_SOLVED:
         .                   {
         .                     if (tracer) {
         .                       SearchTracer::NodeInfo ni(SearchTracer::NodeType::SOLVED,
         .                                                 tracer.wid(), nid, *cur);
         .                       tracer.node(ei,ni);
         .                     }
         .                     // Deletes all pending branchers
         2 ( 0.00%)            (void) cur->choice();
       251 ( 0.00%)  => ???:0x0000000004df1820 (1x)
         3 ( 0.00%)            delete best;
         2 ( 0.00%)            best = cur;
         1 ( 0.00%)            cur = nullptr;
         .                     path.next();
         1 ( 0.00%)            mark = path.entries();
         .                   }
         .                   return best->clone();
         .                 case SS_BRANCH:
         .                   {
         .                     Space* c;
12,122,974 ( 0.01%)            if ((d == 0) || (d >= opt.c_d)) {
         .                       c = cur->clone();
 2,786,698 ( 0.00%)              d = 1;
         .                     } else {
 3,762,664 ( 0.00%)              c = nullptr;
 1,881,332 ( 0.00%)              d++;
         .                     }
 2,786,698 ( 0.00%)            const Choice* ch = path.push(*this,cur,c,nid);
         .                     if (tracer) {
         .                       SearchTracer::NodeInfo ni(SearchTracer::NodeType::BRANCH,
         .                                                 tracer.wid(), nid, *cur, ch);
         .                       tracer.node(ei,ni);
         .                     }
         .                     cur->commit(*ch,0);
         .                     break;
         .                   }
-- line 144 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/driver/script.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 53 ----------------------------------------
          .                 Search::FailStop* fs; ///< Used fail stop object
          .                 Search::TimeStop* ts; ///< Used time stop object
          .                 Search::RestartStop* rs; ///< Used restart stop object
          .                 std::atomic<bool>& search_finished; ///< True if solution has been found.
          .                 GECODE_DRIVER_EXPORT
          .                 static bool sigint;   ///< Whether search was interrupted using Ctrl-C
          .                 /// Initialize stop object
          .                 PBSCombinedStop(unsigned long long int node, unsigned long long int fail, double time, unsigned long long int restart, std::atomic<bool>& search_finished)
          8 ( 0.00%)          : ns((node > 0ULL) ? new Search::NodeStop(node) : nullptr),
          8 ( 0.00%)            fs((fail > 0ULL) ? new Search::FailStop(fail) : nullptr),
         12 ( 0.00%)            ts((time > 0.0)  ? new Search::TimeStop(time) : nullptr),
         24 ( 0.00%)            rs((restart > 0.0) ? new Search::RestartStop(restart) : nullptr),
          4 ( 0.00%)            search_finished(search_finished) {
          4 ( 0.00%)          sigint = false;
          .                 }
          .               public:
          .                 /// Reason why search has been stopped
          .                 enum {
          .                   SR_NODE = 1 << 0, ///< Node limit reached
          .                   SR_FAIL = 1 << 1, ///< Fail limit reached
          .                   SR_TIME = 1 << 2, ///< Time limit reached
          .                   SR_RESTART = 1 << 3, ///< Time limit reached
          .                   SR_INT  = 1 << 4,  ///< Interrupted by user
          .                   SR_SOLUTION = 1 << 5 ///< Solution found
          .                 };
          .                 /// Test whether search must be stopped
 95,826,462 ( 0.11%)        virtual bool stop(const Search::Statistics& s, const Search::Options& o) {
          .                   // if (search_finished.load()) {
          .                   //   std::cerr << "sol is true." << std::endl;
          .                   // }
          .                   return
 31,942,154 ( 0.04%)            sigint ||
 31,942,152 ( 0.04%)            (search_finished.load(std::memory_order_relaxed)) ||
 79,855,380 ( 0.09%)            ((ns != nullptr) && ns->stop(s,o)) ||
 47,913,228 ( 0.05%)            ((fs != nullptr) && fs->stop(s,o)) ||
111,797,537 ( 0.13%)            ((ts != nullptr) && ts->stop(s,o)) ||
 15,971,076 ( 0.02%)            ((rs != nullptr) && rs->stop(s,o));
111,797,539 ( 0.13%)        }
          .                 /// Report reason why search has been stopped
          .                 int reason(const Search::Statistics& s, const Search::Options& o) {
          .                   return
          .                     (((ns != nullptr) && ns->stop(s,o)) ? SR_NODE : 0) |
          .                     (((fs != nullptr) && fs->stop(s,o)) ? SR_FAIL : 0) |
          .                     (((ts != nullptr) && ts->stop(s,o)) ? SR_TIME : 0) |
          .                     (((rs != nullptr) && rs->stop(s,o)) ? SR_RESTART : 0) |
          .                     (sigint                          ? SR_INT  : 0) |
-- line 98 ----------------------------------------
-- line 125 ----------------------------------------
          .                 }
          .             #endif
          .                 /// Install handler for catching Ctrl-C
          .                 static void installCtrlHandler(bool install, bool force=false) {
          .                   if (force || !sigint) {
          .                     #ifdef GECODE_THREADS_WINDOWS
          .                             SetConsoleCtrlHandler( (PHANDLER_ROUTINE) interrupt, install);
          .                     #else
          6 ( 0.00%)                    std::signal(SIGINT, install ? interrupt : SIG_DFL);
      1,083 ( 0.00%)  => ???:0x0000000004866730 (1x)
          .                     #endif
          .                   }
          .                 }
          .                 /// Destructor
          .                 ~PBSCombinedStop(void) {
          .                   delete ns; delete fs; delete ts; delete rs;
          .                 }
          .             };
-- line 141 ----------------------------------------
-- line 250 ----------------------------------------
          .              */
          .             GECODE_DRIVER_EXPORT double
          .             dev(double t[], unsigned int n);
          .           
          .             /// Create cutoff object from options
          .             template<class Options>
          .             inline Search::Cutoff*
          .             createCutoff(const Options& o) {
         14 ( 0.00%)      switch (o.restart()) {
          .               case RM_NONE:
          .                 return nullptr;
          .               case RM_CONSTANT:
          4 ( 0.00%)        return Search::Cutoff::constant(o.restart_scale());
      1,498 ( 0.00%)  => ???:0x0000000004867e20 (1x)
          .               case RM_LINEAR:
          .                 return Search::Cutoff::linear(o.restart_scale());
          .               case RM_LUBY:
          .                 return Search::Cutoff::luby(o.restart_scale());
          .               case RM_GEOMETRIC:
          .                 return Search::Cutoff::geometric(o.restart_scale(),o.restart_base());
          .               default: GECODE_NEVER;
          .               }
-- line 270 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/flatzinc.cpp
--------------------------------------------------------------------------------
Ir                   

-- line 82 ----------------------------------------
          .               }
          .             };
          .           
          .           }
          .           
          .           namespace Gecode { namespace FlatZinc {
          .           
          .             // Default random number generator
          8 ( 0.00%)    Rnd defrnd(0);
      1,112 ( 0.00%)  => ???:0x0000000004867d00 (1x)
         77 ( 0.00%)  => ???:0x00000000048674f0 (1x)
          .           
          .             /**
          .              * \brief Branching on the introduced variables
          .              *
          .              * This brancher makes sure that when a solution is found for the model
          .              * variables, all introduced variables are either assigned, or the solution
          .              * can be extended to a solution of the introduced variables.
          .              *
-- line 98 ----------------------------------------
-- line 260 ----------------------------------------
          .               /// Delete brancher and return its size
          .               virtual size_t dispose(Space&) {
          .                 return sizeof(*this);
          .               }
          .             };
          .           
          .             class BranchInformationO : public SharedHandle::Object {
          .             private:
          4 ( 0.00%)      struct BI {
          .                 std::string r0;
          .                 std::string r1;
          .                 std::vector<std::string> n;
          .                 BI(void) : r0(""), r1(""), n(0) {}
          .                 BI(const std::string& r00, const std::string& r10,
          .                    const std::vector<std::string>& n0)
          .                   : r0(r00), r1(r10), n(n0) {}
          .               };
          .               std::vector<BI> v;
          .               BranchInformationO(std::vector<BI> v0) : v(v0) {}
          .             public:
          2 ( 0.00%)      BranchInformationO(void) {}
          .               virtual ~BranchInformationO(void) {}
          .               virtual SharedHandle::Object* copy(void) const {
          .                 return new BranchInformationO(v);
          .               }
          .               /// Add new brancher information
         64 ( 0.00%)      void add(BrancherGroup bg,
          .                        const std::string& rel0,
          .                        const std::string& rel1,
          .                        const std::vector<std::string>& n) {
         28 ( 0.00%)        v.resize(std::max(static_cast<unsigned int>(v.size()),bg.id()+1));
          8 ( 0.00%)        v[bg.id()] = BI(rel0,rel1,n);
         44 ( 0.00%)      }
          .               /// Output branch information
          .               void print(const Brancher& b,
          .                          unsigned int a, int i, int n, std::ostream& o) const {
          .                 const BI& bi = v[b.group().id()];
          .                 o << bi.n[i] << " " << (a==0 ? bi.r0 : bi.r1) << " " << n;
          .               }
          .           #ifdef GECODE_HAS_FLOAT_VARS
          .               void print(const Brancher& b,
-- line 300 ----------------------------------------
-- line 309 ----------------------------------------
          .           
          .             BranchInformation::BranchInformation(void)
          .               : SharedHandle(nullptr) {}
          .           
          .             BranchInformation::BranchInformation(const BranchInformation& bi)
          .               : SharedHandle(bi) {}
          .           
          .             void
          5 ( 0.00%)    BranchInformation::init(void) {
          .               assert(object() == nullptr);
          .               object(new BranchInformationO());
          4 ( 0.00%)    }
          .           
          .             void
          .             BranchInformation::add(BrancherGroup bg,
          .                                    const std::string& rel0,
          .                                    const std::string& rel1,
          .                                    const std::vector<std::string>& n) {
         26 ( 0.00%)      static_cast<BranchInformationO*>(object())->add(bg,rel0,rel1,n);
     15,924 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/flatzinc.cpp:Gecode::FlatZinc::BranchInformationO::add(Gecode::BrancherGroup, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&) (4x)
          .             }
          .             void
          .             BranchInformation::print(const Brancher& b, unsigned int a, int i,
          .                                      int n, std::ostream& o) const {
          .               static_cast<const BranchInformationO*>(object())->print(b,a,i,n,o);
          .             }
          .           #ifdef GECODE_HAS_FLOAT_VARS
          .             void
-- line 335 ----------------------------------------
-- line 350 ----------------------------------------
          .             void varValPrintF(const Space &home, const Brancher& b,
          .                               unsigned int a,
          .                               FloatVar, int i, const FloatNumBranch& nl,
          .                               std::ostream& o) {
          .               static_cast<const FlatZincSpace&>(home).branchInfo.print(b,a,i,nl,o);
          .             }
          .           #endif
          .           
        220 ( 0.00%)    IntSet vs2is(IntVarSpec* vs) {
         44 ( 0.00%)      if (vs->assigned) {
          .                 return IntSet(vs->i,vs->i);
          .               }
         44 ( 0.00%)      if (vs->domain()) {
         22 ( 0.00%)        AST::SetLit* sl = vs->domain.some();
         44 ( 0.00%)        if (sl->interval) {
         44 ( 0.00%)          return IntSet(sl->min, sl->max);
          .                 } else {
          .                   int* newdom = heap.alloc<int>(static_cast<unsigned long int>(sl->s.size()));
          .                   for (int i=sl->s.size(); i--;)
          .                     newdom[i] = sl->s[i];
          .                   IntSet ret(newdom, sl->s.size());
          .                   heap.free(newdom, static_cast<unsigned long int>(sl->s.size()));
          .                   return ret;
          .                 }
          .               }
          .               return IntSet(Int::Limits::min, Int::Limits::max);
        220 ( 0.00%)    }
          .           
          .             int vs2bsl(BoolVarSpec* bs) {
          .               if (bs->assigned) {
          .                 return bs->i;
          .               }
          .               if (bs->domain()) {
          .                 AST::SetLit* sl = bs->domain.some();
          .                 assert(sl->interval);
-- line 384 ----------------------------------------
-- line 788 ----------------------------------------
          .               typedef std::unordered_set<DFA> DFASet;
          .               /// Hash table of DFAs
          .               DFASet dfaSet;
          .           
          .               /// Initialize
          .               FlatZincSpaceInitData(void) {}
          .             };
          .           
104,210,002 ( 0.12%)    FlatZincSpace::FlatZincSpace(FlatZincSpace& f)
          .               : Space(f),
 48,096,924 ( 0.05%)        _initData(nullptr), _random(f._random),
 72,145,386 ( 0.08%)  => ???:0x0000000004867f60 (8,016,154x)
  8,016,154 ( 0.01%)        _solveAnnotations(nullptr),
 16,032,308 ( 0.02%)        _lnsType(f._lnsType),
          .                 restart_data(f.restart_data),
          .                 iv_boolalias(nullptr),
          .           #ifdef GECODE_HAS_FLOAT_VARS
 16,032,308 ( 0.02%)        step(f.step),
          .           #endif
 16,032,308 ( 0.02%)        pbs_current_best_sol(f.pbs_current_best_sol),
112,226,156 ( 0.13%)        needAuxVars(f.needAuxVars) {
20,610,400,408 (23.05%)  => ???:0x00000000048678e0 (8,016,154x)
 16,032,308 ( 0.02%)  => /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/lnsstrategies.cpp:LNStrategies::LNStrategies() (8,016,154x)
 16,032,308 ( 0.02%)        _optVar = f._optVar;
 16,032,308 ( 0.02%)        _optVarIsInt = f._optVarIsInt;
 16,032,308 ( 0.02%)        _method = f._method;
          .                 _lns = f._lns;
 16,032,308 ( 0.02%)        default_lns = f.default_lns;
          .                 _lnsInitialSolution = f._lnsInitialSolution;
          .                 branchInfo = f.branchInfo;
          .                 iv.update(*this, f.iv);
          .                 iv_lns.update(*this, f.iv_lns);
          .                 iv_lns_default.update(*this, f.iv_lns_default);
 16,032,308 ( 0.02%)        num_non_introduced_vars = f.num_non_introduced_vars;
 16,032,308 ( 0.02%)        intVarCount = f.intVarCount;
          .           
          .                 on_restart_iv.update(*this, f.on_restart_iv);
          .                 on_restart_bv.update(*this, f.on_restart_bv);
          .           #ifdef GECODE_HAS_SET_VARS
          .                 on_restart_sv.update(*this, f.on_restart_sv);
          .           #endif
          .           #ifdef GECODE_HAS_FLOAT_VARS
          .                 on_restart_fv.update(*this, f.on_restart_fv);
          .           #endif
 16,032,308 ( 0.02%)        if (needAuxVars) {
          .                   IntVarArgs iva;
 40,080,770 ( 0.04%)          for (int i=0; i<f.iv_aux.size(); i++) {
          .                     if (!f.iv_aux[i].assigned()) {
          .                       iva << IntVar();
          .                       iva[iva.size()-1].update(*this, f.iv_aux[i]);
          .                     }
          .                   }
          .                   iv_aux = IntVarArray(*this, iva);
          .                 }
          .           
          .                 bv.update(*this, f.bv);
 16,032,308 ( 0.02%)        boolVarCount = f.boolVarCount;
 16,032,308 ( 0.02%)        if (needAuxVars) {
          .                   BoolVarArgs bva;
 40,080,770 ( 0.04%)          for (int i=0; i<f.bv_aux.size(); i++) {
          .                     if (!f.bv_aux[i].assigned()) {
          .                       bva << BoolVar();
          .                       bva[bva.size()-1].update(*this, f.bv_aux[i]);
          .                     }
          .                   }
          .                   bv_aux = BoolVarArray(*this, bva);
          .                 }
          .           
          .           #ifdef GECODE_HAS_SET_VARS
          .                 sv.update(*this, f.sv);
 16,032,308 ( 0.02%)        setVarCount = f.setVarCount;
 16,032,308 ( 0.02%)        if (needAuxVars) {
          .                   SetVarArgs sva;
 40,080,770 ( 0.04%)          for (int i=0; i<f.sv_aux.size(); i++) {
          .                     if (!f.sv_aux[i].assigned()) {
          .                       sva << SetVar();
          .                       sva[sva.size()-1].update(*this, f.sv_aux[i]);
          .                     }
          .                   }
          .                   sv_aux = SetVarArray(*this, sva);
          .                 }
          .           #endif
          .           #ifdef GECODE_HAS_FLOAT_VARS
          .                 fv.update(*this, f.fv);
 16,032,308 ( 0.02%)        floatVarCount = f.floatVarCount;
 16,032,308 ( 0.02%)        if (needAuxVars) {
          .                   FloatVarArgs fva;
 40,080,770 ( 0.04%)          for (int i=0; i<f.fv_aux.size(); i++) {
          .                     if (!f.fv_aux[i].assigned()) {
          .                       fva << FloatVar();
          .                       fva[fva.size()-1].update(*this, f.fv_aux[i]);
          .                     }
          .                   }
          .                   fv_aux = FloatVarArray(*this, fva);
          .                 }
          .           #endif
 88,177,694 ( 0.10%)      }
          .           
          8 ( 0.00%)    FlatZincSpace::FlatZincSpace(Rnd& random)
          3 ( 0.00%)    :  _initData(new FlatZincSpaceInitData),
        269 ( 0.00%)  => ???:0x00000000048662e0 (1x)
          2 ( 0.00%)      intVarCount(-1), boolVarCount(-1), floatVarCount(-1), setVarCount(-1),
          3 ( 0.00%)      _optVar(-1), _optVarIsInt(true), _lns(0), _lnsInitialSolution(0),
          5 ( 0.00%)      _random(random), _solveAnnotations(nullptr), 
        909 ( 0.00%)  => ???:0x0000000004867f60 (1x)
         10 ( 0.00%)      pbs_current_best_sol(nullptr), needAuxVars(true) {
      6,626 ( 0.00%)  => ???:0x0000000004866740 (1x)
          2 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/lnsstrategies.cpp:LNStrategies::LNStrategies() (1x)
          2 ( 0.00%)      branchInfo.init();
        233 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/flatzinc.cpp:Gecode::FlatZinc::BranchInformation::init() (1x)
          6 ( 0.00%)    }
          .           
          .             void
          .             FlatZincSpace::init(int intVars, int boolVars,
         16 ( 0.00%)                        int setVars, int floatVars) {
          .               (void) setVars;
          .               (void) floatVars;
          .           
          1 ( 0.00%)      intVarCount = 0;
          .               iv = IntVarArray(*this, intVars);
          2 ( 0.00%)      iv_introduced = std::vector<bool>(2*intVars);
          3 ( 0.00%)      iv_boolalias = alloc<int>(intVars+(intVars==0?1:0));
          1 ( 0.00%)      boolVarCount = 0;
          .               bv = BoolVarArray(*this, boolVars);
          2 ( 0.00%)      bv_introduced = std::vector<bool>(2*boolVars);
          .           #ifdef GECODE_HAS_SET_VARS
          1 ( 0.00%)      setVarCount = 0;
          5 ( 0.00%)      sv = SetVarArray(*this, setVars);
      1,360 ( 0.00%)  => ???:0x00000000048664c0 (1x)
          2 ( 0.00%)      sv_introduced = std::vector<bool>(2*setVars);
          .           #endif
          .           #ifdef GECODE_HAS_FLOAT_VARS
          1 ( 0.00%)      floatVarCount = 0;
          .               fv = FloatVarArray(*this, floatVars);
          2 ( 0.00%)      fv_introduced = std::vector<bool>(2*floatVars);
          .           #endif
         11 ( 0.00%)    }
          .           
          .             void
        220 ( 0.00%)    FlatZincSpace::newIntVar(IntVarSpec* vs) {
         44 ( 0.00%)      if (vs->alias) {
          .                 iv[intVarCount++] = iv[vs->i];
          .               } else {
         66 ( 0.00%)        IntSet dom(vs2is(vs));
      7,831 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/flatzinc.cpp:Gecode::FlatZinc::vs2is(Gecode::FlatZinc::IntVarSpec*) (22x)
         66 ( 0.00%)        if (dom.size()==0) {
          .                   fail();
          .                   return;
          .                 } else {
        220 ( 0.00%)          iv[intVarCount++] = IntVar(*this, dom);
      2,873 ( 0.00%)  => ???:0x0000000004867de0 (22x)
          .                 }
          .               }
         66 ( 0.00%)      iv_introduced[2*(intVarCount-1)] = vs->introduced;
         66 ( 0.00%)      iv_introduced[2*(intVarCount-1)+1] = vs->funcDep;
         66 ( 0.00%)      iv_boolalias[intVarCount-1] = -1;
        176 ( 0.00%)    }
          .           
          .             void
          .             FlatZincSpace::aliasBool2Int(int iv, int bv) {
          .               iv_boolalias[iv] = bv;
          .             }
          .             int
          4 ( 0.00%)    FlatZincSpace::aliasBool2Int(int iv) {
         12 ( 0.00%)      return iv_boolalias[iv];
          4 ( 0.00%)    }
          .           
          .             void
          .             FlatZincSpace::newBoolVar(BoolVarSpec* vs) {
          .               if (vs->alias) {
          .                 bv[boolVarCount++] = bv[vs->i];
          .               } else {
          .                 bv[boolVarCount++] = BoolVar(*this, vs2bsl(vs), vs2bsh(vs));
          .               }
-- line 950 ----------------------------------------
-- line 1027 ----------------------------------------
          .             FlatZincSpace::newFloatVar(FloatVarSpec*) {
          .               throw FlatZinc::Error("Gecode", "float variables not supported");
          .             }
          .           #endif
          .           
          .             namespace {
          .               struct ConExprOrder {
          .                 bool operator() (ConExpr* ce0, ConExpr* ce1) {
         12 ( 0.00%)          return ce0->args->a.size() < ce1->args->a.size();
          .                 }
          .               };
          .             }
          .           
          .             void
         26 ( 0.00%)    FlatZincSpace::postConstraints(std::vector<ConExpr*>& ces) {
          2 ( 0.00%)      storeConstraintInformation(ces);
     13,228 ( 0.00%)  => ???:0x0000000004867b10 (2x)
          .           
          .               ConExprOrder ceo;
          .               std::sort(ces.begin(), ces.end(), ceo);
          .           
         21 ( 0.00%)      for (unsigned int i=0; i<ces.size(); i++) {
          4 ( 0.00%)        const ConExpr& ce = *ces[i];
          .                 try {
         20 ( 0.00%)          registry().post(*this, ce);
     75,494 ( 0.00%)  => ???:0x0000000004866800 (4x)
         60 ( 0.00%)  => ???:0x0000000004866850 (4x)
          .                 } catch (Gecode::Exception& e) {
          .                     throw FlatZinc::Error("Gecode", e.what(), ce.ann);
          .                 } catch (AST::TypeError& e) {
          .                     throw FlatZinc::Error("Type error", e.what(), ce.ann);
          .                 }
         24 ( 0.00%)        delete ces[i];
        480 ( 0.00%)  => ???:0x0000000004866220 (4x)
          4 ( 0.00%)        ces[i] = nullptr;
          .               }
         22 ( 0.00%)    }
          .           
          .             void flattenAnnotations(AST::Array* ann, std::vector<AST::Node*>& out) {
          .                 for (unsigned int i=0; i<ann->a.size(); i++) {
          .                   if (ann->a[i]->isCall("seq_search")) {
          .                     AST::Call* c = ann->a[i]->getCall();
          .                     if (c->args->isArray())
          .                       flattenAnnotations(c->args->getArray(), out);
          .                     else
          .                       out.push_back(c->args);
          .                   } else {
          .                     out.push_back(ann->a[i]);
          .                   }
          .                 }
          .             }
          .           
         22 ( 0.00%)    void FlatZincSpace::storeConstraintInformation(std::vector<ConExpr*>& ces){
          2 ( 0.00%)      num_non_introduced_vars = 0;
          .               // The best vars (given arguments to constraints). The vars used in _lns if relax and reconstruct is not used.
          .               std::vector<AST::Array*> best_vars_vec;
          .               std::vector<AST::Array*> temp_vars_vec;
          .               // The current best value given constraint times variable value. Used to select the best combination for LNS without relax and reconstruct.
          1 ( 0.00%)      int currentBest = 0;
          1 ( 0.00%)      int temp = 0;
         17 ( 0.00%)      for (ConExpr* ce : ces){
          .                 // If a better candidate for LNS has been found, update the best_vars and currentBest variables.
          7 ( 0.00%)        if (temp > currentBest){
          .                   currentBest = temp;
          .                   best_vars_vec = temp_vars_vec;
          .                   temp_vars_vec.clear();
          .                 }
          .                 // Check domain of variables == size of vars in all_diff, then it is important
          .                 // Go through every constraint in the model and find the best fit for LNS.
         14 ( 0.00%)        if (ce->id == "fzn_all_different_int" || ce->id == "fzn_alldifferent_except_0"){
          2 ( 0.00%)          temp_vars_vec.push_back(ce->args->a[0]->getArray());
          .                   temp = 1000 + temp_vars_vec[0]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size();
          .                 }
          6 ( 0.00%)        else if (ce->id == "fzn_bin_packing_load"){
          .                   temp_vars_vec.push_back(ce->args->a[0]->getArray());
          .                   temp_vars_vec.push_back(ce->args->a[1]->getArray());
          .                   temp = 1000 + temp_vars_vec[0]->a.size() + temp_vars_vec[1]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size() + temp_vars_vec[1]->a.size();
          .                 }
         12 ( 0.00%)        else if (ce->id == "fzn_bin_packing_capa" || ce->id == "fzn_bin_packing"){
          .                   temp_vars_vec.push_back(ce->args->a[1]->getArray());
          .                   temp = 1000 + temp_vars_vec[0]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size();
          .                 }
          6 ( 0.00%)        else if (ce->id == "fzn_circuit"){
          .                   temp_vars_vec.push_back(ce->args->a[0]->getArray());
          .                   temp = 1000 + temp_vars_vec[0]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size();
          .                 }
          6 ( 0.00%)        else if (ce->id == "fzn_cumulatives"){
          .                   temp_vars_vec.push_back(ce->args->a[0]->getArray());
          .                   temp_vars_vec.push_back(ce->args->a[1]->getArray());
          .                   temp_vars_vec.push_back(ce->args->a[2]->getArray());
          .                   temp_vars_vec.push_back(ce->args->a[3]->getArray());
          .                   temp = 1000 + temp_vars_vec[0]->a.size() + temp_vars_vec[1]->a.size() + temp_vars_vec[2]->a.size() + temp_vars_vec[3]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size() + temp_vars_vec[1]->a.size() + temp_vars_vec[2]->a.size() + temp_vars_vec[3]->a.size();  
          .                 }
         12 ( 0.00%)        else if (ce->id == "fzn_cumulative_opt" || ce->id == "cumulative"){
          .                   temp_vars_vec.push_back(ce->args->a[0]->getArray());
          .                   temp_vars_vec.push_back(ce->args->a[1]->getArray());
          .                   temp_vars_vec.push_back(ce->args->a[2]->getArray());
          .                   temp = 1000 + temp_vars_vec[0]->a.size() + temp_vars_vec[1]->a.size() + temp_vars_vec[2]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size() + temp_vars_vec[1]->a.size() + temp_vars_vec[2]->a.size();  
          .                 }
          6 ( 0.00%)        else if (ce->id == "fzn_diffn"){
          .                   temp_vars_vec.push_back(ce->args->a[0]->getArray());
          .                   temp_vars_vec.push_back(ce->args->a[1]->getArray());
          .                   temp_vars_vec.push_back(ce->args->a[2]->getArray());
          .                   temp_vars_vec.push_back(ce->args->a[3]->getArray());
          .                   temp = 1000 + temp_vars_vec[0]->a.size() + temp_vars_vec[1]->a.size() + temp_vars_vec[2]->a.size() + temp_vars_vec[3]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size() + temp_vars_vec[1]->a.size() + temp_vars_vec[2]->a.size() + temp_vars_vec[3]->a.size();  
          .                 }
         12 ( 0.00%)        else if (ce->id == "fzn_global_cardinality_closed" || ce->id == "fzn_global_cardinality"){
          .                   temp_vars_vec.push_back(ce->args->a[0]->getArray());
          .                   temp_vars_vec.push_back(ce->args->a[2]->getArray());
          .                   temp = 1000 + temp_vars_vec[0]->a.size() + temp_vars_vec[1]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size() + temp_vars_vec[1]->a.size();
          .                 }
         12 ( 0.00%)        else if (ce->id == "fzn_global_cardinality_low_up" || ce->id == "fzn_global_cardinality_low_up_closed"){
          .                   temp_vars_vec.push_back(ce->args->a[0]->getArray());
          4 ( 0.00%)          temp = 1000 + temp_vars_vec[0]->a.size();
          1 ( 0.00%)          num_non_introduced_vars += temp_vars_vec[0]->a.size();
          .                 }
         12 ( 0.00%)        else if (ce->id == "fzn_disjunctive_strict_opt" || ce->id == "fzn_disjunctive_strict"){
          .                   temp_vars_vec.push_back(ce->args->a[0]->getArray());
          .                   temp_vars_vec.push_back(ce->args->a[1]->getArray());
          .                   temp = 1000 + temp_vars_vec[0]->a.size() + temp_vars_vec[1]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size() + temp_vars_vec[1]->a.size();
          .                 }
          6 ( 0.00%)        else if (ce->id == "fzn_inverse"){
          .                   temp_vars_vec.push_back(ce->args->a[0]->getArray());
          .                   temp_vars_vec.push_back(ce->args->a[1]->getArray());
          .                   temp = 750 + temp_vars_vec[0]->a.size() + temp_vars_vec[1]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size() + temp_vars_vec[1]->a.size();
          .                 }
          6 ( 0.00%)        else if (ce->id == "fzn_decreasing_int"){
          .                   temp_vars_vec.push_back(ce->args->a[0]->getArray());
          .                   temp = 750 + temp_vars_vec[0]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size();
          .                 }
         12 ( 0.00%)        else if (ce->id == "fzn_table_int_reif" || ce->id == "fzn_table_int"){
          .                   temp_vars_vec.push_back(ce->args->a[0]->getArray());
          .                   temp = 750 + temp_vars_vec[0]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size();
          .                 }
          6 ( 0.00%)        else if (ce->id == "fzn_increasing_int"){
          .                   temp_vars_vec.push_back(ce->args->a[0]->getArray());
          .                   temp = 750 + temp_vars_vec[0]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size();
          .                 }
          6 ( 0.00%)        else if (ce->id == "fzn_sort"){
          .                   temp_vars_vec.push_back(ce->args->a[0]->getArray());
          .                   temp_vars_vec.push_back(ce->args->a[1]->getArray());
          .                   temp = 500 + temp_vars_vec[0]->a.size() + temp_vars_vec[1]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size() + temp_vars_vec[1]->a.size();
          .                 }
          6 ( 0.00%)        else if (ce->id == "fzn_value_precede_int"){
          .                   temp_vars_vec.push_back(ce->args->a[2]->getArray());
          .                   temp = 500 + temp_vars_vec[0]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size();
          .                 }
         12 ( 0.00%)        else if (ce->id == "fzn_count_eq_reif" || ce->id == "fzn_count_eq"){
          4 ( 0.00%)          temp_vars_vec.push_back(ce->args->a[0]->getArray());
        966 ( 0.00%)  => ???:0x0000000004867350 (1x)
          .                   temp = 500 + temp_vars_vec[0]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size();
          .                 }
          4 ( 0.00%)        else if (ce->id == "fzn_regular"){
          .                   temp_vars_vec.push_back(ce->args->a[0]->getArray());
          .                   temp_vars_vec.push_back(ce->args->a[3]->getArray());
          .                   temp = 500 + temp_vars_vec[0]->a.size() + temp_vars_vec[1]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size() + temp_vars_vec[1]->a.size();
          .                 }
          4 ( 0.00%)        else if (ce->id == "fzn_nvalue"){
          1 ( 0.00%)          temp_vars_vec.push_back(ce->args->a[1]->getArray());
          4 ( 0.00%)          temp = 500 + temp_vars_vec[0]->a.size();
          2 ( 0.00%)          num_non_introduced_vars += temp_vars_vec[0]->a.size();
          .                 }
          4 ( 0.00%)        else if (ce->id == "fzn_at_least_int"){
          .                   temp_vars_vec.push_back(ce->args->a[1]->getArray());
          .                   temp = 310 + temp_vars_vec[0]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size();
          .                 }
          4 ( 0.00%)        else if (ce->id == "fzn_roots"){
          .                   temp_vars_vec.push_back(ce->args->a[0]->getArray());
          .                   temp = 300 + temp_vars_vec[0]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size();
          .                 }
          4 ( 0.00%)        else if (ce->id == "fzn_range"){
          .                   temp_vars_vec.push_back(ce->args->a[0]->getArray());
          .                   temp = 300 + temp_vars_vec[0]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size();
          .                 }
          8 ( 0.00%)        else if (ce->id == "fzn_lex_less_int" || ce->id == "fzn_lex_lesseq_int"){
          .                   temp_vars_vec.push_back(ce->args->a[0]->getArray());
          .                   temp_vars_vec.push_back(ce->args->a[1]->getArray());
          .                   temp = 300 + temp_vars_vec[0]->a.size() + temp_vars_vec[1]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size() + temp_vars_vec[1]->a.size();
          .                 }
          4 ( 0.00%)        else if (ce->id == "fzn_int_set_channel"){
          .                   temp_vars_vec.push_back(ce->args->a[0]->getArray());
          .                   temp = 300 + temp_vars_vec[0]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size();
          .                 }
          8 ( 0.00%)        else if (ce->id == "fzn_member_int_reif" || ce->id == "fzn_member_int"){
          .                   temp_vars_vec.push_back(ce->args->a[0]->getArray());
          .                   temp = 300 + temp_vars_vec[0]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size();
          .                 }
          4 ( 0.00%)        else if (ce->id == "fzn_at_most_int"){
          .                   temp_vars_vec.push_back(ce->args->a[1]->getArray());
          .                   temp = 300 + temp_vars_vec[0]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size();
          .                 }
          4 ( 0.00%)        else if (ce->id == "fzn_all_equal_int"){
          .                   temp_vars_vec.push_back(ce->args->a[0]->getArray());
          .                   temp = 200 + temp_vars_vec[0]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size();
          .                 }
          4 ( 0.00%)        else if (ce->id == "fzn_among"){
          .                   temp_vars_vec.push_back(ce->args->a[1]->getArray());
          .                   temp = 100 + temp_vars_vec[0]->a.size();
          .                   num_non_introduced_vars += temp_vars_vec[0]->a.size();
          .                 }
          .               }
          .           
          2 ( 0.00%)      if (best_vars_vec.size() > 0){
          .                 // Get total number of vars:
          2 ( 0.00%)        int total_vars = 0;
          7 ( 0.00%)        for (long unsigned int i = 0; i < best_vars_vec.size(); i++){
          2 ( 0.00%)          total_vars += best_vars_vec[i]->a.size();
          .                 }
          .           
          .                 // Allocate iv_lns size.
          .                 iv_lns_default = IntVarArray(*this, total_vars);
          .           
          4 ( 0.00%)        int iv_lns_index = 0;
          .                 // Add the selected variables to iv_lns.
          6 ( 0.00%)        for (AST::Array* vars : best_vars_vec){
         41 ( 0.00%)          for (long unsigned int i = 0; i < vars->a.size(); i++){
         28 ( 0.00%)            iv_lns_default[iv_lns_index] = iv[vars->a[i]->getIntVar()];
          8 ( 0.00%)            iv_lns_index++;
          .                   }
          .                 }
          1 ( 0.00%)        default_lns = 60;
          .               }
         18 ( 0.00%)    }
          .           
          .             void
         44 ( 0.00%)    FlatZincSpace::createBranchers(Printer&p, AST::Node* ann, FlatZincOptions& opt, bool ignoreUnknown, BranchModifier& bm, std::ostream& err) {
          .               int seed = opt.seed();
          .               double decay = opt.decay();
         10 ( 0.00%)      Rnd rnd(static_cast<unsigned int>(seed));
        380 ( 0.00%)  => ???:0x0000000004867d00 (2x)
         10 ( 0.00%)      TieBreak<IntVarBranch> def_int_varsel = bm.def_int_varsel;
        532 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/tiebreak.hpp:Gecode::TieBreak<Gecode::IntVarBranch>::TieBreak(Gecode::TieBreak<Gecode::IntVarBranch> const&) (2x)
          .               IntBoolVarBranch def_intbool_varsel = INTBOOL_VAR_AFC_SIZE_MAX(0.99);
          .               IntValBranch def_int_valsel = bm.def_int_valsel;
         10 ( 0.00%)      std::string def_int_rel_left = "=";
        102 ( 0.00%)  => /usr/include/c++/11/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) [clone .constprop.0] (2x)
         10 ( 0.00%)      std::string def_int_rel_right = "!=";
        158 ( 0.00%)  => /usr/include/c++/11/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) [clone .constprop.0] (2x)
         10 ( 0.00%)      TieBreak<BoolVarBranch> def_bool_varsel = bm.def_bool_varsel;
        536 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/tiebreak.hpp:Gecode::TieBreak<Gecode::BoolVarBranch>::TieBreak(Gecode::TieBreak<Gecode::BoolVarBranch> const&) (2x)
          .               BoolValBranch def_bool_valsel = bm.def_bool_valsel;
         10 ( 0.00%)      std::string def_bool_rel_left = "=";
        102 ( 0.00%)  => /usr/include/c++/11/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) [clone .constprop.0] (2x)
         10 ( 0.00%)      std::string def_bool_rel_right = "!=";
        158 ( 0.00%)  => /usr/include/c++/11/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) [clone .constprop.0] (2x)
          .           #ifdef GECODE_HAS_SET_VARS
          .               SetVarBranch def_set_varsel = bm.def_set_varsel;
          .               SetValBranch def_set_valsel = bm.def_set_valsel;
         10 ( 0.00%)      std::string def_set_rel_left = "in";
        158 ( 0.00%)  => /usr/include/c++/11/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) [clone .constprop.0] (2x)
         10 ( 0.00%)      std::string def_set_rel_right = "not in";
        152 ( 0.00%)  => /usr/include/c++/11/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) [clone .constprop.0] (2x)
          .           #endif
          .           #ifdef GECODE_HAS_FLOAT_VARS
         10 ( 0.00%)      TieBreak<FloatVarBranch> def_float_varsel = bm.def_float_varsel;
        536 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/tiebreak.hpp:Gecode::TieBreak<Gecode::FloatVarBranch>::TieBreak(Gecode::TieBreak<Gecode::FloatVarBranch> const&) (2x)
          .               FloatValBranch def_float_valsel = bm.def_float_valsel;
         10 ( 0.00%)      std::string def_float_rel_left = "<=";
        158 ( 0.00%)  => /usr/include/c++/11/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) [clone .constprop.0] (2x)
         10 ( 0.00%)      std::string def_float_rel_right = ">";
        102 ( 0.00%)  => /usr/include/c++/11/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) [clone .constprop.0] (2x)
          .           #endif
          .           
          2 ( 0.00%)      std::vector<bool> iv_searched(iv.size());
         98 ( 0.00%)      for (unsigned int i=iv.size(); i--;)
          .                 iv_searched[i] = false;
          2 ( 0.00%)      std::vector<bool> bv_searched(bv.size());
          .               for (unsigned int i=bv.size(); i--;)
          .                 bv_searched[i] = false;
          .           #ifdef GECODE_HAS_SET_VARS
          2 ( 0.00%)      std::vector<bool> sv_searched(sv.size());
          .               for (unsigned int i=sv.size(); i--;)
          .                 sv_searched[i] = false;
          .           #endif
          .           #ifdef GECODE_HAS_FLOAT_VARS
          2 ( 0.00%)      std::vector<bool> fv_searched(fv.size());
          .               for (unsigned int i=fv.size(); i--;)
          .                 fv_searched[i] = false;
          .           #endif
          .           
          2 ( 0.00%)      _lns = 0;
          6 ( 0.00%)      if (ann) {
          .                 std::vector<AST::Node*> flatAnn;
          .                 if (ann->isArray()) {
          .                   flattenAnnotations(ann->getArray()  , flatAnn);
          .                 } else {
          .                   flatAnn.push_back(ann);
          .                 }
          .           
          .                 for (unsigned int i=0; i<flatAnn.size(); i++) {
-- line 1324 ----------------------------------------
-- line 1567 ----------------------------------------
          .                       err << "Warning, ignored search annotation: ";
          .                       flatAnn[i]->print(err);
          .                       err << std::endl;
          .                     }
          .                   }
          .                 }
          .               }
          .               // If relax and reconstruct is not set: Use default values set in storeConstraintInformation.:
          4 ( 0.00%)      if (_lns == 0){
          .                 iv_lns = iv_lns_default;
          6 ( 0.00%)        _lns = default_lns;
          .               }
          .           
          2 ( 0.00%)      int introduced = 0;
          2 ( 0.00%)      int funcdep = 0;
          2 ( 0.00%)      int searched = 0;
        232 ( 0.00%)      for (int i=iv.size(); i--;) {
        394 ( 0.00%)        if (iv_searched[i] || (_method != SAT && _optVarIsInt && _optVar==i)) {
          2 ( 0.00%)          searched++;
         84 ( 0.00%)        } else if (iv_introduced[2*i]) {
          .                   if (iv_introduced[2*i+1]) {
          .                     funcdep++;
          .                   } else {
          .                     introduced++;
          .                   }
          .                 }
          .               }
         16 ( 0.00%)      std::vector<std::string> iv_sol_names(iv.size()-(introduced+funcdep+searched));
      1,027 ( 0.00%)  => /usr/include/c++/11/bits/stl_vector.h:std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::vector(unsigned long, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&) [clone .constprop.2] (2x)
          4 ( 0.00%)      IntVarArgs iv_sol(iv.size()-(introduced+funcdep+searched));
         12 ( 0.00%)      std::vector<std::string> iv_tmp_names(introduced);
         40 ( 0.00%)  => /usr/include/c++/11/bits/stl_vector.h:std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::vector(unsigned long, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&) [clone .constprop.2] (2x)
          .               IntVarArgs iv_tmp(introduced);
        236 ( 0.00%)      for (int i=iv.size(), j=0, k=0; i--;) {
        396 ( 0.00%)        if (iv_searched[i] || (_method != SAT && _optVarIsInt && _optVar==i))
          .                   continue;
         84 ( 0.00%)        if (iv_introduced[2*i]) {
          .                   if (!iv_introduced[2*i+1]) {
          .                     iv_tmp_names[j] = p.intVarName(i);
          .                     iv_tmp[j++] = iv[i];
          .                   }
          .                 } else {
         42 ( 0.00%)          iv_sol_names[k] = p.intVarName(i);
        252 ( 0.00%)          iv_sol[k++] = iv[i];
          .                 }
          .               }
          .           
          2 ( 0.00%)      introduced = 0;
          .               funcdep = 0;
          .               searched = 0;
          8 ( 0.00%)      for (int i=bv.size(); i--;) {
          .                 if (bv_searched[i]) {
          .                   searched++;
          .                 } else if (bv_introduced[2*i]) {
          .                   if (bv_introduced[2*i+1]) {
          .                     funcdep++;
          .                   } else {
          .                     introduced++;
          .                   }
          .                 }
          .               }
         10 ( 0.00%)      std::vector<std::string> bv_sol_names(bv.size()-(introduced+funcdep+searched));
         40 ( 0.00%)  => /usr/include/c++/11/bits/stl_vector.h:std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::vector(unsigned long, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&) [clone .constprop.2] (2x)
          4 ( 0.00%)      BoolVarArgs bv_sol(bv.size()-(introduced+funcdep+searched));
          .               BoolVarArgs bv_tmp(introduced);
         10 ( 0.00%)      std::vector<std::string> bv_tmp_names(introduced);
         40 ( 0.00%)  => /usr/include/c++/11/bits/stl_vector.h:std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::vector(unsigned long, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&) [clone .constprop.2] (2x)
          6 ( 0.00%)      for (int i=bv.size(), j=0, k=0; i--;) {
          .                 if (bv_searched[i])
          .                   continue;
          .                 if (bv_introduced[2*i]) {
          .                   if (!bv_introduced[2*i+1]) {
          .                     bv_tmp_names[j] = p.boolVarName(i);
          .                     bv_tmp[j++] = bv[i];
          .                   }
          .                 } else {
          .                   bv_sol_names[k] = p.boolVarName(i);
          .                   bv_sol[k++] = bv[i];
          .                 }
          .               }
          .           
         10 ( 0.00%)      if (iv_sol.size() > 0 && bv_sol.size() > 0) {
          .                 branch(*this, iv_sol, bv_sol, def_intbool_varsel, def_int_valsel);
          .               } else if (iv_sol.size() > 0) {
          .                 BrancherGroup bg;
         32 ( 0.00%)        branch(bg(*this), iv_sol, def_int_varsel, def_int_valsel, nullptr,
     20,809 ( 0.00%)  => ???:0x00000000048669b0 (2x)
        532 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/tiebreak.hpp:Gecode::TieBreak<Gecode::IntVarBranch>::TieBreak(Gecode::TieBreak<Gecode::IntVarBranch> const&) (2x)
        288 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/tiebreak.hpp:Gecode::TieBreak<Gecode::IntVarBranch>::~TieBreak() (2x)
          .                        &varValPrint<IntVar>);
          .                 branchInfo.add(bg,def_int_rel_left,def_int_rel_right,iv_sol_names);
          .               } else if (bv_sol.size() > 0) {
          .                 BrancherGroup bg;
          .                 branch(bg(*this), bv_sol, def_bool_varsel, def_bool_valsel, nullptr,
          .                        &varValPrint<BoolVar>);
          .                 branchInfo.add(bg,def_bool_rel_left,def_bool_rel_right,bv_sol_names);
          .               }
          .           #ifdef GECODE_HAS_FLOAT_VARS
          4 ( 0.00%)      introduced = 0;
          .               funcdep = 0;
          .               searched = 0;
          8 ( 0.00%)      for (int i=fv.size(); i--;) {
          .                 if (fv_searched[i] || (_method != SAT && !_optVarIsInt && _optVar==i)) {
          .                   searched++;
          .                 } else if (fv_introduced[2*i]) {
          .                   if (fv_introduced[2*i+1]) {
          .                     funcdep++;
          .                   } else {
          .                     introduced++;
          .                   }
          .                 }
          .               }
         10 ( 0.00%)      std::vector<std::string> fv_sol_names(fv.size()-(introduced+funcdep+searched));
         40 ( 0.00%)  => /usr/include/c++/11/bits/stl_vector.h:std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::vector(unsigned long, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&) [clone .constprop.2] (2x)
          4 ( 0.00%)      FloatVarArgs fv_sol(fv.size()-(introduced+funcdep+searched));
          .               FloatVarArgs fv_tmp(introduced);
         10 ( 0.00%)      std::vector<std::string> fv_tmp_names(introduced);
         40 ( 0.00%)  => /usr/include/c++/11/bits/stl_vector.h:std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::vector(unsigned long, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&) [clone .constprop.2] (2x)
          8 ( 0.00%)      for (int i=fv.size(), j=0, k=0; i--;) {
          .                 if (fv_searched[i] || (_method != SAT && !_optVarIsInt && _optVar==i))
          .                   continue;
          .                 if (fv_introduced[2*i]) {
          .                   if (!fv_introduced[2*i+1]) {
          .                     fv_tmp_names[j] = p.floatVarName(i);
          .                     fv_tmp[j++] = fv[i];
          .                   }
          .                 } else {
          .                   fv_sol_names[k] = p.floatVarName(i);
          .                   fv_sol[k++] = fv[i];
          .                 }
          .               }
          .           
          6 ( 0.00%)      if (fv_sol.size() > 0) {
          .                 BrancherGroup bg;
          .                 branch(bg(*this), fv_sol, def_float_varsel, def_float_valsel, nullptr,
          .                        &varValPrintF);
          .                 branchInfo.add(bg,def_float_rel_left,def_float_rel_right,fv_sol_names);
          .               }
          .           #endif
          .           #ifdef GECODE_HAS_SET_VARS
          4 ( 0.00%)      introduced = 0;
          .               funcdep = 0;
          .               searched = 0;
          8 ( 0.00%)      for (int i=sv.size(); i--;) {
          .                 if (sv_searched[i]) {
          .                   searched++;
          .                 } else if (sv_introduced[2*i]) {
          .                   if (sv_introduced[2*i+1]) {
          .                     funcdep++;
          .                   } else {
          .                     introduced++;
          .                   }
          .                 }
          .               }
         10 ( 0.00%)      std::vector<std::string> sv_sol_names(sv.size()-(introduced+funcdep+searched));
         40 ( 0.00%)  => /usr/include/c++/11/bits/stl_vector.h:std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::vector(unsigned long, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&) [clone .constprop.2] (2x)
          4 ( 0.00%)      SetVarArgs sv_sol(sv.size()-(introduced+funcdep+searched));
          .               SetVarArgs sv_tmp(introduced);
         10 ( 0.00%)      std::vector<std::string> sv_tmp_names(introduced);
         40 ( 0.00%)  => /usr/include/c++/11/bits/stl_vector.h:std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::vector(unsigned long, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&) [clone .constprop.2] (2x)
          6 ( 0.00%)      for (int i=sv.size(), j=0, k=0; i--;) {
          .                 if (sv_searched[i])
          .                   continue;
          .                 if (sv_introduced[2*i]) {
          .                   if (!sv_introduced[2*i+1]) {
          .                     sv_tmp_names[j] = p.setVarName(i);
          .                     sv_tmp[j++] = sv[i];
          .                   }
          .                 } else {
          .                   sv_sol_names[k] = p.setVarName(i);
          .                   sv_sol[k++] = sv[i];
          .                 }
          .               }
          .           
          6 ( 0.00%)      if (sv_sol.size() > 0) {
          .                 BrancherGroup bg;
          .                 branch(bg(*this), sv_sol, def_set_varsel, def_set_valsel, nullptr,
          .                        &varValPrint<SetVar>);
          .                 branchInfo.add(bg,def_set_rel_left,def_set_rel_right,sv_sol_names);
          .           
          .               }
          .           #endif
          .               iv_aux = IntVarArray(*this, iv_tmp);
          .               bv_aux = BoolVarArray(*this, bv_tmp);
          2 ( 0.00%)      int n_aux = iv_aux.size() + bv_aux.size();
          .           #ifdef GECODE_HAS_SET_VARS
          .               sv_aux = SetVarArray(*this, sv_tmp);
          2 ( 0.00%)      n_aux += sv_aux.size();
          .           #endif
          .           #ifdef GECODE_HAS_FLOAT_VARS
          .               fv_aux = FloatVarArray(*this, fv_tmp);
          2 ( 0.00%)      n_aux += fv_aux.size();
          .           #endif
          .           
          4 ( 0.00%)      if (n_aux > 0) {
          2 ( 0.00%)        if (_method == SAT) {
          .                   AuxVarBrancher::post(*this, def_int_varsel, def_int_valsel,
          .                                        def_bool_varsel, def_bool_valsel
          .           #ifdef GECODE_HAS_SET_VARS
          .                                        , def_set_varsel, def_set_valsel
          .           #endif
          .           #ifdef GECODE_HAS_FLOAT_VARS
          .                                        , def_float_varsel, def_float_valsel
          .           #endif
-- line 1759 ----------------------------------------
-- line 1786 ----------------------------------------
          .                            &varValPrintF);
          .                     branchInfo.add(bg,def_float_rel_left,def_float_rel_right,fv_tmp_names);
          .                   }
          .             #endif
          .           
          .                 }
          .               }
          .           
          4 ( 0.00%)      if (_method == MIN) {
          4 ( 0.00%)        if (_optVarIsInt) {
          .                   std::vector<std::string> names(1);
          .                   names[0] = p.intVarName(_optVar);
          .                   BrancherGroup bg;
         16 ( 0.00%)          branch(bg(*this), iv[_optVar], INT_VAL_MIN(),
      3,622 ( 0.00%)  => ???:0x00000000048666f0 (2x)
          .                          &varValPrint<IntVar>);
         14 ( 0.00%)          branchInfo.add(bg,"=","!=",names);
        260 ( 0.00%)  => /usr/include/c++/11/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) [clone .constprop.0] (4x)
          .                 } else {
          .           #ifdef GECODE_HAS_FLOAT_VARS
          .                   std::vector<std::string> names(1);
          .                   names[0] = p.floatVarName(_optVar);
          .                   BrancherGroup bg;
          .                   branch(bg(*this), fv[_optVar], FLOAT_VAL_SPLIT_MIN(),
          .                          &varValPrintF);
          .                   branchInfo.add(bg,"<=",">",names);
-- line 1809 ----------------------------------------
-- line 1821 ----------------------------------------
          .           #ifdef GECODE_HAS_FLOAT_VARS
          .                   std::vector<std::string> names(1);
          .                   names[0] = p.floatVarName(_optVar);
          .                   BrancherGroup bg;
          .                   branch(bg(*this), fv[_optVar], FLOAT_VAL_SPLIT_MAX(),
          .                          &varValPrintF);
          .                   branchInfo.add(bg,"<=",">",names);
          .           #endif
          6 ( 0.00%)        }
      1,412 ( 0.00%)  => ???:0x0000000004866340 (2x)
          .               }
          .           
         70 ( 0.00%)    }
      5,754 ( 0.00%)  => ???:0x0000000004866340 (16x)
        288 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/tiebreak.hpp:Gecode::TieBreak<Gecode::IntVarBranch>::~TieBreak() (2x)
        288 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/tiebreak.hpp:Gecode::TieBreak<Gecode::BoolVarBranch>::~TieBreak() (2x)
        288 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/tiebreak.hpp:Gecode::TieBreak<Gecode::FloatVarBranch>::~TieBreak() (2x)
        212 ( 0.00%)  => ???:0x0000000004866040 (2x)
          .           
          .             AST::Array*
          4 ( 0.00%)    FlatZincSpace::solveAnnotations(void) const {
          4 ( 0.00%)      return _solveAnnotations;
          4 ( 0.00%)    }
          .           
          2 ( 0.00%)    void FlatZincSpace::setSolveAnnotations(AST::Array* solveAnnotations){
          2 ( 0.00%)      _solveAnnotations = solveAnnotations;
          2 ( 0.00%)    }
          .           
          .             void
          .             FlatZincSpace::solve(AST::Array* ann) {
          .               _method = SAT;
          .               _solveAnnotations = ann;
          .             }
          .           
          .             void
          1 ( 0.00%)    FlatZincSpace::minimize(int var, bool isInt, AST::Array* ann) {
          1 ( 0.00%)      _method = MIN;
          1 ( 0.00%)      _optVar = var;
          1 ( 0.00%)      _optVarIsInt = isInt;
          1 ( 0.00%)      _solveAnnotations = ann;
          1 ( 0.00%)    }
          .           
          .             void
          .             FlatZincSpace::maximize(int var, bool isInt, AST::Array* ann) {
          .               _method = MAX;
          .               _optVar = var;
          .               _optVarIsInt = isInt;
          .               _solveAnnotations = ann;
          .             }
          .           
104,209,898 ( 0.12%)    FlatZincSpace::~FlatZincSpace(void) {
 24,048,441 ( 0.03%)      delete _initData;
         99 ( 0.00%)  => ???:0x0000000004866220 (1x)
 24,048,438 ( 0.03%)      delete _solveAnnotations;
104,209,898 ( 0.12%)    }
3,134,387,355 ( 3.51%)  => ???:0x0000000004867320 (8,016,146x)
          .           
          .           #ifdef GECODE_HAS_GIST
          .           
          .             /**
          .              * \brief Traits class for search engines
          .              */
          .             template<class Engine>
          .             class GistEngine {
-- line 1876 ----------------------------------------
-- line 2220 ----------------------------------------
          .                 runEngine<BAB>(out,p,opt,t_total);
          .                 break;
          .               case SAT:
          .                 runEngine<DFS>(out,p,opt,t_total);
          .                 break;
          .               }
          .             }
          .           
         16 ( 0.00%)    void FlatZincSpace::runPBS(std::ostream& out, FlatZinc::Printer& p, FlatZincOptions& opt, Support::Timer& t_total, const int assets) {
          5 ( 0.00%)      PBSController pbs(this, assets, p);
      2,221 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/fzn-pbs.cpp:PBSController::PBSController(Gecode::FlatZinc::FlatZincSpace*, int, Gecode::FlatZinc::Printer&) (1x)
          4 ( 0.00%)      switch (_method) {
          .               case MIN:
          .               case MAX:
          6 ( 0.00%)        pbs.controller(out, opt, t_total);
    311,778 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/fzn-pbs.cpp:PBSController::controller(std::ostream&, Gecode::FlatZinc::FlatZincOptions&, Gecode::Support::Timer&) (1x)
          .                 break;
          .               case SAT:
          .                 // runEngine<DFS>(out,p,opt,t_total);
          .                 break;
          .               }
         12 ( 0.00%)    }
      4,293 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/fzn-pbs.cpp:PBSController::~PBSController() (1x)
          .           
          .             void
    122,910 ( 0.00%)    FlatZincSpace::constrain(const Space& s) {
          .               // If PBS, update global bounds.
          .               FlatZincSpace* best_sol = nullptr;
    102,425 ( 0.00%)      if (pbs_current_best_sol != nullptr){
          .                   best_sol = pbs_current_best_sol->load();
          .               }
          .           
     40,970 ( 0.00%)      if (_optVarIsInt) {
     40,970 ( 0.00%)        if (best_sol != nullptr){
     61,455 ( 0.00%)          if (_method == MIN){
     40,970 ( 0.00%)            rel(*this, iv[_optVar], IRT_LE, best_sol->iv[best_sol->optVar()].val());
    102,425 ( 0.00%)  => ???:0x0000000004866420 (20,485x)
          .                   }
          .                   else if (_method == MAX){
          .                     rel(*this, iv[_optVar], IRT_GR, best_sol->iv[best_sol->optVar()].val());
          .                   } 
          .                 }
          .                 // If not PBS or no solution has been found, update local bounds.
          .                 else{
          .                   if (_method == MIN){
    122,910 ( 0.00%)            rel(*this, iv[_optVar], IRT_LE, static_cast<const FlatZincSpace*>(&s)->iv[_optVar].val());
  1,333,455 ( 0.00%)  => ???:0x0000000004867000 (20,485x)
          .                   }
          .                   else if (_method == MAX){
          .                     rel(*this, iv[_optVar], IRT_GR, static_cast<const FlatZincSpace*>(&s)->iv[_optVar].val());
          .                   } 
          .                 }
          .               }
          .               else {
          .           #ifdef GECODE_HAS_FLOAT_VARS
-- line 2269 ----------------------------------------
-- line 2283 ----------------------------------------
          .                     
          .                   else if (_method == MAX){
          .                     rel(*this, fv[_optVar], FRT_GR, static_cast<const FlatZincSpace*>(&s)->fv[_optVar].val()+step);
          .                   }
          .                 }
          .           
          .           #endif
          .               }
    163,880 ( 0.00%)    }
          .           
          .             bool
    286,776 ( 0.00%)    FlatZincSpace::slave(const MetaInfo& mi) {
     61,452 ( 0.00%)      if (mi.type() == MetaInfo::RESTART) {
     40,968 ( 0.00%)        if (restart_data.initialized() && restart_data().mark_complete) {
          .                   // Fail the space
          .                   this->fail();
          .                   // Return true to signal we are in the global search space
          .                   return true;
          .                 }
          .           
     40,968 ( 0.00%)        bool ret = false;
     81,936 ( 0.00%)        if (on_restart_iv.size() > 0) {
          .                   int base = 0;
          .           
          .                   // Assign the sol_int values (use lb if no solution is known)
          .                   const FlatZincSpace* last = static_cast<const FlatZincSpace*>(mi.last());
          .                   assert(last == nullptr || last->on_restart_iv.size() == restart_data().on_restart_iv_sol);
          .                   for (int i = 0; i < restart_data().on_restart_iv_sol; ++i) {
          .                     IntVar& outVar = on_restart_iv[base + restart_data().on_restart_iv_sol + i];
          .                     int solVal = (last != nullptr) ? last->on_restart_iv[i].val() : on_restart_iv[base + i].min();
-- line 2312 ----------------------------------------
-- line 2357 ----------------------------------------
          .                   IntVarArray tmp(*this, restart_data().on_restart_iv_sol);
          .                   for (int i = 0; i < restart_data().on_restart_iv_sol; ++i) {
          .                     tmp[i] = on_restart_iv[i];
          .                   }
          .                   on_restart_iv = tmp;
          .           
          .                   ret = true;
          .                 }
     81,936 ( 0.00%)        if (on_restart_bv.size() > 0) {
          .                   int base = 0;
          .           
          .                   // Assign the sol_bool values (use lb if no solution is known)
          .                   const FlatZincSpace* last = static_cast<const FlatZincSpace*>(mi.last());
          .                   assert(last == nullptr || last->on_restart_bv.size() == restart_data().on_restart_bv_sol);
          .                   for (int i = 0; i < restart_data().on_restart_bv_sol; ++i) {
          .                     BoolVar& outVar = on_restart_bv[base + restart_data().on_restart_bv_sol + i];
          .                     int solVal = (last != nullptr) ? last->on_restart_bv[i].val() : on_restart_bv[base + i].min();
-- line 2373 ----------------------------------------
-- line 2387 ----------------------------------------
          .                   for (int i = 0; i < restart_data().on_restart_bv_sol; ++i) {
          .                     tmp[i] = on_restart_bv[i];
          .                   }
          .                   on_restart_bv = tmp;
          .           
          .                   ret = true;
          .                 }
          .           #ifdef GECODE_HAS_SET_VARS
     61,452 ( 0.00%)        if (on_restart_sv.size() > 0) {
          .                   int base = 0;
          .           
          .                   // Assign the sol_set values (use lb if no solution is known)
          .                   const FlatZincSpace* last = static_cast<const FlatZincSpace*>(mi.last());
          .                   assert(last == nullptr || last->on_restart_sv.size() == restart_data().on_restart_sv_sol);
          .                   for (int i = 0; i < restart_data().on_restart_sv_sol; ++i) {
          .                     SetVar& outVar = on_restart_sv[base + restart_data().on_restart_sv_sol + i];
          .                     Set::GlbRanges<Set::SetView> lb(last != nullptr ? last->on_restart_sv[i] : on_restart_sv[base + i]);
-- line 2403 ----------------------------------------
-- line 2419 ----------------------------------------
          .                     tmp[i] = on_restart_sv[i];
          .                   }
          .                   on_restart_sv = tmp;
          .           
          .                   ret = true;
          .                 }
          .           #endif
          .           #ifdef GECODE_HAS_FLOAT_VARS
     61,452 ( 0.00%)        if (on_restart_fv.size() > 0) {
          .                   int base = 0;
          .           
          .                   // Assign the sol_float values (use lb if no solution is known)
          .                   const FlatZincSpace* last = static_cast<const FlatZincSpace*>(mi.last());
          .                   assert(last == nullptr || last->on_restart_fv.size() == restart_data().on_restart_fv_sol);
          .                   for (int i = 0; i < restart_data().on_restart_fv_sol; ++i) {
          .                     FloatVar& outVar = on_restart_fv[base + restart_data().on_restart_fv_sol + i];
          .                     FloatVal solVal = (last != nullptr) ? last->on_restart_fv[i].val() : on_restart_fv[base + i].min();
-- line 2435 ----------------------------------------
-- line 2458 ----------------------------------------
          .                   for (int i = 0; i < restart_data().on_restart_fv_sol; ++i) {
          .                     tmp[i] = on_restart_fv[i];
          .                   }
          .                   on_restart_fv = tmp;
          .           
          .                   ret = true;
          .                 }
          .           #endif
     61,452 ( 0.00%)        if (ret) {
          .                   return false;
          .                 }
          .               }
          .           
          .               // Depending on the type of LNS, apply it and return false.
    143,388 ( 0.00%)      switch (_lnsType) {
          .                 case RANDOM:
          .                 {
          .                   // cerr << "Random LNS" << endl;
    573,552 ( 0.00%)          return _lnsStrategy.randomLNS(*this, mi, _lnsInitialSolution, _lns, iv_lns, _random);
 40,012,872 ( 0.04%)  => /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/lnsstrategies.cpp:LNStrategies::randomLNS(Gecode::FlatZinc::FlatZincSpace&, Gecode::MetaInfo, Gecode::SharedArray<int>&, unsigned int, Gecode::IntVarArgs, Gecode::Rnd) (20,484x)
    184,356 ( 0.00%)  => ???:0x0000000004867f60 (20,484x)
    184,356 ( 0.00%)  => ???:0x0000000004866040 (20,484x)
          .                 }
          .                 case PG:
          .                 {
          .                   return _lnsStrategy.pgLNS(*this, mi, iv, num_non_introduced_vars, _random);
          .                 }
          .                 case rPG:
          .                 {
          .                   return _lnsStrategy.revpgLNS(*this, mi, iv, num_non_introduced_vars, _random);
-- line 2484 ----------------------------------------
-- line 2487 ----------------------------------------
          .                 {
          .                   return _lnsStrategy.afcLNS(*this, mi, iv);
          .                 }
          .                 default:
          .                 {
          .                   return true;
          .                 }
          .               }
    245,808 ( 0.00%)    }
          .           
          .             Space*
 40,080,770 ( 0.04%)    FlatZincSpace::copy(void) {
 32,064,616 ( 0.04%)      return new FlatZincSpace(*this);
27,889,079,112 (31.19%)  => ???:0x0000000004866440 (8,016,154x)
 40,080,770 ( 0.04%)    }
          .           
          .             FlatZincSpace::Meth
          1 ( 0.00%)    FlatZincSpace::method(void) const {
          1 ( 0.00%)      return _method;
          1 ( 0.00%)    }
          .           
          .             int
     20,489 ( 0.00%)    FlatZincSpace::optVar(void) const {
     20,489 ( 0.00%)      return _optVar;
     20,489 ( 0.00%)    }
          .           
          .             bool
          .             FlatZincSpace::optVarIsInt(void) const {
          .               return _optVarIsInt;
          .             }
          .           
          .             void
          3 ( 0.00%)    FlatZincSpace::print(std::ostream& out, const Printer& p) const {
          5 ( 0.00%)      p.print(out, iv, bv
    115,556 ( 0.00%)  => ???:0x0000000004867ed0 (1x)
          .           #ifdef GECODE_HAS_SET_VARS
          .               , sv
          .           #endif
          .           #ifdef GECODE_HAS_FLOAT_VARS
          .               , fv
          .           #endif
          .               );
          .             }
-- line 2527 ----------------------------------------
-- line 2587 ----------------------------------------
          .           #endif
          .           #ifdef GECODE_HAS_FLOAT_VARS
          .               , fv
          .           #endif
          .               );
          .             }
          .           
          .             IntArgs
         28 ( 0.00%)    FlatZincSpace::arg2intargs(AST::Node* arg, int offset) {
          .               AST::Array* a = arg->getArray();
          2 ( 0.00%)      IntArgs ia(a->a.size()+offset);
          6 ( 0.00%)      for (int i=offset; i--;)
          .                 ia[i] = 0;
        144 ( 0.00%)      for (int i=a->a.size(); i--;)
         58 ( 0.00%)        ia[i+offset] = a->a[i]->getInt();
          .               return ia;
         24 ( 0.00%)    }
          .             TupleSet
          .             FlatZincSpace::arg2tupleset(const IntArgs& a, int noOfVars) {
          .               int noOfTuples = a.size() == 0 ? 0 : (a.size()/noOfVars);
          .           
          .               // Build TupleSet
          .               TupleSet ts(noOfVars);
          .               for (int i=0; i<noOfTuples; i++) {
          .                 IntArgs t(noOfVars);
-- line 2611 ----------------------------------------
-- line 2691 ----------------------------------------
          .               for (int i=offset; i--;)
          .                 ia[i] = IntSet::empty;
          .               for (int i=a->a.size(); i--;) {
          .                 ia[i+offset] = arg2intset(a->a[i]);
          .               }
          .               return ia;
          .             }
          .             IntVarArgs
         60 ( 0.00%)    FlatZincSpace::arg2intvarargs(AST::Node* arg, int offset) {
          .               AST::Array* a = arg->getArray();
          8 ( 0.00%)      if (a->a.size() == 0) {
          .                 IntVarArgs emptyIa(0);
          .                 return emptyIa;
          .               }
          4 ( 0.00%)      IntVarArgs ia(a->a.size()+offset);
         20 ( 0.00%)      for (int i=offset; i--;)
          .                 ia[i] = IntVar(*this, 0, 0);
        145 ( 0.00%)      for (int i=a->a.size(); i--;) {
        129 ( 0.00%)        if (a->a[i]->isIntVar()) {
        172 ( 0.00%)          ia[i+offset] = iv[a->a[i]->getIntVar()];
          .                 } else {
          .                   int value = a->a[i]->getInt();
         20 ( 0.00%)          IntVar iv(*this, value, value);
          .                   ia[i+offset] = iv;
          .                 }
          .               }
          .               return ia;
         48 ( 0.00%)    }
          .             BoolVarArgs
          .             FlatZincSpace::arg2boolvarargs(AST::Node* arg, int offset, int siv) {
          .               AST::Array* a = arg->getArray();
          .               if (a->a.size() == 0) {
          .                 BoolVarArgs emptyIa(0);
          .                 return emptyIa;
          .               }
          .               BoolVarArgs ia(a->a.size()+offset-(siv==-1?0:1));
-- line 2726 ----------------------------------------
-- line 2759 ----------------------------------------
          .               if (n->isIntVar()) {
          .                 x0 = iv[n->getIntVar()];
          .               } else {
          .                 x0 = IntVar(*this, n->getInt(), n->getInt());
          .               }
          .               return x0;
          .             }
          .             bool
         30 ( 0.00%)    FlatZincSpace::isBoolArray(AST::Node* b, int& singleInt) {
          .               AST::Array* a = b->getArray();
          2 ( 0.00%)      singleInt = -1;
          4 ( 0.00%)      if (a->a.size() == 0)
          .                 return true;
         20 ( 0.00%)      for (int i=a->a.size(); i--;) {
         20 ( 0.00%)        if (a->a[i]->isBoolVar() || a->a[i]->isBool()) {
          8 ( 0.00%)        } else if (a->a[i]->isIntVar()) {
         20 ( 0.00%)          if (aliasBool2Int(a->a[i]->getIntVar()) == -1) {
        983 ( 0.00%)  => ???:0x0000000004866f50 (4x)
         12 ( 0.00%)            if (singleInt != -1) {
          .                       return false;
          .                     }
          2 ( 0.00%)            singleInt = i;
          .                   }
          .                 } else {
          4 ( 0.00%)          return false;
          .                 }
          .               }
          .               return singleInt==-1 || a->a.size() > 1;
         22 ( 0.00%)    }
          .           #ifdef GECODE_HAS_SET_VARS
          .             SetVar
          .             FlatZincSpace::arg2SetVar(AST::Node* n) {
          .               SetVar x0;
          .               if (!n->isSetVar()) {
          .                 IntSet d = arg2intset(n);
          .                 x0 = SetVar(*this, d, d);
          .               } else {
-- line 2794 ----------------------------------------
-- line 2850 ----------------------------------------
          .                 x0 = fv[n->getFloatVar()];
          .               } else {
          .                 x0 = FloatVar(*this, n->getFloat(), n->getFloat());
          .               }
          .               return x0;
          .             }
          .           #endif
          .             IntPropLevel
         44 ( 0.00%)    FlatZincSpace::ann2ipl(AST::Node* ann) {
          9 ( 0.00%)      if (ann) {
         15 ( 0.00%)        if (ann->hasAtom("val") || ann->hasAtom("value_propagation"))
        676 ( 0.00%)  => ???:0x0000000004867080 (2x)
        148 ( 0.00%)  => /usr/include/c++/11/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) [clone .constprop.0] (1x)
          1 ( 0.00%)          return IPL_VAL;
         17 ( 0.00%)        if (ann->hasAtom("domain") || ann->hasAtom("domain_propagation"))
        676 ( 0.00%)  => ???:0x0000000004867080 (2x)
        224 ( 0.00%)  => /usr/include/c++/11/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) [clone .constprop.0] (2x)
          .                   return IPL_DOM;
         10 ( 0.00%)        if (ann->hasAtom("bounds") ||
        338 ( 0.00%)  => ???:0x0000000004867080 (1x)
         76 ( 0.00%)  => /usr/include/c++/11/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) [clone .constprop.0] (1x)
          9 ( 0.00%)            ann->hasAtom("bounds_propagation") ||
        338 ( 0.00%)  => ???:0x0000000004867080 (1x)
        148 ( 0.00%)  => /usr/include/c++/11/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) [clone .constprop.0] (1x)
         10 ( 0.00%)            ann->hasAtom("boundsR") ||
        338 ( 0.00%)  => ???:0x0000000004867080 (1x)
         76 ( 0.00%)  => /usr/include/c++/11/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) [clone .constprop.0] (1x)
         10 ( 0.00%)            ann->hasAtom("boundsD") ||
        338 ( 0.00%)  => ???:0x0000000004867080 (1x)
         76 ( 0.00%)  => /usr/include/c++/11/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) [clone .constprop.0] (1x)
          8 ( 0.00%)            ann->hasAtom("boundsZ"))
        338 ( 0.00%)  => ???:0x0000000004867080 (1x)
         76 ( 0.00%)  => /usr/include/c++/11/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) [clone .constprop.0] (1x)
          .                   return IPL_BND;
          .               }
          6 ( 0.00%)      return IPL_DEF;
         48 ( 0.00%)    }
          .           
          .             DFA
          .             FlatZincSpace::getSharedDFA(DFA& a) {
          .               if (_initData) {
          .                 FlatZincSpaceInitData::DFASet::iterator it = _initData->dfaSet.find(a);
          .                 if (it != _initData->dfaSet.end()) {
          .                   return *it;
          .                 }
          .                 _initData->dfaSet.insert(a);
          .               }
          .               return a;
          .             }
          .           
          .             void
          1 ( 0.00%)    Printer::init(AST::Array* output) {
          1 ( 0.00%)      _output = output;
          1 ( 0.00%)    }
          .           
          .             void
          .             Printer::printElem(std::ostream& out,
          .                                  AST::Node* ai,
          .                                  const Gecode::IntVarArray& iv,
          .                                  const Gecode::BoolVarArray& bv
          .           #ifdef GECODE_HAS_SET_VARS
          .                                  , const Gecode::SetVarArray& sv
          .           #endif
          .           #ifdef GECODE_HAS_FLOAT_VARS
          .                                  ,
          .                                  const Gecode::FloatVarArray& fv
          .           #endif
        648 ( 0.00%)                         ) const {
          .               int k;
          .               if (ai->isInt(k)) {
          .                 out << k;
         72 ( 0.00%)      } else if (ai->isIntVar()) {
         44 ( 0.00%)        out << iv[ai->getIntVar()];
      3,438 ( 0.00%)  => ???:0x0000000004866780 (22x)
         28 ( 0.00%)      } else if (ai->isBoolVar()) {
          .                 if (bv[ai->getBoolVar()].min() == 1) {
          .                   out << "true";
          .                 } else if (bv[ai->getBoolVar()].max() == 0) {
          .                   out << "false";
          .                 } else {
          .                   out << "false..true";
          .                 }
          .           #ifdef GECODE_HAS_SET_VARS
         28 ( 0.00%)      } else if (ai->isSetVar()) {
          .                 if (!sv[ai->getSetVar()].assigned()) {
          .                   out << sv[ai->getSetVar()];
          .                   return;
          .                 }
          .                 SetVarGlbRanges svr(sv[ai->getSetVar()]);
          .                 if (!svr()) {
          .                   out << "{}";
          .                   return;
-- line 2926 ----------------------------------------
-- line 2936 ----------------------------------------
          .                   for (; svv(); ++svv)
          .                     out << ", " << svv.val();
          .                   out << "}";
          .                 } else {
          .                   out << min << ".." << max;
          .                 }
          .           #endif
          .           #ifdef GECODE_HAS_FLOAT_VARS
         28 ( 0.00%)      } else if (ai->isFloatVar()) {
          .                 if (fv[ai->getFloatVar()].assigned()) {
          .                   FloatVal vv = fv[ai->getFloatVar()].val();
          .                   FloatNum v;
          .                   if (vv.singleton())
          .                     v = vv.min();
          .                   else if (vv < 0.0)
          .                     v = vv.max();
          .                   else
-- line 2952 ----------------------------------------
-- line 2957 ----------------------------------------
          .                   oss << v;
          .                   if (oss.str().find(".") == std::string::npos)
          .                     oss << ".0";
          .                   out << oss.str();
          .                 } else {
          .                   out << fv[ai->getFloatVar()];
          .                 }
          .           #endif
         28 ( 0.00%)      } else if (ai->isBool()) {
          .                 out << (ai->getBool() ? "true" : "false");
         28 ( 0.00%)      } else if (ai->isSet()) {
          .                 AST::SetLit* s = ai->getSet();
          .                 if (s->interval) {
          .                   out << s->min << ".." << s->max;
          .                 } else {
          .                   out << "{";
          .                   for (unsigned int i=0; i<s->s.size(); i++) {
          .                     out << s->s[i] << (i < s->s.size()-1 ? ", " : "}");
          .                   }
          .                 }
         28 ( 0.00%)      } else if (ai->isString()) {
         56 ( 0.00%)        std::string s = ai->getString();
      3,136 ( 0.00%)  => ???:0x0000000004866cb0 (14x)
        340 ( 0.00%)        for (unsigned int i=0; i<s.size(); i++) {
        213 ( 0.00%)          if (s[i] == '\\' && i<s.size()-1) {
          .                     switch (s[i+1]) {
          .                     case 'n': out << "\n"; break;
          .                     case '\\': out << "\\"; break;
         14 ( 0.00%)            case 't': out << "\t"; break;
          .                     default: out << "\\" << s[i+1];
          .                     }
          .                     i++;
          .                   } else {
          .                     out << s[i];
          .                   }
          .                 }
          .               }
        396 ( 0.00%)    }
          .           
          .             void
          .             Printer::printElemDiff(std::ostream& out,
          .                                  AST::Node* ai,
          .                                  const Gecode::IntVarArray& iv1,
          .                                  const Gecode::IntVarArray& iv2,
          .                                  const Gecode::BoolVarArray& bv1,
          .                                  const Gecode::BoolVarArray& bv2
-- line 3001 ----------------------------------------
-- line 3107 ----------------------------------------
          .           #ifdef GECODE_HAS_SET_VARS
          .                              ,
          .                              const Gecode::SetVarArray& sv
          .           #endif
          .           #ifdef GECODE_HAS_FLOAT_VARS
          .                              ,
          .                              const Gecode::FloatVarArray& fv
          .           #endif
         11 ( 0.00%)                     ) const {
          4 ( 0.00%)      if (_output == nullptr){
          .                 out << "No output" << endl;
          .                 return;
          .               }
          .                 
         95 ( 0.00%)      for (unsigned int i=0; i< _output->a.size(); i++) {
         18 ( 0.00%)        AST::Node* ai = _output->a[i];
         36 ( 0.00%)        if (ai->isArray()) {
          .                   AST::Array* aia = ai->getArray();
          3 ( 0.00%)          int size = aia->a.size();
          .                   out << "[";
        150 ( 0.00%)          for (int j=0; j<size; j++) {
        210 ( 0.00%)            printElem(out,aia->a[j],iv,bv
     50,421 ( 0.00%)  => ???:0x0000000004867990 (21x)
          .           #ifdef GECODE_HAS_SET_VARS
          .                     ,sv
          .           #endif
          .           #ifdef GECODE_HAS_FLOAT_VARS
          .                     ,fv
          .           #endif
          .                     );
         21 ( 0.00%)            if (j<size-1)
          .                       out << ", ";
          .                   }
          .                   out << "]";
          .                 } else {
        165 ( 0.00%)          printElem(out,ai,iv,bv
     53,538 ( 0.00%)  => ???:0x0000000004867990 (15x)
          .           #ifdef GECODE_HAS_SET_VARS
          .                   ,sv
          .           #endif
          .           #ifdef GECODE_HAS_FLOAT_VARS
          .                     ,fv
          .           #endif
          .                   );
          .                 }
          .               }
          8 ( 0.00%)    }
          .           
          .             void
          .             Printer::printDiff(std::ostream& out,
          .                              const Gecode::IntVarArray& iv1,
          .                              const Gecode::IntVarArray& iv2,
          .                              const Gecode::BoolVarArray& bv1,
          .                              const Gecode::BoolVarArray& bv2
          .           #ifdef GECODE_HAS_SET_VARS
-- line 3159 ----------------------------------------
-- line 3197 ----------------------------------------
          .                       ,fv1,fv2
          .           #endif
          .                   );
          .                 }
          .               }
          .             }
          .           
          .             void
        220 ( 0.00%)    Printer::addIntVarName(const std::string& n) {
          .               iv_names.push_back(n);
        174 ( 0.00%)    }
          .             void
          .             Printer::addBoolVarName(const std::string& n) {
          .               bv_names.push_back(n);
          .             }
          .           #ifdef GECODE_HAS_FLOAT_VARS
          .             void
          .             Printer::addFloatVarName(const std::string& n) {
          .               fv_names.push_back(n);
-- line 3215 ----------------------------------------
-- line 3357 ----------------------------------------
          .                 fva[(*i).second] = fv[(*i).first];
          .                 fv_names_new[(*i).second] = fv_names[(*i).first];
          .               }
          .               fv = FloatVarArray(home, fva);
          .               fv_names = fv_names_new;
          .           #endif
          .             }
          .           
          7 ( 0.00%)    Printer::~Printer(void) {
          7 ( 0.00%)      delete _output;
          5 ( 0.00%)    }
          .           
          7 ( 0.00%)  }}
          .           
          .           // STATISTICS: flatzinc-any

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/view.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 469 ----------------------------------------
          .           
          .             /*
          .              * Variable view: contains a pointer to a variable implementation
          .              *
          .              */
          .             template<class Var>
          .             forceinline
          .             VarImpView<Var>::VarImpView(void)
185,370,226 ( 0.21%)      : x(nullptr) {}
         14 ( 0.00%)  => ???:0x0000000004e951f0 (1x)
          .             template<class Var>
          .             forceinline
          .             VarImpView<Var>::VarImpView(VarImpType* y)
         22 ( 0.00%)      : x(y) {}
          .             template<class Var>
          .             forceinline void
          .             VarImpView<Var>::varimp(VarImpType* y) {
          .               x=y;
          .             }
          .             template<class Var>
          .             forceinline bool
          .             VarImpView<Var>::varderived(void) {
          .               return true;
          .             }
          .             template<class Var>
          .             forceinline typename Var::VarImpType*
          .             VarImpView<Var>::varimp(void) const {
          3 ( 0.00%)      return x;
          .             }
          .            template<class Var>
          .             forceinline unsigned int
          .             VarImpView<Var>::degree(void) const {
          .               return x->degree();
          .             }
          .             template<class Var>
          .             forceinline double
-- line 503 ----------------------------------------
-- line 509 ----------------------------------------
          .             forceinline unsigned int
          .             VarImpView<Var>::id(void) const {
          .               return x->id();
          .             }
          .           #endif
          .             template<class Var>
          .             forceinline bool
          .             VarImpView<Var>::assigned(void) const {
279,944,986 ( 0.31%)      return x->assigned();
          .             }
          .             template<class Var>
          .             forceinline void
          .             VarImpView<Var>::subscribe(Space& home, Propagator& p, PropCond pc,
          .                                        bool schedule) {
    604,150 ( 0.00%)      x->subscribe(home,p,pc,schedule);
      3,848 ( 0.00%)  => ???:0x0000000004e95700 (7x)
          .             }
          .             template<class Var>
          .             forceinline void
          .             VarImpView<Var>::cancel(Space& home, Propagator& p, PropCond pc) {
 20,012,824 ( 0.02%)      x->cancel(home,p,pc);
          .             }
          .             template<class Var>
          .             forceinline void
          .             VarImpView<Var>::reschedule(Space& home, Propagator& p, PropCond pc) {
          .               x->reschedule(home,p,pc);
          .             }
          .             template<class Var>
          .             forceinline void
-- line 536 ----------------------------------------
-- line 560 ----------------------------------------
          .             template<class Var>
          .             forceinline ModEvent
          .             VarImpView<Var>::modevent(const Delta& d) {
          .               return VarImpType::modevent(d);
          .             }
          .             template<class Var>
          .             forceinline void
          .             VarImpView<Var>::update(Space& home, VarImpView<Var>& y) {
725,507,848 ( 0.81%)      x = y.x->copy(home);
          .             }
          .             template<class Var>
          .             forceinline bool
          .             VarImpView<Var>::operator <(const VarImpView<Var>& y) const {
          .               return this->varimp() < y.varimp();
          .             }
          .           
          .           
-- line 576 ----------------------------------------
-- line 581 ----------------------------------------
          .           
          .             template<class View>
          .             forceinline
          .             DerivedView<View>::DerivedView(void) {}
          .           
          .             template<class View>
          .             forceinline
          .             DerivedView<View>::DerivedView(const View& y)
         29 ( 0.00%)      : x(y) {}
          .           
          .             template<class View>
          .             forceinline bool
          .             DerivedView<View>::varderived(void) {
          .               return View::varderived();
          .             }
          .           
          .             template<class View>
-- line 597 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/int/distinct/bnd.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 31 ----------------------------------------
          .            *
          .            */
          .           
          .           namespace Gecode { namespace Int { namespace Distinct {
          .           
          .             template<class View>
          .             forceinline
          .             Bnd<View>::Bnd(Home home, ViewArray<View>& x0)
          2 ( 0.00%)      : Propagator(home), x(x0), y(home,x0) {
          .               // Both x and y initially contain the same variables
          .               //  - x is used for bounds propagation
          .               //  - y is used for performing singleton propagation
          .               // They can not be shared as singleton propagation removes
          .               // determined variables still required for bounds propagation.
          .               y.subscribe(home,*this,PC_INT_BND);
          .               int min = x[0].min(), max = x[0].max();
         27 ( 0.00%)      for (int i=1; i<x.size(); i++) {
          .                 min = std::min(min,x[i].min());
          .                 max = std::max(max,x[i].max());
          .               }
          1 ( 0.00%)      min_x = min; max_x = max;
          .             }
          .           
          .             template<class View>
          .             forceinline size_t
          .             Bnd<View>::dispose(Space& home) {
          .               y.cancel(home,*this,PC_INT_BND);
          .               (void) Propagator::dispose(home);
          .               return sizeof(*this);
          .             }
          .           
          .             template<class View>
          .             forceinline
          .             Bnd<View>::Bnd(Space& home, Bnd<View>& p)
 16,516,452 ( 0.02%)      : Propagator(home,p), min_x(p.min_x), max_x(p.max_x) {
  8,258,226 ( 0.01%)      x.update(home,p.x);
1,768,824,113 ( 1.98%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/data/array.hpp:Gecode::ViewArray<Gecode::Int::IntView>::update(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&) (2,752,742x)
 11,010,968 ( 0.01%)      y.update(home,p.y);
314,954,294 ( 0.35%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/data/array.hpp:Gecode::ViewArray<Gecode::Int::IntView>::update(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&) (2,752,742x)
          .             }
          .           
          .             template<class View>
          .             Actor*
 22,021,936 ( 0.02%)    Bnd<View>::copy(Space& home) {
          .               return new (home) Bnd<View>(home,*this);
 19,269,194 ( 0.02%)    }
          .           
          .             template<class View>
          .             PropCost
 15,251,792 ( 0.02%)    Bnd<View>::cost(const Space&, const ModEventDelta& med) const {
 30,503,584 ( 0.03%)      if (View::me(med) == ME_INT_VAL)
          .                 return PropCost::linear(PropCost::LO, y.size());
          .               else
          .                 return PropCost::quadratic(PropCost::LO, x.size());
  9,452,456 ( 0.01%)    }
          .           
          .             template<class View>
          .             void
          .             Bnd<View>::reschedule(Space& home) {
          .               y.reschedule(home,*this,PC_INT_BND);
          .             }
          .           
          .           
-- line 91 ----------------------------------------
-- line 140 ----------------------------------------
          .               IntType bounds, t, d, h;
          .             };
          .           
          .             template<class IntType>
          .             forceinline void
          .             pathset_t(HallInfo<IntType> hall[],
          .                       IntType start, IntType end, IntType to) {
          .               IntType k, l;
372,015,390 ( 0.42%)      for (l=start; (k=l) != end; hall[k].t=to) {
286,735,120 ( 0.32%)        l = hall[k].t;
          .               }
          .             }
          .           
          .             template<class IntType>
          .             forceinline void
          .             pathset_h(HallInfo<IntType> hall[],
          .                       IntType start, IntType end, IntType to) {
          .               IntType k, l;
152,023,424 ( 0.17%)      for (l=start; (k=l) != end; hall[k].h=to) {
 88,169,835 ( 0.10%)        l = hall[k].h;
          .               }
          .             }
          .           
          .             template<class IntType>
          .             forceinline IntType
          .             pathmin_h(const HallInfo<IntType> hall[], IntType i) {
          .               while (hall[i].h < i)
          .                 i = hall[i].h;
          .               return i;
          .             }
          .           
          .             template<class IntType>
          .             forceinline IntType
          .             pathmin_t(const HallInfo<IntType> hall[], IntType i) {
399,476,189 ( 0.45%)      while (hall[i].t < i)
          .                 i = hall[i].t;
          .               return i;
          .             }
          .           
          .             template<class IntType>
          .             forceinline IntType
          .             pathmax_h(const HallInfo<IntType> hall[], IntType i) {
  7,285,838 ( 0.01%)      while (hall[i].h > i)
          .                 i = hall[i].h;
          .               return i;
          .             }
          .           
          .             template<class IntType>
          .             forceinline IntType
 20,819,930 ( 0.02%)    pathmax_t(const HallInfo<IntType> hall[], IntType i) {
516,446,028 ( 0.58%)      while (hall[i].t > i)
          .                 i = hall[i].t;
          .               return i;
          .             }
          .           
          .             template<class View, class IntType>
          .             forceinline ExecStatus
          .             prop_bnd(Space& home, ViewArray<View>& x,
          .                      int* minsorted, int* maxsorted) {
          .               const int n = x.size();
          .           
          .               Region r;
          .           
          .               // Setup rank and bounds info
  9,786,118 ( 0.01%)      HallInfo<IntType>* hall = r.alloc<HallInfo<IntType> >(2*n+2);
          .               Rank* rank = r.alloc<Rank>(n);
          .           
  4,893,059 ( 0.01%)      int nb = 0;
          .               {
          .                 IntType min  = x[minsorted[0]].min();
 14,679,177 ( 0.02%)        IntType max  = x[maxsorted[0]].max() + 1;
  4,893,059 ( 0.01%)        IntType last = min - 2;
          .           
  4,893,059 ( 0.01%)        hall[0].bounds = last;
          .           
  4,893,059 ( 0.01%)        int i = 0;
  4,893,059 ( 0.01%)        int j = 0;
          .                 while (true) {
236,737,328 ( 0.26%)          if ((i < n) && (min < max)) {
 68,475,534 ( 0.08%)            if (min != last)
242,019,903 ( 0.27%)              hall[++nb].bounds = last = min;
239,664,369 ( 0.27%)            rank[minsorted[i]].min = nb;
102,713,301 ( 0.11%)            if (++i < n)
          .                       min = x[minsorted[i]].min();
          .                   } else {
 68,475,534 ( 0.08%)            if (max != last)
 54,505,308 ( 0.06%)              hall[++nb].bounds = last = max;
205,426,602 ( 0.23%)            rank[maxsorted[j]].max = nb;
102,713,301 ( 0.11%)            if (++j == n)
          .                       break;
117,378,832 ( 0.13%)            max = x[maxsorted[j]].max() + 1;
          .                   }
          .                 }
 44,037,531 ( 0.05%)        hall[nb+1].bounds = hall[nb].bounds + 2;
          .               }
          .           
          .               // If tells cross holes, we do not compute a fixpoint
 24,465,295 ( 0.03%)      ExecStatus es = ES_FIX;
          .           
          .               // Propagate lower bounds
190,975,487 ( 0.21%)      for (int i=nb+2; --i;) {
 70,518,524 ( 0.08%)        hall[i].t = hall[i].h = i-1;
105,777,786 ( 0.12%)        hall[i].d = hall[i].bounds - hall[i-1].bounds;
          .               }
143,930,700 ( 0.16%)      for (int i=0; i<n; i++) { // visit intervals in increasing max order
160,585,690 ( 0.18%)        IntType x0 = rank[maxsorted[i]].min;
 96,351,414 ( 0.11%)        IntType z = pathmax_t(hall, x0+1);
          .                 IntType j = hall[z].t;
 85,054,206 ( 0.10%)        if (--hall[z].d == 0)
 62,459,790 ( 0.07%)          hall[z = pathmax_t(hall, hall[z].t=z+1)].t = j;
          .                 pathset_t(hall, x0+1, z, z); // path compression
160,585,690 ( 0.18%)        IntType y = rank[maxsorted[i]].max;
289,054,242 ( 0.32%)        if (hall[z].d < hall[z].bounds-hall[y].bounds)
  1,027,522 ( 0.00%)          return ES_FAILED;
186,537,696 ( 0.21%)        if (hall[x0].h > x0) {
          .                   IntType w = pathmax_h(hall, hall[x0].h);
  2,157,411 ( 0.00%)          IntType m = hall[w].bounds;
          .                   ModEvent me = x[maxsorted[i]].gq(home,m);
  1,438,274 ( 0.00%)          if (me_failed(me))
          .                     return ES_FAILED;
  2,248,046 ( 0.00%)          if ((me == ME_INT_VAL) ||
          .                       ((me == ME_INT_BND) && (m != x[maxsorted[i]].min())))
  3,057,818 ( 0.00%)            es = ES_NOFIX;
          .                   pathset_h(hall, x0, w, w); // path compression
          .                 }
 65,055,780 ( 0.07%)        if (hall[z].d == hall[z].bounds-hall[y].bounds) {
 52,162,460 ( 0.06%)          pathset_h(hall, hall[y].h, j-1, y); // mark hall interval
 39,121,845 ( 0.04%)          hall[y].h = j-1;
          .                 }
          .               }
          .           
          .               // Propagate upper bounds
126,583,460 ( 0.14%)      for (int i=nb+1; i--;) {
138,901,640 ( 0.16%)        hall[i].t = hall[i].h = i+1;
 55,560,656 ( 0.06%)        hall[i].d = hall[i+1].bounds - hall[i].bounds;
          .               }
100,463,024 ( 0.11%)      for (int i=n; --i>=0; ) { // visit intervals in decreasing min order
135,225,565 ( 0.15%)        IntType x0 = rank[minsorted[i]].max;
 81,135,339 ( 0.09%)        IntType z = pathmin_t(hall, x0-1);
          .                 IntType j = hall[z].t;
 71,190,707 ( 0.08%)        if (--hall[z].d == 0)
 51,301,443 ( 0.06%)          hall[z = pathmin_t(hall, hall[z].t=z-1)].t = j;
          .                 pathset_t(hall, x0-1, z, z);
135,225,565 ( 0.15%)        IntType y = rank[minsorted[i]].min;
216,360,904 ( 0.24%)        if (hall[z].d < hall[y].bounds-hall[z].bounds)
          .                   return ES_FAILED;
189,315,791 ( 0.21%)        if (hall[x0].h < x0) {
          .                   IntType w = pathmin_h(hall, hall[x0].h);
          .                   IntType m = hall[w].bounds - 1;
          .                   ModEvent me = x[minsorted[i]].lq(home,m);
          .                   if (me_failed(me))
          .                     return ES_FAILED;
          .                   if ((me == ME_INT_VAL) ||
          .                       ((me == ME_INT_BND) && (m != x[maxsorted[i]].min())))
    310,256 ( 0.00%)            es = ES_NOFIX;
          .                   pathset_h(hall, x0, w, w);
          .                 }
 54,090,226 ( 0.06%)        if (hall[z].d == hall[y].bounds-hall[z].bounds) {
 40,833,844 ( 0.05%)          pathset_h(hall, hall[y].h, j+1, y);
 30,625,383 ( 0.03%)          hall[y].h = j+1;
          .                 }
          .               }
          .           
          .               return es;
          .             }
          .           
          .             template<class View>
          .             forceinline ExecStatus
-- line 307 ----------------------------------------
-- line 309 ----------------------------------------
          .           
          .               const int n = x.size();
          .           
          .               Region r;
          .           
          .               int* minsorted = r.alloc<int>(n);
          .               int* maxsorted = r.alloc<int>(n);
          .           
 19,572,236 ( 0.02%)      unsigned int d = static_cast<unsigned int>(max_x - min_x) + 1;
          .           
 14,679,177 ( 0.02%)      if (d < static_cast<unsigned int>(n))
          .                 return ES_FAILED;
          .           
 14,679,177 ( 0.02%)      if (d > 2*static_cast<unsigned int>(n)) {
     22,876 ( 0.00%)        for (int i=0; i<n; i++)
      4,902 ( 0.00%)          minsorted[i]=maxsorted[i]=i;
          .           
          .                 MinIncIdx<View> min_inc(x);
          .                 Support::quicksort<int,MinIncIdx<View> >(minsorted, n, min_inc);
          .                 MaxIncIdx<View> max_inc(x);
          .                 Support::quicksort<int,MaxIncIdx<View> >(maxsorted, n, max_inc);
          .               } else {
          .           
          .                 int* minbucket = r.alloc<int>(d);
          .                 int* maxbucket = r.alloc<int>(d);
 14,676,726 ( 0.02%)        for (unsigned int i=0; i<d; i++)
 39,137,936 ( 0.04%)          minbucket[i]=maxbucket[i]=0;
136,986,490 ( 0.15%)  => ???:0x0000000004e951f0 (9,784,484x)
          .           
127,167,158 ( 0.14%)        for (int i=0; i<n; i++) {
136,941,264 ( 0.15%)          minbucket[x[i].min() - min_x]++;
136,941,264 ( 0.15%)          maxbucket[x[i].max() - min_x]++;
          .                 }
          .           
 14,676,726 ( 0.02%)        int c_min = 0, c_max = 0;
136,300,291 ( 0.15%)        for (unsigned int i=0; i<d; i++) {
 38,910,441 ( 0.04%)          int t_min = minbucket[i];
 38,910,441 ( 0.04%)          int t_max = maxbucket[i];
 77,820,882 ( 0.09%)          minbucket[i] = c_min; c_min += t_min;
116,731,323 ( 0.13%)          maxbucket[i] = c_max; c_max += t_max;
          .                 }
          .                 assert((c_min == n) && (c_max == n));
          .           
215,206,758 ( 0.24%)        for (int i=n; i--; ) {
273,882,528 ( 0.31%)          minsorted[minbucket[x[i].min() - min_x]++] = i;
273,882,528 ( 0.31%)          maxsorted[maxbucket[x[i].max() - min_x]++] = i;
          .                 }
          .               }
          .           
          .               // Update minimum and maximum information
  4,893,059 ( 0.01%)      min_x = x[minsorted[0]].min();
  4,893,059 ( 0.01%)      max_x = x[maxsorted[n-1]].max();
          .           
          .           
  9,786,118 ( 0.01%)      if (d > (static_cast<unsigned int>(Int::Limits::max) / 2U))
          .                 return prop_bnd<View,long long int>(home,x,minsorted,maxsorted);
          .               else
          .                 return prop_bnd<View,int>(home,x,minsorted,maxsorted);
          .             }
          .           
          .             template<class View>
          .             ExecStatus
          .             prop_bnd(Space& home, ViewArray<View>& x) {
-- line 370 ----------------------------------------
-- line 373 ----------------------------------------
          .                 min = std::min(min,x[i].min());
          .                 max = std::max(max,x[i].max());
          .               }
          .               return prop_bnd(home, x, min, max);
          .             }
          .           
          .             template<class View>
          .             ExecStatus
108,576,070 ( 0.12%)    Bnd<View>::propagate(Space& home, const ModEventDelta& med) {
          .               assert(x.size() > 1);
          .           
 21,715,214 ( 0.02%)      if (View::me(med) == ME_INT_VAL) {
 17,742,756 ( 0.02%)        ExecStatus es = prop_val<View,false>(home,y);
4,583,074,670 ( 5.13%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/int/distinct/val.hpp:Gecode::ExecStatus Gecode::Int::Distinct::prop_val<Gecode::Int::IntView, false>(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&) (5,914,252x)
 11,828,504 ( 0.01%)        GECODE_ES_CHECK(es);
  9,814,374 ( 0.01%)        if (y.size() < 2)
          .                   return home.ES_SUBSUMED(*this);
  9,753,690 ( 0.01%)        if (es == ES_FIX)
  9,753,690 ( 0.01%)          return home.ES_FIX_PARTIAL(*this,View::med(ME_INT_BND));
          .               }
          .           
  9,886,710 ( 0.01%)      if (y.size() == 2)
  8,723,736 ( 0.01%)        GECODE_REWRITE(*this,(Rel::Nq<View,View>::post(home(*this),y[0],y[1])));
 10,260,384 ( 0.01%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/int/rel/nq.hpp:Gecode::Int::Rel::Nq<Gecode::Int::IntView, Gecode::Int::IntView>::post(Gecode::Home, Gecode::Int::IntView, Gecode::Int::IntView) (50,296x)
          .           
          .               ExecStatus es = prop_bnd<View>(home,x,min_x,max_x);
          .           
  9,786,118 ( 0.01%)      GECODE_ES_CHECK(es);
 12,225,113 ( 0.01%)      if (es == ES_NOFIX && View::me(modeventdelta()) ==  ME_INT_VAL)
          .                 return es;
          .           
          .               const int n = x.size();
          .           
 24,859,002 ( 0.03%)      if ((n > 2*y.size()) && (n > 6)) {
          .                 // If there are many assigned views, try to eliminate them
    998,541 ( 0.00%)        unsigned int d = static_cast<unsigned int>(max_x - min_x) + 1;
    998,541 ( 0.00%)        if (d > 2*static_cast<unsigned int>(n)) {
          .                   MinInc<View> min_inc;
          .                   Support::quicksort<View,MinInc<View> >(&x[0], n, min_inc);
          .                 } else {
          .                   Region r;
          .                   int* minbucket = r.alloc<int>(d);
          .                   View* minsorted = r.alloc<View>(n);
          .           
    665,694 ( 0.00%)          for (unsigned int i=0; i<d; i++)
  1,664,235 ( 0.00%)            minbucket[i]=0;
  4,659,858 ( 0.01%)  => ???:0x0000000004e951f0 (332,847x)
  6,989,787 ( 0.01%)          for (int i=0; i<n; i++)
  9,319,716 ( 0.01%)            minbucket[x[i].min() - min_x]++;
          .           
    665,694 ( 0.00%)          int c_min = 0;
  8,787,675 ( 0.01%)          for (unsigned int i=0; i<d; i++) {
  2,485,429 ( 0.00%)            int t_min = minbucket[i];
  4,970,858 ( 0.01%)            minbucket[i] = c_min; c_min += t_min;
          .                   }
          .                   assert(c_min == n);
          .           
  7,322,634 ( 0.01%)          for (int i=0; i<n; i++)
 20,969,361 ( 0.02%)            minsorted[minbucket[x[i].min() - min_x]++] = x[i];
  6,989,787 ( 0.01%)          for (int i=0; i<n; i++)
  6,989,787 ( 0.01%)            x[i] = minsorted[i];
          .                 }
          .           
          .                 int i   = 0;
    332,847 ( 0.00%)        int j   = 0;
    332,847 ( 0.00%)        int max = x[0].max()-1;
  8,393,052 ( 0.01%)        while (i < n-1) {
  2,042,264 ( 0.00%)          if (!x[i].assigned() ||
  5,038,044 ( 0.01%)              (x[i].val() <= max) || (x[i].val() > x[i+1].min())) {
          .                     // Keep view x[i]
          .                     max = std::max(max,x[i].max());
  5,208,336 ( 0.01%)            x[j++]=x[i];
          .                   }
          .                   i++;
          .                 }
  1,471,586 ( 0.00%)        if (!x[i].assigned() || (x[i].val() <= max))
    623,913 ( 0.00%)          x[j++]=x[i];
          .                 x.size(j);
          .               }
          .           
  7,102,572 ( 0.01%)      if (x.size() < 2)
     60,684 ( 0.00%)        return home.ES_SUBSUMED(*this);
          .           
  7,102,572 ( 0.01%)      if (x.size() == 2)
     50,296 ( 0.00%)        GECODE_REWRITE(*this,(Rel::Nq<View,View>::post(home(*this),x[0],x[1])));
          .           
          .               return es;
130,291,284 ( 0.15%)    }
          .           
          .           #ifdef GECODE_HAS_CBS
          .             template<class View>
          .             void
          .             Bnd<View>::solndistrib(Space& home, Propagator::SendMarginal send) const {
          .               cbsdistinct(home,this->id(),x,send);
          .             }
          .           
-- line 465 ----------------------------------------
-- line 468 ----------------------------------------
          .             Bnd<View>::domainsizesum(Propagator::InDecision in, unsigned int& size,
          .                                      unsigned int& size_b) const {
          .               cbssize(x,in,size,size_b);
          .             }
          .           #endif
          .           
          .             template<class View>
          .             ExecStatus
         12 ( 0.00%)    Bnd<View>::post(Home home, ViewArray<View>& x){
          2 ( 0.00%)      if (x.size() == 2)
          .                 return Rel::Nq<View,View>::post(home,x[0],x[1]);
          1 ( 0.00%)      if (x.size() > 2)
          .                 (void) new (home) Bnd<View>(home,x);
          2 ( 0.00%)      return ES_OK;
         11 ( 0.00%)    }
          .           
          .           }}}
          .           
          .           // STATISTICS: int-prop
          .           

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/int/branch/merit.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 105 ----------------------------------------
          .               : MeritBase<View,double>(home,vb), afc(vb.afc()) {}
          .             template<class View>
          .             forceinline
          .             MeritAFCSize<View>::MeritAFCSize(Space& home, MeritAFCSize& m)
          .               : MeritBase<View,double>(home,m), afc(m.afc) {}
          .             template<class View>
          .             forceinline double
          .             MeritAFCSize<View>::operator ()(const Space&, View x, int) {
165,497,944 ( 0.19%)      return x.afc() / static_cast<double>(x.size());
          .             }
          .             template<class View>
          .             forceinline bool
          .             MeritAFCSize<View>::notice(void) const {
          .               return false;
          .             }
          .             template<class View>
          .             forceinline void
-- line 121 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/int/view/rel-test.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 67 ----------------------------------------
          .               if (rt != RT_MAYBE) return rt;
          .               return (x.range() && y.range()) ? RT_MAYBE : rtest_eq_dom_check(x,y);
          .             }
          .           
          .           
          .             template<class VX>
          .             forceinline RelTest
          .             rtest_eq_bnd(VX x, int n) {
216,827,158 ( 0.24%)      if ((n > x.max()) || (n < x.min())) return RT_FALSE;
 94,380,656 ( 0.11%)      return x.assigned() ? RT_TRUE : RT_MAYBE;
          .             }
          .           
          .             template<class VX>
          .             RelTest
          .             rtest_eq_dom_check(VX x, int n) {
          .               ViewRanges<VX> rx(x);
          .               while (n > rx.max()) ++rx;
          .               return (n >= rx.min()) ? RT_MAYBE : RT_FALSE;
          .             }
          .           
          .             template<class VX>
          .             forceinline RelTest
          .             rtest_eq_dom(VX x, int n) {
          .               RelTest rt = rtest_eq_bnd(x,n);
          .               if (rt != RT_MAYBE) return rt;
 92,162,368 ( 0.10%)      return x.range() ? RT_MAYBE : rtest_eq_dom_check(x,n);
          .             }
          .           
          .           
          .           
          .             /*
          .              * Testing disequality
          .              *
          .              */
-- line 100 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/memory/region.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 330 ----------------------------------------
          .              * Implementation
          .              *
          .              */
          .             forceinline bool
          .             Region::Chunk::alloc(size_t s, void*& p) {
          .               Kernel::MemoryConfig::align
          .                 (s,((alignof(std::max_align_t) > GECODE_MEMORY_ALIGNMENT) ?
          .                     alignof(std::max_align_t) : GECODE_MEMORY_ALIGNMENT));
107,810,010 ( 0.12%)      if (s > free)
          .                 return false;
 71,873,340 ( 0.08%)      free -= s;
 56,530,099 ( 0.06%)      p = ptr_cast<char*>(&area[0]) + free;
          .               return true;
          .             }
          .           
          .             forceinline void
          .             Region::Chunk::reset(void) {
 16,033,221 ( 0.02%)      free = Kernel::MemoryConfig::region_area_size;
          .             }
          .           
          .           
          .             forceinline
          .             Region::Region(void)
 80,166,105 ( 0.09%)      : chunk(pool().chunk()), hi(nullptr) {}
941,063,743 ( 1.05%)  => ???:0x0000000004e95070 (10,118,965x)
455,353,425 ( 0.51%)  => ???:0x0000000004e95750 (10,118,965x)
          .           
          .             forceinline void
          .             Region::free(void) {
          .               chunk->reset();
          .             }
          .           
          .             forceinline void*
          .             Region::ralloc(size_t s) {
          .               void* p;
 19,903,449 ( 0.02%)      if (chunk->alloc(s,p))
          6 ( 0.00%)        return p;
          .               else
          .                 return heap_alloc(s);
          .             }
          .           
          .             forceinline void
          .             Region::rfree(void*, size_t) {}
          .           
          .             forceinline
          .             Region::~Region(void) {
 64,132,884 ( 0.07%)      pool().chunk(chunk);
455,353,425 ( 0.51%)  => ???:0x0000000004e95750 (10,118,965x)
880,349,953 ( 0.98%)  => ???:0x0000000004e955a0 (10,118,965x)
 32,066,442 ( 0.04%)      if (hi != nullptr)
          .                 heap_free();
          .             }
          .           
          .           
          .             /*
          .              * Typed allocation routines
          .              *
          .              */
          .             template<class T>
          .             forceinline T*
          .             Region::alloc(long unsigned int n) {
 31,044,430 ( 0.03%)      T* p = static_cast<T*>(ralloc(sizeof(T)*n));
649,989,255 ( 0.73%)      for (long unsigned int i=0U; i<n; i++)
278,661,060 ( 0.31%)  => ???:0x0000000004e951f0 (19,903,449x)
          .                 (void) new (p+i) T();
          .               return p;
          .             }
          .             template<class T>
          .             forceinline T*
          .             Region::alloc(long int n) {
          .               assert(n >= 0);
          .               return alloc<T>(static_cast<long unsigned int>(n));
          .             }
          .             template<class T>
          .             forceinline T*
          .             Region::alloc(unsigned int n) {
  5,225,089 ( 0.01%)      return alloc<T>(static_cast<long unsigned int>(n));
          .             }
          .             template<class T>
          .             forceinline T*
          .             Region::alloc(int n) {
          .               assert(n >= 0);
 10,118,969 ( 0.01%)      return alloc<T>(static_cast<long unsigned int>(n));
          .             }
          .           
          .             template<class T>
          .             forceinline void
          .             Region::free(T* b, long unsigned int n) {
          .               for (long unsigned int i=0U; i<n; i++)
          .                 b[i].~T();
          .               rfree(b,n*sizeof(T));
-- line 415 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/int/view/scale.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 60 ----------------------------------------
          .             template<class Val, class UnsVal>
          .             forceinline int
          .             ScaleView<Val,UnsVal>::scale(void) const {
          .               return a;
          .             }
          .             template<class Val, class UnsVal>
          .             forceinline Val
          .             ScaleView<Val,UnsVal>::min(void) const {
691,729,137 ( 0.77%)      return static_cast<Val>(x.min()) * a;
          .             }
          .           
          .             template<class Val, class UnsVal>
          .             forceinline Val
          .             ScaleView<Val,UnsVal>::max(void) const {
737,945,815 ( 0.83%)      return static_cast<Val>(x.max()) * a;
          .             }
          .           
          .             template<class Val, class UnsVal>
          .             forceinline Val
          .             ScaleView<Val,UnsVal>::med(void) const {
          .               return static_cast<Val>(x.med()) * a;
          .             }
          .           
-- line 82 ----------------------------------------
-- line 138 ----------------------------------------
          .           
          .             /*
          .              * Domain update by value
          .              *
          .              */
          .             template<class Val, class UnsVal>
          .             forceinline ModEvent
          .             ScaleView<Val,UnsVal>::lq(Space& home, Val n) {
165,199,966 ( 0.18%)      return (n >= max()) ? ME_INT_NONE :
          .                 x.lq(home,floor_div_xp(n,static_cast<Val>(a)));
          .             }
          .           
          .             template<class Val, class UnsVal>
          .             forceinline ModEvent
          .             ScaleView<Val,UnsVal>::le(Space& home, Val n) {
          .               return (n > max()) ? ME_INT_NONE :
          .                 x.le(home,floor_div_xp(n,static_cast<Val>(a)));
          .             }
          .           
          .             template<class Val, class UnsVal>
          .             forceinline ModEvent
          .             ScaleView<Val,UnsVal>::gq(Space& home, Val n) {
234,499,934 ( 0.26%)      return (n <= min()) ? ME_INT_NONE :
          .                 x.gq(home,ceil_div_xp(n,static_cast<Val>(a)));
          .             }
          .             template<class Val, class UnsVal>
          .             forceinline ModEvent
          .             ScaleView<Val,UnsVal>::gr(Space& home, Val n) {
          .               return (n < min()) ? ME_INT_NONE :
          .                 x.gr(home,ceil_div_xp(n,static_cast<Val>(a)));
          .             }
-- line 168 ----------------------------------------
-- line 170 ----------------------------------------
          .             template<class Val, class UnsVal>
          .             forceinline ModEvent
          .             ScaleView<Val,UnsVal>::nq(Space& home, Val n) {
          .               return ((n % a) == 0) ? x.nq(home,n/a) :  ME_INT_NONE;
          .             }
          .           
          .             template<class Val, class UnsVal>
          .             forceinline ModEvent
  6,997,866 ( 0.01%)    ScaleView<Val,UnsVal>::eq(Space& home, Val n) {
  6,997,866 ( 0.01%)      return ((n % a) == 0) ? x.eq(home,n/a) : ME_INT_FAILED;
          .             }
          .           
          .           
          .             /*
          .              * Propagator modification events
          .              *
          .              */
          .             template<class Val, class UnsVal>
-- line 187 ----------------------------------------
-- line 222 ----------------------------------------
          .             /*
          .              * Cloning
          .              *
          .              */
          .             template<class Val, class UnsVal>
          .             forceinline void
          .             ScaleView<Val,UnsVal>::update(Space& home, ScaleView<Val,UnsVal>& y) {
          .               DerivedView<IntView>::update(home,y);
 98,214,790 ( 0.11%)      a=y.a;
          .             }
          .           
          .           
          .             /*
          .              * Ordering
          .              *
          .              */
          .             template<class Val, class UnsVal>
-- line 238 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/var.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 81 ----------------------------------------
          .           
          .             /*
          .              * Variable: contains a pointer to a variable implementation
          .              *
          .              */
          .             template<class VarImp>
          .             forceinline
          .             VarImpVar<VarImp>::VarImpVar(void)
762,026,803 ( 0.85%)      : x(nullptr) {}
         14 ( 0.00%)  => ???:0x0000000004866660 (1x)
          .             template<class VarImp>
          .             forceinline
    108,942 ( 0.00%)    VarImpVar<VarImp>::VarImpVar(VarImp* y)
    197,423 ( 0.00%)      : x(y) {}
          .             template<class VarImp>
          .             forceinline VarImp*
          .             VarImpVar<VarImp>::varimp(void) const {
    592,431 ( 0.00%)      return x;
          .             }
          .             template<class VarImp>
          .             forceinline unsigned int
          .             VarImpVar<VarImp>::degree(void) const {
          .               return x->degree();
          .             }
          .             template<class VarImp>
          .             forceinline double
          .             VarImpVar<VarImp>::afc(void) const {
          .               return x->afc();
          .             }
          .             template<class VarImp>
          .             forceinline bool
          .             VarImpVar<VarImp>::assigned(void) const {
         21 ( 0.00%)      return x->assigned();
          .             }
          .             template<class VarImp>
          .             forceinline void
          .             VarImpVar<VarImp>::update(Space& home, VarImpVar<VarImp>& y) {
865,744,590 ( 0.97%)      x = y.x->copy(home);
          .             }
          .           
          .           }
          .           
          .           // STATISTICS: kernel-var

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/support/dynamic-stack.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 104 ----------------------------------------
          .               int nl = (limit * 3) / 2;
          .               stack = a.template realloc<T>(stack,limit,nl);
          .               limit = nl;
          .             }
          .           
          .             template<class T, class A>
          .             forceinline
          .             DynamicStack<T,A>::DynamicStack(A& a0, int n)
         10 ( 0.00%)      : a(a0), limit(n), tos(0), stack(a.template alloc<T>(n)) {}
          .           
          .             template<class T, class A>
          .             forceinline
          .             DynamicStack<T,A>::~DynamicStack(void) {
          .               a.free(stack,limit);
          .             }
          .           
          .             template<class T, class A>
          .             forceinline T
          .             DynamicStack<T,A>::pop(void) {
 56,305,711 ( 0.06%)      return stack[--tos];
          .             }
          .           
          .             template<class T, class A>
          .             forceinline T&
          .             DynamicStack<T,A>::top(void) const {
127,045,171 ( 0.14%)      return stack[tos-1];
          .             }
          .           
          .             template<class T, class A>
          .             forceinline T&
          .             DynamicStack<T,A>::last(void) const {
          .               return stack[tos];
          .             }
          .           
          .             template<class T, class A>
          .             forceinline void
          .             DynamicStack<T,A>::push(const T& x) {
 64,349,448 ( 0.07%)      stack[tos++] = x;
 24,131,043 ( 0.03%)      if (tos==limit)
          .                 resize();
          .             }
          .           
          .             template<class T, class A>
          .             forceinline bool
          .             DynamicStack<T,A>::empty(void) const {
 30,016,156 ( 0.03%)      return tos==0;
          .             }
          .           
          .             template<class T, class A>
          .             forceinline int
    122,898 ( 0.00%)    DynamicStack<T,A>::entries(void) const {
  4,533,512 ( 0.01%)      return tos;
          .             }
          .           
          .             template<class T, class A>
          .             forceinline T&
          .             DynamicStack<T,A>::operator [](int i) {
 19,467,417 ( 0.02%)      return stack[i];
          .             }
          .           
          .             template<class T, class A>
          .             forceinline const T&
          .             DynamicStack<T,A>::operator [](int i) const {
 50,385,315 ( 0.06%)      return stack[i];
          .             }
          .           
          .           }}
          .           
          .           // STATISTICS: support-any

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/search/statistics.hpp
--------------------------------------------------------------------------------
Ir                  

-- line 44 ----------------------------------------
         .             forceinline
         .             Statistics::Statistics(void)
         .               : fail(0ULL), node(0ULL), 
         .                 depth(0UL), restart(0UL), nogood(0UL) {}
         .           
         .             forceinline Statistics&
         .             Statistics::operator +=(const Statistics& s) {
         .               (void) StatusStatistics::operator +=(s);
         2 ( 0.00%)      fail += s.fail;
20,836,330 ( 0.02%)      node += s.node;
   163,869 ( 0.00%)      depth = std::max(depth,s.depth);
31,234,011 ( 0.03%)      restart += s.restart;
31,234,011 ( 0.03%)      nogood += s.nogood;
         .               return *this;
         .             }
         .           
         .             forceinline Statistics
         .             Statistics::operator +(const Statistics& s) {
         .               Statistics t(s);
41,590,724 ( 0.05%)      return t += *this;
         .             }
         .           
         .           }}
         .           
         .           // STATISTICS: search-other

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/gecode/kernel/core.cpp
--------------------------------------------------------------------------------
Ir                   

-- line 77 ----------------------------------------
          .             /*
          .              * No-goods
          .              *
          .              */
          .             void
          .             NoGoods::post(Space&) const {
          .             }
          .           
          3 ( 0.00%)    NoGoods NoGoods::eng;
         77 ( 0.00%)  => ???:0x0000000004954800 (1x)
          .           
          .             /*
          .              * Brancher
          .              *
          .              */
          .             NGL*
          .             Brancher::ngl(Space&, const Choice&, unsigned int) const {
          .               return nullptr;
-- line 93 ----------------------------------------
-- line 107 ----------------------------------------
          .             StatusStatistics Space::unused_status;
          .             CloneStatistics Space::unused_clone;
          .             CommitStatistics Space::unused_commit;
          .           
          .           #ifdef GECODE_HAS_VAR_DISPOSE
          .             VarImpDisposerBase* Space::vd[AllVarConf::idx_d];
          .           #endif
          .           
         10 ( 0.00%)    Space::Space(void) : mm(ssd.data().sm) {
          .           #ifdef GECODE_HAS_CBS
          .               var_id_counter = 0;
          .           #endif
          .           #ifdef GECODE_HAS_VAR_DISPOSE
          .               for (int i=0; i<AllVarConf::idx_d; i++)
          .                 _vars_d[i] = nullptr;
          .           #endif
          .               // Initialize propagator and brancher links
          2 ( 0.00%)      pl.init();
          2 ( 0.00%)      bl.init();
          .               b_status = b_commit = Brancher::cast(&bl);
          .               // Initialize array for forced deletion to be empty
          2 ( 0.00%)      d_fst = d_cur = d_lst = nullptr;
          .               // Initialize space as stable but not failed
          2 ( 0.00%)      pc.p.active = &pc.p.queue[0]-1;
          .               // Initialize propagator queues
          .               for (int i=0; i<=PropCost::AC_MAX; i++)
          7 ( 0.00%)        pc.p.queue[i].init();
          2 ( 0.00%)      pc.p.bid_sc = (reserved_bid+1) << sc_bits;
          .               pc.p.n_sub  = 0;
          .               pc.p.vti.other();
          6 ( 0.00%)    }
          .           
          .             void
         44 ( 0.00%)    Space::ap_notice_dispose(Actor* a, bool duplicate) {
          .               // Note that a might be a marked pointer!
         20 ( 0.00%)      if (duplicate && (d_fst != nullptr)) {
         18 ( 0.00%)        for (Actor** f = d_fst; f < d_cur; f++)
          4 ( 0.00%)          if (a == *f)
          .                     return;
          .               }
         10 ( 0.00%)      if (d_cur == d_lst) {
          .                 // Resize
          .                 if (d_fst == nullptr) {
          .                   // Create new array
          2 ( 0.00%)          d_fst = alloc<Actor*>(4);
          .                   d_cur = d_fst;
         10 ( 0.00%)          d_lst = d_fst+4;
          .                 } else {
          .                   // Resize existing array
          .                   unsigned int n = static_cast<unsigned int>(d_lst - d_fst);
          .                   assert(n != 0);
          .                   d_fst = realloc<Actor*>(d_fst,n,2*n);
          .                   d_cur = d_fst+n;
          .                   d_lst = d_fst+2*n;
          .                 }
          .               }
         12 ( 0.00%)      *(d_cur++) = a;
         32 ( 0.00%)    }
          .           
          .             void
          8 ( 0.00%)    Space::ap_ignore_dispose(Actor* a, bool duplicate) {
          .               // Note that a might be a marked pointer!
          .               assert(d_fst != nullptr);
          4 ( 0.00%)      Actor** f = d_fst;
          8 ( 0.00%)      if (duplicate) {
         12 ( 0.00%)        while (f < d_cur)
          8 ( 0.00%)          if (a == *f)
          .                     break;
          .                   else
          .                     f++;
          8 ( 0.00%)        if (f == d_cur)
          .                   return;
          .               } else {
          .                 while (a != *f)
          .                   f++;
          .               }
         16 ( 0.00%)      *f = *(--d_cur);
          4 ( 0.00%)    }
          .           
 88,177,616 ( 0.10%)    Space::~Space(void) {
          .               // Mark space as failed
          .               fail();
          .               // Delete actors that must be deleted
          .               {
  8,016,146 ( 0.01%)        Actor** a = d_fst;
  8,016,146 ( 0.01%)        Actor** e = d_cur;
          .                 // So that d_unforce knows that deletion is in progress
  8,016,146 ( 0.01%)        d_fst = nullptr;
 56,113,007 ( 0.06%)        while (a < e) {
          .                   // Ignore entries for tracers
 48,096,858 ( 0.05%)          if (!Support::marked(*a))
112,226,002 ( 0.13%)            (void) (*a)->dispose(*this);
657,323,726 ( 0.74%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view-val.hpp:Gecode::ViewValBrancher<Gecode::Int::IntView, 1, int, 2u, Gecode::BrancherNoFilter<Gecode::Int::IntView>, Gecode::BrancherPrint<Gecode::Int::IntView, int> >::dispose(Gecode::Space&) (16,032,286x)
 16,032,286 ( 0.02%)          a++;
          .                 }
          .               }
          .           #ifdef GECODE_HAS_VAR_DISPOSE
          .               // Delete variables that were registered for disposal
          .               for (int i=0; i<AllVarConf::idx_d; i++)
          .                 if (_vars_d[i] != nullptr)
          .                   vd[i]->dispose(*this, _vars_d[i]);
          .           #endif
          .               // Release memory from memory manager
          .               mm.release(ssd.data().sm);
 48,096,876 ( 0.05%)    }
          .           
          .           
          .           
          .             /*
          .              * Space: propagation
          .              *
          .              */
          .           
-- line 218 ----------------------------------------
-- line 244 ----------------------------------------
          .                 else
          .                   s = PostTraceInfo::POSTED;
          .                 PostTraceInfo pti(pi.pg,s,n);
          .                 tr->tracer()._post(*this,pti);
          .               }
          .             }
          .           
          .             SpaceStatus
137,813,144 ( 0.15%)    Space::status(StatusStatistics& stat) {
          .               // Check whether space is failed
 34,453,286 ( 0.04%)      if (failed())
 15,854,786 ( 0.02%)        return SS_FAILED;
          .               assert(pc.p.active <= &pc.p.queue[PropCost::AC_MAX+1]);
          .               Propagator* p;
          .               // Check whether space is stable but not failed
 68,906,572 ( 0.08%)      if (pc.p.active >= &pc.p.queue[0]) {
          .                 ModEventDelta med_o;
 85,928,195 ( 0.10%)        if ((pc.p.bid_sc & ((1 << sc_bits) - 1)) == 0) {
          .                   // No support for disabled propagators and tracing
          .                   // Check whether space is stable but not failed
          .                   goto f_unstable;
          .                 f_execute:
 43,442,226 ( 0.05%)          stat.propagate++;
          .                   // Keep old modification event delta
 86,884,452 ( 0.10%)          med_o = p->u.med;
          .                   // Clear med but leave propagator in queue
 43,442,226 ( 0.05%)          p->u.med = 0;
495,050,125 ( 0.55%)          switch (p->propagate(*this,med_o)) {
18,392,082,637 (20.57%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/int/distinct/bnd.hpp:Gecode::Int::Distinct::Bnd<Gecode::Int::IntView>::propagate(Gecode::Space&, int const&) (10,857,607x)
12,999,110,733 (14.54%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/int/linear/int-nary.hpp:Gecode::Int::Linear::Eq<int, Gecode::Int::ScaleView<int, unsigned int>, Gecode::Int::ScaleView<int, unsigned int> >::propagate(Gecode::Space&, int const&) (17,913,297x)
3,381,389,042 ( 3.78%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/int/count/int-eq.hpp:Gecode::Int::Count::EqInt<Gecode::Int::IntView, Gecode::Int::ConstIntView>::propagate(Gecode::Space&, int const&) (14,573,065x)
 12,993,063 ( 0.01%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/int/rel/nq.hpp:Gecode::Int::Rel::Nq<Gecode::Int::IntView, Gecode::Int::IntView>::propagate(Gecode::Space&, int const&) (98,256x)
      2,787 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/int/linear/int-nary.hpp:Gecode::Int::Linear::Eq<int, Gecode::Int::ScaleView<int, unsigned int>, Gecode::Int::Linear::NoView>::propagate(Gecode::Space&, int const&) (1x)
          .                   case ES_FAILED:
          .                     goto failed;
          .                   case ES_NOFIX:
          .                     // Find next, if possible
    942,753 ( 0.00%)            if (p->u.med != 0) {
          .                     f_unstable:
          .                       // There is at least one propagator in a queue
          .                       do {
          .                         assert(pc.p.active >= &pc.p.queue[0]);
          .                         // First propagator or link back to queue
    628,502 ( 0.00%)                ActorLink* fst = pc.p.active->next();
 45,485,464 ( 0.05%)                if (pc.p.active != fst) {
          .                           p = Propagator::cast(fst);
          .                           goto f_execute;
          .                         }
    731,994 ( 0.00%)                pc.p.active--;
          .                       } while (true);
          .                       GECODE_NEVER;
          .                     }
          .                     // Fall through
          .                   case ES_FIX:
          .                     // Clear med
 25,714,087 ( 0.03%)            p->u.med = 0;
          .                     // Put into idle queue
 51,428,174 ( 0.06%)            p->unlink(); pl.head(p);
          .                   f_stable_or_unstable:
          .                     // There might be a propagator in the queue
          .                     do {
          .                       assert(pc.p.active >= &pc.p.queue[0]);
          .                       // First propagator or link back to queue
 60,647,474 ( 0.07%)              ActorLink* fst = pc.p.active->next();
175,712,587 ( 0.20%)              if (pc.p.active != fst) {
          .                         p = Propagator::cast(fst);
          .                         goto f_execute;
          .                       }
225,032,228 ( 0.25%)            } while (--pc.p.active >= &pc.p.queue[0]);
          .                     assert(pc.p.active < &pc.p.queue[0]);
          .                     goto f_stable;
          .                   case ES_SUBSUMED_:
  4,609,650 ( 0.01%)            p->unlink(); rfree(p,p->u.size);
          .                     goto f_stable_or_unstable;
          .                   case ES_PARTIAL_:
          .                     // Schedule propagator with specified propagator events
          .                     assert(p->u.med != 0);
          .                     enqueue(p);
          .                     goto f_unstable;
          .                   default:
          .                     GECODE_NEVER;
-- line 319 ----------------------------------------
-- line 491 ----------------------------------------
          .                * The same situation may arise due to weakly monotonic propagators.
          .                *
          .                * A brancher reporting that no more alternatives exist is exhausted.
          .                * All exhausted branchers will be left of the current pointer b_status.
          .                * Only when it is known that no more choices
          .                * can be used for commit an exhausted brancher can actually be deleted.
          .                * This becomes known when choice is called.
          .                */
 27,897,759 ( 0.03%)      while (b_status != Brancher::cast(&bl))
 46,496,255 ( 0.05%)        if (b_status->status(*this)) {
187,906,370 ( 0.21%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view.hpp:Gecode::ViewBrancher<Gecode::Int::IntView, Gecode::BrancherNoFilter<Gecode::Int::IntView>, 1>::status(Gecode::Space const&) const (9,299,251x)
          .                   // Brancher still has choices to generate
  9,299,247 ( 0.01%)          return SS_BRANCH;
          .                 } else {
          .                   // Brancher is exhausted
          4 ( 0.00%)          b_status = Brancher::cast(b_status->next());
          .                 }
          .               // No brancher with alternatives left, space is solved
          6 ( 0.00%)      return SS_SOLVED;
          .           
          .               // Process failure
          .             failed:
          .               // Count failure
          .               ssd.data().gpi.fail(p->gpi());
          .               // Mark as failed
          .               fail();
          .               // Propagate top priority propagators
          .               ActorLink* e = &pc.p.queue[PropCost::AC_RECORD];
 15,854,786 ( 0.02%)      for (ActorLink* a = e->next(); a != e; a = a->next()) {
          .                 Propagator* top = Propagator::cast(a);
          .                 // Keep old modification event delta
          .                 ModEventDelta top_med_o = top->u.med;
          .                 // Clear med but leave propagator in queue
          .                 top->u.med = 0;
          .                 switch (top->propagate(*this,top_med_o)) {
          .                 case ES_FIX:
          .                   break;
          .                 case ES_SUBSUMED_:
          .                   break;
          .                 default:
          .                   GECODE_NEVER;
          .                 }
          .               }
          .               return SS_FAILED;
189,493,073 ( 0.21%)    }
          .           
          .           
          .             const Choice*
 72,393,147 ( 0.08%)    Space::choice(void) {
          .               if (!stable())
          .                 throw SpaceNotStable("Space::choice");
 40,218,415 ( 0.04%)      if (failed() || (b_status == Brancher::cast(&bl))) {
          .                 // There are no more choices to be generated
          .                 // Delete all branchers
          .                 Brancher* b = Brancher::cast(bl.next());
         16 ( 0.00%)        while (b != Brancher::cast(&bl)) {
          .                   Brancher* d = b;
          .                   b = Brancher::cast(b->next());
         36 ( 0.00%)          rfree(d,d->dispose(*this));
      1,383 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view-val.hpp:Gecode::ViewValBrancher<Gecode::Int::IntView, 1, int, 2u, Gecode::BrancherNoFilter<Gecode::Int::IntView>, Gecode::BrancherPrint<Gecode::Int::IntView, int> >::dispose(Gecode::Space&) (4x)
          .                 }
          4 ( 0.00%)        bl.init();
          4 ( 0.00%)        b_status = b_commit = Brancher::cast(&bl);
          .                 return nullptr;
          .               }
          .               /*
          .                * The call to choice() says that no older choices
          .                * can be used. Hence, all branchers that are exhausted can be deleted.
          .                */
          .               Brancher* b = Brancher::cast(bl.next());
 16,087,362 ( 0.02%)      while (b != b_status) {
          .                 Brancher* d = b;
          .                 b = Brancher::cast(b->next());
          .                 d->unlink();
          .                 rfree(d,d->dispose(*this));
          .               }
          .               // Make sure that b_commit does not point to a deleted brancher!
  8,043,681 ( 0.01%)      b_commit = b_status;
 40,218,405 ( 0.04%)      return b_status->choice(*this);
3,218,209,897 ( 3.60%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view-val.hpp:Gecode::ViewValBrancher<Gecode::Int::IntView, 1, int, 2u, Gecode::BrancherNoFilter<Gecode::Int::IntView>, Gecode::BrancherPrint<Gecode::Int::IntView, int> >::choice(Gecode::Space&) (8,043,681x)
 56,305,785 ( 0.06%)    }
          .           
          .             const Choice*
          .             Space::choice(Archive& e) const {
          .               unsigned int id; e >> id;
          .               Brancher* b_cur = Brancher::cast(bl.next());
          .               while (b_cur != Brancher::cast(&bl)) {
          .                 if (id == b_cur->id())
          .                   return b_cur->choice(*this,e);
          .                 b_cur = Brancher::cast(b_cur->next());
          .               }
          .               throw SpaceNoBrancher("Space::choice");
          .             }
          .           
          .             void
302,993,691 ( 0.34%)    Space::_commit(const Choice& c, unsigned int a) {
 82,634,643 ( 0.09%)      if (a >= c.alternatives())
          .                 throw SpaceIllegalAlternative("Space::commit");
 55,089,762 ( 0.06%)      if (failed())
          .                 return;
 27,544,881 ( 0.03%)      if (Brancher* b = brancher(c.bid)) {
          .                 // There is a matching brancher
 55,089,762 ( 0.06%)        if (pc.p.bid_sc & sc_trace) {
          .                   TraceRecorder* tr = findtracerecorder();
          .                   if ((tr != nullptr) && (tr->events() & TE_COMMIT) &&
          .                       tr->filter()(b->group())) {
          .                     CommitTraceInfo cti(*b,c,a);
          .                     tr->tracer()._commit(*this,cti);
          .                   }
          .                   ViewTraceInfo vti = pc.p.vti;
          .                   pc.p.vti.brancher(*b);
          .                   ExecStatus es = b->commit(*this,c,a);
          .                   pc.p.vti = vti;
          .                   if (es == ES_FAILED)
          .                     fail();
          .                 } else {
220,359,048 ( 0.25%)          if (b->commit(*this,c,a) == ES_FAILED)
4,958,901,857 ( 5.55%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view-val.hpp:Gecode::ViewValBrancher<Gecode::Int::IntView, 1, int, 2u, Gecode::BrancherNoFilter<Gecode::Int::IntView>, Gecode::BrancherPrint<Gecode::Int::IntView, int> >::commit(Gecode::Space&, Gecode::Choice const&, unsigned int) (27,544,881x)
          .                     fail();
          .                 }
          .               } else {
          .                 // There is no matching brancher!
          .                 throw SpaceNoBrancher("Space::commit");
          .               }
302,993,691 ( 0.34%)    }
          .           
          .             void
          .             Space::_trycommit(const Choice& c, unsigned int a) {
          .               if (a >= c.alternatives())
          .                 throw SpaceIllegalAlternative("Space::commit");
          .               if (failed())
          .                 return;
          .               if (Brancher* b = brancher(c.bid)) {
-- line 619 ----------------------------------------
-- line 686 ----------------------------------------
          .              * Cloning is performed in two steps:
          .              *  - The space itself is copied by the copy constructor. This
          .              *    also copies all propagators, branchers, and variables.
          .              *    The copied variables are recorded.
          .              *  - In the second step the dependency information of the recorded
          .              *    variables is updated and their forwarding information is reset.
          .              *
          .              */
 80,161,540 ( 0.09%)    Space::Space(Space& s)
          .               : ssd(s.ssd),
 24,048,462 ( 0.03%)        mm(ssd.data().sm,s.mm,s.pc.p.n_sub*sizeof(Propagator**)),
          .           #ifdef GECODE_HAS_CBS
          .                 var_id_counter(s.var_id_counter),
          .           #endif
 40,080,770 ( 0.04%)        d_fst(&Actor::sentinel) {
          .           #ifdef GECODE_HAS_VAR_DISPOSE
          .               for (int i=0; i<AllVarConf::idx_d; i++)
          .                 _vars_d[i] = nullptr;
          .           #endif
          .               for (int i=0; i<AllVarConf::idx_c; i++)
 24,048,462 ( 0.03%)        pc.c.vars_u[i] = nullptr;
          .               pc.c.vars_noidx = nullptr;
          .               pc.c.local = nullptr;
          .               // Copy all propagators
          .               {
 24,048,462 ( 0.03%)        ActorLink* p = &pl;
  8,016,154 ( 0.01%)        ActorLink* e = &s.pl;
 48,533,042 ( 0.05%)        for (ActorLink* a = e->next(); a != e; a = a->next()) {
 48,751,098 ( 0.05%)          Actor* c = Actor::cast(a)->copy(*this);
3,225,093,129 ( 3.61%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/int/linear/int-nary.hpp:Gecode::Int::Linear::Eq<int, Gecode::Int::ScaleView<int, unsigned int>, Gecode::Int::ScaleView<int, unsigned int> >::copy(Gecode::Space&) (8,016,152x)
2,210,404,539 ( 2.47%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/int/distinct/bnd.hpp:Gecode::Int::Distinct::Bnd<Gecode::Int::IntView>::copy(Gecode::Space&) (2,752,742x)
1,442,283,614 ( 1.61%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/int/count/int-eq.hpp:Gecode::Int::Count::EqInt<Gecode::Int::IntView, Gecode::Int::ConstIntView>::copy(Gecode::Space&) (5,426,491x)
 11,824,527 ( 0.01%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/int/rel/nq.hpp:Gecode::Int::Rel::Nq<Gecode::Int::IntView, Gecode::Int::IntView>::copy(Gecode::Space&) (54,981x)
          .                   // Link copied actor
          .                   p->next(ActorLink::cast(c)); ActorLink::cast(c)->prev(p);
          .                   // Note that forwarding is done in the constructors
          .                   p = c;
          .                 }
          .                 // Link last actor
          .                 p->next(&pl); pl.prev(p);
          .               }
          .               // Copy all branchers
          .               {
 24,048,462 ( 0.03%)        ActorLink* p = &bl;
  8,016,154 ( 0.01%)        ActorLink* e = &s.bl;
 48,096,908 ( 0.05%)        for (ActorLink* a = e->next(); a != e; a = a->next()) {
 48,096,900 ( 0.05%)          Actor* c = Actor::cast(a)->copy(*this);
11,811,669,247 (13.21%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view-val.hpp:Gecode::ViewValBrancher<Gecode::Int::IntView, 1, int, 2u, Gecode::BrancherNoFilter<Gecode::Int::IntView>, Gecode::BrancherPrint<Gecode::Int::IntView, int> >::copy(Gecode::Space&) (16,032,300x)
          .                   // Link copied actor
          .                   p->next(ActorLink::cast(c)); ActorLink::cast(c)->prev(p);
          .                   // Note that forwarding is done in the constructors
          .                   p = c;
          .                 }
          .                 // Link last actor
          .                 p->next(&bl); bl.prev(p);
          .               }
          .               // Setup brancher pointers
 48,096,924 ( 0.05%)      if (s.b_status == &s.bl) {
          .                 b_status = Brancher::cast(&bl);
          .               } else {
          .                 b_status = Brancher::cast(s.b_status->prev());
          .               }
 48,096,924 ( 0.05%)      if (s.b_commit == &s.bl) {
          .                 b_commit = Brancher::cast(&bl);
          .               } else {
          .                 b_commit = Brancher::cast(s.b_commit->prev());
          .               }
 64,129,232 ( 0.07%)    }
          .           
          .             Space*
 72,145,386 ( 0.08%)    Space::_clone(void) {
 16,032,308 ( 0.02%)      if (failed())
          .                 throw SpaceFailed("Space::clone");
          .               if (!stable())
          .                 throw SpaceNotStable("Space::clone");
          .           
          .               // Copy all data structures (which in turn will invoke the constructor)
 24,048,462 ( 0.03%)      Space* c = copy();
28,394,188,971 (31.76%)  => /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/flatzinc.cpp:Gecode::FlatZinc::FlatZincSpace::copy() (8,016,154x)
          .           
 24,048,462 ( 0.03%)      if (c->d_fst != &Actor::sentinel)
          .                 throw SpaceNotCloned("Space::clone");
          .           
          .               // Setup array for actor disposal in c
          .               {
 32,064,616 ( 0.04%)        unsigned int n = static_cast<unsigned int>(d_cur - d_fst);
 16,032,308 ( 0.02%)        if (n == 0) {
          .                   // No actors
         16 ( 0.00%)          c->d_fst = c->d_cur = c->d_lst = nullptr;
          .                 } else {
          .                   // Leave one entry free
 16,032,300 ( 0.02%)          c->d_fst = c->alloc<Actor*>(n+1);
          .                   c->d_cur = c->d_fst;
 32,064,600 ( 0.04%)          c->d_lst = c->d_fst+n+1;
136,274,550 ( 0.15%)          for (Actor** d_fst_iter = d_fst; d_fst_iter != d_cur; d_fst_iter++) {
          .                     ptrdiff_t m;
          .                     Actor* a = static_cast<Actor*>(Support::ptrsplit(*d_fst_iter,m));
 32,064,600 ( 0.04%)            if (a->prev())
 48,096,900 ( 0.05%)              *(c->d_cur++) = Actor::cast(static_cast<ActorLink*>
          .                                                   (Support::ptrjoin(a->prev(),m)));
          .                   }
          .                 }
          .               }
          .           
          .               // Update variables without indexing structure
 16,032,308 ( 0.02%)      VarImp<NoIdxVarImpConf>* x =
          .                 static_cast<VarImp<NoIdxVarImpConf>*>(c->pc.c.vars_noidx);
278,544,448 ( 0.31%)      while (x != nullptr) {
          .                 VarImp<NoIdxVarImpConf>* n = x->next();
254,495,986 ( 0.28%)        x->b.base = nullptr; x->u.idx[0] = 0;
          .                 if (sizeof(ActorLink**) > sizeof(unsigned int))
          .                   *(1+&x->u.idx[0]) = 0;
          .                 x = n;
          .               }
          .               // Update variables with indexing structure
          .               c->update(static_cast<ActorLink**>(c->mm.subscriptions()));
          .           
          .               // Re-establish prev links (reset forwarding information)
          .               {
 16,032,308 ( 0.02%)        ActorLink* p_a = &pl;
          .                 ActorLink* c_a = p_a->next();
          .                 // First update propagators and advisors
 81,033,776 ( 0.09%)        while (c_a != &pl) {
          .                   Propagator* p = Propagator::cast(c_a);
 48,751,098 ( 0.05%)          if (p->u.advisors != nullptr) {
          .                     ActorLink* a = p->u.advisors;
          .                     p->u.advisors = nullptr;
          .                     do {
          .                       a->prev(p); a = a->next();
          .                     } while (a != nullptr);
          .                   }
          .                   c_a->prev(p_a); p_a = c_a; c_a = c_a->next();
          .                 }
          .               }
          .               {
 16,032,308 ( 0.02%)        ActorLink* p_a = &bl;
          .                 ActorLink* c_a = p_a->next();
          .                 // Update branchers
 64,129,212 ( 0.07%)        while (c_a != &bl) {
          .                   c_a->prev(p_a); p_a = c_a; c_a = c_a->next();
          .                 }
          .               }
          .           
          .               // Reset links for local objects
 40,080,770 ( 0.04%)      for (ActorLink* l = c->pc.c.local; l != nullptr; l = l->next())
          .                 l->prev(nullptr);
          .           
          .               // Initialize propagator queue
136,274,618 ( 0.15%)      c->pc.p.active = &c->pc.p.queue[0]-1;
          .               for (int i=0; i<=PropCost::AC_MAX; i++)
112,226,156 ( 0.13%)        c->pc.p.queue[i].init();
          .               // Copy propagation only data
 24,048,462 ( 0.03%)      c->pc.p.n_sub  = pc.p.n_sub;
 16,032,308 ( 0.02%)      c->pc.p.bid_sc = pc.p.bid_sc;
          .           
          .               // Reset execution information
          .               c->pc.p.vti.other(); pc.p.vti.other();
          .           
          .               return c;
 72,145,386 ( 0.08%)    }
          .           
          .             void
          .             Space::constrain(const Space&) {
          .             }
          .           
          .             bool
     81,932 ( 0.00%)    Space::master(const MetaInfo& mi) {
     40,966 ( 0.00%)      switch (mi.type()) {
          .               case MetaInfo::RESTART:
     40,966 ( 0.00%)        if (mi.last() != nullptr)
    163,864 ( 0.00%)          constrain(*mi.last());
  2,560,488 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/flatzinc.cpp:Gecode::FlatZinc::FlatZincSpace::constrain(Gecode::Space const&) (20,483x)
    163,864 ( 0.00%)        mi.nogoods().post(*this);
  1,066,017 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/search/seq/path.hpp:Gecode::Search::Seq::Path<Gecode::Search::NoTraceRecorder>::post(Gecode::Space&) const (20,483x)
          .                 // Perform a restart even if a solution has been found
          .                 return true;
          .               case MetaInfo::PORTFOLIO:
          .                 // Kill all branchers
          .                 BrancherGroup::all.kill(*this);
          .                 return true;
          .               default: GECODE_NEVER;
          .                 return true;
          .               }
    122,898 ( 0.00%)    }
          .           
          .             bool
          .             Space::slave(const MetaInfo&) {
          .               return true;
          .             }
          .           
          .           
          .             void
-- line 869 ----------------------------------------
-- line 893 ----------------------------------------
          .               e << id();
          .             }
          .           
          .             bool
          .             NGL::notice(void) const {
          .               return false;
          .             }
          .           
     20,483 ( 0.00%)    NGL::~NGL(void) {
     20,483 ( 0.00%)    }
          .           
          .           
          .             /*
          .              * Groups
          .              */
          .           
          .             Group Group::all(GROUPID_ALL);
          .             Group Group::def(GROUPID_DEF);
-- line 910 ----------------------------------------
-- line 914 ----------------------------------------
          .           
          .             BrancherGroup BrancherGroup::all(GROUPID_ALL);
          .             BrancherGroup BrancherGroup::def(GROUPID_DEF);
          .           
          .             unsigned int Group::next = GROUPID_DEF+1;
          .             Support::Mutex Group::m;
          .           
          .           
         20 ( 0.00%)    Group::Group(void) {
          .               {
          .                 Support::Lock l(m);
         20 ( 0.00%)        gid = next++;
          .               }
          8 ( 0.00%)      if (gid == GROUPID_MAX)
          .                 throw TooManyGroups("Group::Group");
         16 ( 0.00%)    }
          .           
          .           
          .             PropagatorGroup&
          .             PropagatorGroup::move(Space& home, PropagatorGroup g) {
          .               if ((id() != GROUPID_ALL) && (id() != g.id()))
          .                 for (Space::Propagators ps(home); ps(); ++ps)
          .                   if (g.in(ps.propagator().group()))
          .                     ps.propagator().group(*this);
-- line 937 ----------------------------------------
-- line 948 ----------------------------------------
          .                   return *this;
          .                 }
          .               throw UnknownPropagator("PropagatorGroup::move");
          .               GECODE_NEVER;
          .               return *this;
          .             }
          .           
          .             unsigned int
          6 ( 0.00%)    PropagatorGroup::size(Space& home) const {
          4 ( 0.00%)      if (home.failed())
          4 ( 0.00%)        return 0;
          .               unsigned int n=0;
         12 ( 0.00%)      for (Space::Propagators ps(home); ps(); ++ps)
          .                 if (in(ps.propagator().group()))
          6 ( 0.00%)          n++;
          .               return n;
          6 ( 0.00%)    }
          .           
          .             void
          .             PropagatorGroup::kill(Space& home) {
          .               if (home.failed())
          .                 return;
          .               Space::Propagators ps(home);
          .               while (ps()) {
          .                 Propagator& p = ps.propagator();
-- line 972 ----------------------------------------
-- line 1050 ----------------------------------------
          .                 Brancher& b = bs.brancher();
          .                 ++bs;
          .                 if (in(b.group()))
          .                   home.kill(b);
          .               }
          .             }
          .           
          .           
          8 ( 0.00%)  }
          .           
          .           // STATISTICS: kernel-core

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/gecode/int/var-imp/int.cpp
--------------------------------------------------------------------------------
Ir                     

-- line 32 ----------------------------------------
            .            */
            .           
            .           #include <gecode/int.hh>
            .           
            .           namespace Gecode { namespace Int {
            .           
            .             forceinline bool
            .             IntVarImp::closer_min(int n) const {
    2,263,512 ( 0.00%)      unsigned int l = static_cast<unsigned int>(n - dom.min());
    2,263,512 ( 0.00%)      unsigned int r = static_cast<unsigned int>(dom.max() - n);
            .               return l < r;
            .             }
            .           
            .             int
            .             IntVarImp::med(void) const {
            .               // Computes the median
            .               if (fst() == nullptr)
            .                 return (dom.min()+dom.max())/2 - ((dom.min()+dom.max())%2 < 0 ? 1 : 0);
-- line 49 ----------------------------------------
-- line 79 ----------------------------------------
            .             }
            .           
            .             /*
            .              * "Standard" tell operations
            .              *
            .              */
            .           
            .             ModEvent
  357,596,540 ( 0.40%)    IntVarImp::lq_full(Space& home, int m) {
            .               assert((m >= dom.min()) && (m <= dom.max()));
            .               int old_max = dom.max();
            .               ModEvent me = ME_INT_BND;
   51,085,220 ( 0.06%)      if (range()) { // Is already range...
            .                 dom.max(m);
   30,034,624 ( 0.03%)        if (assigned()) me = ME_INT_VAL;
   21,050,596 ( 0.02%)      } else if (m < fst()->next(nullptr)->min()) { // Becomes range...
            .                 dom.max(std::min(m,fst()->max()));
            .                 fst()->dispose(home,nullptr,lst());
    3,922,278 ( 0.00%)        fst(nullptr); holes = 0;
    7,844,556 ( 0.01%)        if (assigned()) me = ME_INT_VAL;
            .               } else { // Stays non-range...
   13,206,040 ( 0.01%)        RangeList* n = nullptr;
            .                 RangeList* c = lst();
    6,603,020 ( 0.01%)        unsigned int h = 0;
   16,610,350 ( 0.02%)        while (m < c->min()) {
            .                   RangeList* p = c->prev(n); c->fix(n);
    5,106,465 ( 0.01%)          h += (c->min() - p->max() - 1);
            .                   n=c; c=p;
            .                 }
    6,603,020 ( 0.01%)        holes -= h;
            .                 int max_c = std::min(m,c->max());
            .                 dom.max(max_c); c->max(max_c);
   13,206,040 ( 0.01%)        if (c != lst()) {
            .                   n->dispose(home,lst());
            .                   c->next(n,nullptr); lst(c);
            .                 }
            .               }
   54,482,450 ( 0.06%)      IntDelta d(dom.max()+1,old_max);
            .               return notify(home,me,d);
  280,968,710 ( 0.31%)    }
            .           
            .             ModEvent
  151,552,898 ( 0.17%)    IntVarImp::gq_full(Space& home, int m) {
            .               assert((m >= dom.min()) && (m <= dom.max()));
            .               int old_min = dom.min();
            .               ModEvent me = ME_INT_BND;
   21,650,414 ( 0.02%)      if (range()) { // Is already range...
            .                 dom.min(m);
   20,743,612 ( 0.02%)        if (assigned()) me = ME_INT_VAL;
      906,802 ( 0.00%)      } else if (m > lst()->prev(nullptr)->max()) { // Becomes range...
            .                 dom.min(std::max(m,lst()->min()));
            .                 fst()->dispose(home,nullptr,lst());
      414,053 ( 0.00%)        fst(nullptr); holes = 0;
      828,106 ( 0.00%)        if (assigned()) me = ME_INT_VAL;
            .               } else { // Stays non-range...
       78,696 ( 0.00%)        RangeList* p = nullptr;
            .                 RangeList* c = fst();
       39,348 ( 0.00%)        unsigned int h = 0;
       92,370 ( 0.00%)        while (m > c->max()) {
            .                   RangeList* n = c->next(p); c->fix(n);
       18,232 ( 0.00%)          h += (n->min() - c->max() - 1);
            .                   p=c; c=n;
            .                 }
       39,348 ( 0.00%)        holes -= h;
            .                 int min_c = std::max(m,c->min());
            .                 dom.min(min_c); c->min(min_c);
       78,696 ( 0.00%)        if (c != fst()) {
            .                   fst()->dispose(home,p);
            .                   c->prev(p,nullptr); fst(c);
            .                 }
            .               }
   21,210,687 ( 0.02%)      IntDelta d(old_min,dom.min()-1);
            .               return notify(home,me,d);
  119,077,277 ( 0.13%)    }
            .           
            .             ModEvent
  317,399,043 ( 0.35%)    IntVarImp::eq_full(Space& home, int m) {
            .               dom.min(m); dom.max(m);
   48,830,622 ( 0.05%)      if (!range()) {
            .                 bool failed = false;
    6,189,434 ( 0.01%)        RangeList* p = nullptr;
            .                 RangeList* c = fst();
    6,259,626 ( 0.01%)        while (m > c->max()) {
            .                   RangeList* n=c->next(p); c->fix(n); p=c; c=n;
            .                 }
            .                 if (m < c->min())
            .                   failed = true;
   21,169,347 ( 0.02%)        while (c != nullptr) {
            .                   RangeList* n=c->next(p); c->fix(n); p=c; c=n;
            .                 }
            .                 assert(p == lst());
            .                 fst()->dispose(home,p);
    3,094,717 ( 0.00%)        fst(nullptr); holes = 0;
    6,189,434 ( 0.01%)        if (failed)
            .                   return fail(home);
            .               }
            .               IntDelta d;
            .               return notify(home,ME_INT_VAL,d);
  268,568,421 ( 0.30%)    }
            .           
            .             ModEvent
  491,538,960 ( 0.55%)    IntVarImp::nq_full(Space& home, int m) {
            .               assert(!((m < dom.min()) || (m > dom.max())));
            .               ModEvent me = ME_INT_DOM;
   61,442,370 ( 0.07%)      if (range()) {
   54,244,156 ( 0.06%)        if ((m == dom.min()) && (m == dom.max()))
            .                   return fail(home);
            .                 if (m == dom.min()) {
   11,911,491 ( 0.01%)          dom.min(m+1);
   23,822,982 ( 0.03%)          me = assigned() ? ME_INT_VAL : ME_INT_BND;
    6,578,248 ( 0.01%)        } else if (m == dom.max()) {
   23,287,888 ( 0.03%)          dom.max(m-1);
      368,990 ( 0.00%)          me = assigned() ? ME_INT_VAL : ME_INT_BND;
            .                 } else {
            .                   RangeList* f = new (home) RangeList(dom.min(),m-1);
   18,601,378 ( 0.02%)          RangeList* l = new (home) RangeList(m+1,dom.max());
            .                   f->prevnext(nullptr,l);
            .                   l->prevnext(f,nullptr);
    3,105,169 ( 0.00%)          fst(f); lst(l); holes = 1;
            .                 }
   31,031,168 ( 0.03%)      } else if (m < fst()->next(nullptr)->min()) { // Concerns the first range...
            .                 int f_max = fst()->max();
   21,774,426 ( 0.02%)        if (m > f_max)
   14,383,828 ( 0.02%)          return ME_INT_NONE;
            .                 int f_min = dom.min();
   36,838,594 ( 0.04%)        if ((m == f_min) && (m == f_max)) {
            .                   RangeList* f_next = fst()->next(nullptr);
            .                   dom.min(f_next->min());
    8,514,316 ( 0.01%)          if (f_next == lst()) { // Turns into range
            .                     // Works as at the ends there are only nullptr pointers
            .                     fst()->dispose(home,f_next);
    2,415,110 ( 0.00%)            fst(nullptr); holes = 0;
    7,304,520 ( 0.01%)            me = assigned() ? ME_INT_VAL : ME_INT_BND;
            .                   } else { // Remains non-range
            .                     f_next->prev(fst(),nullptr);
            .                     fst()->dispose(home); fst(f_next);
    5,526,144 ( 0.01%)            holes -= dom.min() - f_min - 1;
            .                     me = ME_INT_BND;
            .                   }
    6,549,852 ( 0.01%)        } else if (m == f_min) {
    3,274,926 ( 0.00%)          dom.min(m+1); fst()->min(m+1);
            .                   me = ME_INT_BND;
    6,710,258 ( 0.01%)        } else if (m == f_max) {
    1,828,551 ( 0.00%)          fst()->max(m-1); holes += 1;
            .                 } else {
            .                   // Create new hole
            .                   RangeList* f = new (home) RangeList(f_min,m-1);
            .                   f->prevnext(nullptr,fst());
    3,053,156 ( 0.00%)          fst()->min(m+1); fst()->prev(nullptr,f);
    1,526,578 ( 0.00%)          fst(f); holes += 1;
            .                 }
    9,256,742 ( 0.01%)      } else if (m > lst()->prev(nullptr)->max()) { // Concerns the last range...
            .                 int l_min = lst()->min();
    6,993,230 ( 0.01%)        if (m < l_min)
            .                   return ME_INT_NONE;
            .                 int l_max = dom.max();
    6,551,511 ( 0.01%)        if ((m == l_min) && (m == l_max)) {
            .                   RangeList* l_prev = lst()->prev(nullptr);
            .                   dom.max(l_prev->max());
       90,980 ( 0.00%)          if (l_prev == fst()) {
            .                     // Turns into range
            .                     l_prev->dispose(home,lst());
       27,040 ( 0.00%)            fst(nullptr); holes = 0;
       88,608 ( 0.00%)            me = assigned() ? ME_INT_VAL : ME_INT_BND;
            .                   } else { // Remains non-range
            .                     l_prev->next(lst(),nullptr);
            .                     lst()->dispose(home); lst(l_prev);
       55,350 ( 0.00%)            holes -= l_max - dom.max() - 1;
            .                     me = ME_INT_BND;
            .                   }
    3,938,334 ( 0.00%)        } else if (m == l_max) {
      353,365 ( 0.00%)          dom.max(m-1); lst()->max(m-1);
            .                   me = ME_INT_BND;
    6,195,520 ( 0.01%)        } else if (m == l_min) {
    1,481,958 ( 0.00%)          lst()->min(m+1); holes += 1;
            .                 } else { // Create new hole
            .                   RangeList* l = new (home) RangeList(m+1,l_max);
            .                   l->prevnext(lst(),nullptr);
    3,231,604 ( 0.00%)          lst()->max(m-1); lst()->next(nullptr,l);
    1,615,802 ( 0.00%)          lst(l); holes += 1;
            .                 }
            .               } else { // Concerns element in the middle of the list of ranges
            .                 RangeList* p;
            .                 RangeList* c;
            .                 RangeList* n;
    2,263,512 ( 0.00%)        if (closer_min(m)) {
            .                   assert(m > fst()->max());
            .                   p = nullptr;
            .                   c = fst();
            .                   do {
            .                     n=c->next(p); p=c; c=n;
    3,498,096 ( 0.00%)          } while (m > c->max());
            .                   if (m < c->min())
            .                     return ME_INT_NONE;
            .                   n=c->next(p);
            .                 } else {
            .                   assert(m < lst()->min());
            .                   n = nullptr;
            .                   c = lst();
            .                   do {
            .                     p=c->prev(n); n=c; c=p;
    1,028,928 ( 0.00%)          } while (m < c->min());
            .                   if (m > c->max())
            .                     return ME_INT_NONE;
            .                   p=c->prev(n);
            .                 }
            .                 assert((fst() != c) && (lst() != c));
            .                 assert((m >= c->min()) && (m <= c->max()));
    1,131,756 ( 0.00%)        holes += 1;
            .                 int c_min = c->min();
            .                 int c_max = c->max();
    4,008,606 ( 0.00%)        if ((c_min == m) && (c_max == m)) {
            .                   c->dispose(home);
            .                   p->next(c,n); n->prev(c,p);
      739,608 ( 0.00%)        } else if (c_min == m) {
      739,608 ( 0.00%)          c->min(m+1);
            .                 } else {
      518,418 ( 0.00%)          c->max(m-1);
      518,418 ( 0.00%)          if (c_max != m) {
      175,918 ( 0.00%)            RangeList* l = new (home) RangeList(m+1,c_max);
            .                     l->prevnext(c,n);
            .                     c->next(n,l);
            .                     n->prev(c,l);
            .                   }
            .                 }
            .               }
            .               IntDelta d(m,m);
            .               return notify(home,me,d);
  337,933,035 ( 0.38%)    }
            .           
            .           
            .           
            .             /*
            .              * Copying variables
            .              *
            .              */
            .           
            .             forceinline
            .             IntVarImp::IntVarImp(Space& home, IntVarImp& x)
            .               : IntVarImpBase(home,x), dom(x.dom.min(),x.dom.max()) {
  352,710,776 ( 0.39%)      holes = x.holes;
  352,710,776 ( 0.39%)      if (holes) {
    9,710,312 ( 0.01%)        int m = 1;
            .                 // Compute length
            .                 {
            .                   RangeList* s_p = x.fst();
            .                   RangeList* s_c = s_p->next(nullptr);
            .                   do {
   12,046,462 ( 0.01%)            m++;
    2,336,150 ( 0.00%)            RangeList* s_n = s_c->next(s_p); s_p=s_c; s_c=s_n;
   24,092,924 ( 0.03%)          } while (s_c != nullptr);
            .                 }
            .                 RangeList* d_c = home.alloc<RangeList>(m);
   19,420,624 ( 0.02%)        fst(d_c); lst(d_c+m-1);
            .                 d_c->min(x.fst()->min());
            .                 d_c->max(x.fst()->max());
            .                 d_c->prevnext(nullptr,nullptr);
            .                 RangeList* s_p = x.fst();
            .                 RangeList* s_c = s_p->next(nullptr);
            .                 do {
   24,092,924 ( 0.03%)          RangeList* d_n = d_c + 1;
            .                   d_c->next(nullptr,d_n);
            .                   d_n->prevnext(d_c,nullptr);
            .                   d_n->min(s_c->min()); d_n->max(s_c->max());
            .                   d_c = d_n;
    2,336,150 ( 0.00%)          RangeList* s_n=s_c->next(s_p); s_p=s_c; s_c=s_n;
   24,092,924 ( 0.03%)        } while (s_c != nullptr);
            .                 d_c->next(nullptr,nullptr);
            .               } else {
            .                 fst(nullptr);
            .               }
            .             }
            .           
            .             IntVarImp*
1,410,843,104 ( 1.58%)    IntVarImp::perform_copy(Space& home) {
            .               return new (home) IntVarImp(home,*this);
1,234,487,716 ( 1.38%)    }
            .           
            .             /*
            .              * Dependencies
            .              *
            .              */
            .             void
            .             IntVarImp::subscribe(Space& home, Propagator& p, PropCond pc,
    1,107,392 ( 0.00%)                         bool schedule) {
            .               IntVarImpBase::subscribe(home,p,pc,dom.min()==dom.max(),schedule);
      805,376 ( 0.00%)    }
            .           
            .             void
            .             IntVarImp::reschedule(Space& home, Propagator& p, PropCond pc) {
            .               IntVarImpBase::reschedule(home,p,pc,dom.min()==dom.max());
            .             }
            .           
            .             void
            .             IntVarImp::subscribe(Space& home, Advisor& a, bool fail) {
            .               IntVarImpBase::subscribe(home,a,dom.min()==dom.max(),fail);
            .             }
            .           
            3 ( 0.00%)  }}
            .           
            .           // STATISTICS: int-var

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 108 ----------------------------------------
          .           
          .             /*
          .              * Position information
          .              *
          .              */
          .             forceinline
          .             Pos::Pos(int p) : pos(p) {}
          .             forceinline
  8,043,681 ( 0.01%)    Pos::Pos(const Pos& p) : pos(p.pos) {}
          .           
          .             /*
          .              * Choice with position
          .              *
          .              */
          .             forceinline
          .             PosChoice::PosChoice(const Brancher& b, unsigned int a, const Pos& p)
          .               : Choice(b,a), _pos(p) {}
-- line 124 ----------------------------------------
-- line 132 ----------------------------------------
          .               e << _pos.pos;
          .             }
          .           
          .             template<class View, class Filter, int n>
          .             forceinline
          .             ViewBrancher<View,Filter,n>::ViewBrancher(Home home, ViewArray<View>& x0,
          .                                                       ViewSel<View>* vs0[n],
          .                                                       BranchFilter<Var> bf)
         12 ( 0.00%)      : Brancher(home), x(x0), start(0), f(bf) {
          .               for (int i=0; i<n; i++)
         12 ( 0.00%)        vs[i] = vs0[i];
          .               for (int i=0; i<n; i++)
         24 ( 0.00%)        if (f.notice() || vs[i]->notice()) {
          6 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view-sel.hpp:Gecode::ViewSelChoose<Gecode::ChooseMax, Gecode::Int::Branch::MeritAFCSize<Gecode::Int::IntView> >::notice() const (2x)
          .                   home.notice(*this,AP_DISPOSE,true);
          .                   break;
          .                 }
          .             }
          .           
          .             template<class View, class Filter, int n>
          .             forceinline
          .             ViewBrancher<View,Filter,n>::ViewBrancher(Space& home,
          .                                                       ViewBrancher<View,Filter,n>& vb)
 80,161,500 ( 0.09%)      : Brancher(home,vb), start(vb.start), f(vb.f) {
 48,096,900 ( 0.05%)      x.update(home,vb.x);
10,108,679,915 (11.31%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/data/array.hpp:Gecode::ViewArray<Gecode::Int::IntView>::update(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&) (16,032,300x)
          .               for (int i=0; i<n; i++)
136,274,550 ( 0.15%)        vs[i] = vb.vs[i]->copy(home);
217,617,148 ( 0.24%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view-sel.hpp:Gecode::ViewSelMax<Gecode::Int::Branch::MeritAFCSize<Gecode::Int::IntView> >::copy(Gecode::Space&) (8,016,150x)
          .             }
          .           
          .             template<class View, class Filter, int n>
          .             bool
  9,299,251 ( 0.01%)    ViewBrancher<View,Filter,n>::status(const Space& home) const {
 52,633,557 ( 0.06%)      for (int i=start; i < x.size(); i++)
 52,633,545 ( 0.06%)        if (!x[i].assigned() && f(home,x[i],i)) {
  9,299,247 ( 0.01%)          start = i;
 18,598,494 ( 0.02%)          return true;
          .                 }
          4 ( 0.00%)      return false;
          4 ( 0.00%)    }
          .           
          .             template<class View, class Filter, int n>
          .             inline Pos
          .             ViewBrancher<View,Filter,n>::pos(Space& home) {
          .               assert(!x[start].assigned());
          .               int s;
          .               if (f) {
          .                 if (n == 1) {
-- line 177 ----------------------------------------
-- line 185 ----------------------------------------
          .                     vs[i]->brk(home,x,ties,n_ties);
          .                   if (n_ties > 1)
          .                     s = vs[n-1]->select(home,x,ties,n_ties);
          .                   else
          .                     s = ties[0];
          .                 }
          .               } else {
          .                 if (n == 1) {
104,567,853 ( 0.12%)          s = vs[0]->select(home,x,start);
2,389,576,747 ( 2.67%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view-sel.hpp:Gecode::ViewSelChoose<Gecode::ChooseMax, Gecode::Int::Branch::MeritAFCSize<Gecode::Int::IntView> >::select(Gecode::Space&, Gecode::ViewArray<Gecode::Int::IntView>&, int) (8,043,681x)
          .                 } else {
          .                   Region r;
          .                   int* ties = r.alloc<int>(x.size()-start+1);
          .                   int n_ties;
          .                   vs[0]->ties(home,x,start,ties,n_ties);
          .                   for (int i=1; (i < n-1) && (n_ties > 1); i++)
          .                     vs[i]->brk(home,x,ties,n_ties);
          .                   if (n_ties > 1)
-- line 201 ----------------------------------------
-- line 206 ----------------------------------------
          .               }
          .               Pos p(s);
          .               return p;
          .             }
          .           
          .             template<class View, class Filter, int n>
          .             forceinline View
          .             ViewBrancher<View,Filter,n>::view(const Pos& p) const {
 35,588,562 ( 0.04%)      return x[p.pos];
          .             }
          .           
          .             template<class View, class Filter, int n>
          .             forceinline size_t
          .             ViewBrancher<View,Filter,n>::dispose(Space& home) {
          .               for (int i=0; i<n; i++)
120,242,175 ( 0.13%)        if (f.notice() || vs[i]->notice()) {
 24,048,435 ( 0.03%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view-sel.hpp:Gecode::ViewSelChoose<Gecode::ChooseMax, Gecode::Int::Branch::MeritAFCSize<Gecode::Int::IntView> >::notice() const (8,016,145x)
          .                   home.ignore(*this,AP_DISPOSE,true);
          .                   break;
          .                 }
          .               for (int i=0; i<n; i++)
 96,193,740 ( 0.11%)        vs[i]->dispose(home);
 16,032,290 ( 0.02%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view-sel.hpp:Gecode::ViewSelChoose<Gecode::ChooseMax, Gecode::Int::Branch::MeritAFCSize<Gecode::Int::IntView> >::dispose(Gecode::Space&) (8,016,145x)
          .               (void) Brancher::dispose(home);
          .               return sizeof(ViewBrancher<View,Filter,n>);
          .             }
          .           
          .           }
          .           
          .           // STATISTICS: kernel-branch

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/var-type.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 499 ----------------------------------------
          .             }
          .             forceinline bool
          .             IntVarImpConf::med_update(Gecode::ModEventDelta& med, Gecode::ModEvent me) {
          .               switch (me) {
          .               case ME_INT_NONE:
          .                 return false;
          .               case ME_INT_VAL:
          .                 {
166,502,352 ( 0.19%)          Gecode::ModEventDelta med_int = med & med_mask;
111,001,568 ( 0.12%)          if (med_int == (ME_INT_VAL << med_fst))
          .                     return false;
 34,537,441 ( 0.04%)          med ^= med_int;
 69,074,882 ( 0.08%)          med ^= ME_INT_VAL << med_fst;
          .                   break;
          .                 }
          .               case ME_INT_BND:
          .                 {
          .                   static const Gecode::ModEvent me_c = (
          .                     ((ME_INT_NONE ^ ME_INT_BND ) <<  0) |
          .                     ((ME_INT_VAL  ^ ME_INT_VAL ) <<  4) |
          .                     ((ME_INT_BND  ^ ME_INT_BND ) <<  8) |
          .                     ((ME_INT_DOM  ^ ME_INT_BND ) << 12)
          .                   );
 94,241,897 ( 0.11%)          Gecode::ModEvent me_o = (med & med_mask) >> med_fst;
481,269,854 ( 0.54%)          Gecode::ModEvent me_n = (me_c >> (me_o << 2)) & (med_mask >> med_fst);
188,483,794 ( 0.21%)          if (me_n == 0)
          .                     return false;
 46,426,116 ( 0.05%)          med ^= me_n << med_fst;
          .                   break;
          .                 }
          .               case ME_INT_DOM:
          .                 {
      7,752 ( 0.00%)          Gecode::ModEventDelta med_int = med & med_mask;
     15,504 ( 0.00%)          if (med_int != 0)
          .                     return false;
     14,062 ( 0.00%)          med |= ME_INT_DOM << med_fst;
          .                   break;
          .                 }
          .               default: GECODE_NEVER;
          .               }
          .               return true;
          .             }
          .           
          .           }}
-- line 542 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/align.h
--------------------------------------------------------------------------------
Ir                   

-- line 56 ----------------------------------------
          .            *  @param __space   Size of the buffer pointed to by @a __ptr.
          .            *  @return the updated pointer if the aligned storage fits, otherwise nullptr.
          .            *
          .            *  @ingroup memory
          .            */
          .           inline void*
          .           align(size_t __align, size_t __size, void*& __ptr, size_t& __space) noexcept
          .           {
 82,568,476 ( 0.09%)    if (__space < __size)
          .               return nullptr;
          .             const auto __intptr = reinterpret_cast<uintptr_t>(__ptr);
 74,566,196 ( 0.08%)    const auto __aligned = (__intptr - 1u + __align) & -__align;
 74,566,196 ( 0.08%)    const auto __diff = __aligned - __intptr;
111,849,298 ( 0.13%)    if (__diff > (__space - __size))
          .               return nullptr;
          .             else
          .               {
 74,566,196 ( 0.08%)        __space -= __diff;
          .                 return __ptr = reinterpret_cast<void*>(__aligned);
          .               }
          .           }
          .           
          .           #if __cplusplus > 201703L
          .           #define __cpp_lib_assume_aligned 201811L
          .             /** @brief Inform the compiler that a pointer is aligned.
          .              *
-- line 81 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/support/sort.hpp
--------------------------------------------------------------------------------
Ir                  

-- line 35 ----------------------------------------
         .           #include <climits>
         .           
         .           namespace Gecode { namespace Support {
         .           
         .             /// Exchange elements according to order
         .             template<class Type, class Less>
         .             forceinline void
         .             exchange(Type &a, Type &b, Less &less) {
    19,767 ( 0.00%)      if (less(b,a)) std::swap(a,b);
         .             }
         .           
         .             /// Perform quicksort only for more elements
         .             int const QuickSortCutoff = 20;
         .           
         .             /// Static stack for quicksort
         .             template<class Type>
         .             class QuickSortStack {
-- line 51 ----------------------------------------
-- line 65 ----------------------------------------
         .               void push(Type* l, Type* r);
         .               /// Pop two positions \a l and \a r
         .               void pop(Type*& l, Type*& r);
         .             };
         .           
         .             template<class Type>
         .             forceinline
         .             QuickSortStack<Type>::QuickSortStack(void) : tos(&stack[0]) {
         5 ( 0.00%)      *(tos++) = nullptr;
         1 ( 0.00%)    }
         .           
         .             template<class Type>
         .             forceinline bool
         .             QuickSortStack<Type>::empty(void) const {
         1 ( 0.00%)      return *(tos-1) == nullptr;
         .             }
         .           
         .             template<class Type>
         .             forceinline void
         .             QuickSortStack<Type>::push(Type* l, Type* r) {
         .               *(tos++) = l; *(tos++) = r;
         .             }
         .           
-- line 87 ----------------------------------------
-- line 90 ----------------------------------------
         .             QuickSortStack<Type>::pop(Type*& l, Type*& r) {
         .               r = *(--tos); l = *(--tos);
         .             }
         .           
         .             /// Standard insertion sort
         .             template<class Type, class Less>
         .             forceinline void
         .             insertion(Type* l, Type* r, Less &less) {
    14,046 ( 0.00%)      for (Type* i = r; i > l; i--)
     4,967 ( 0.00%)        exchange(*(i-1),*i,less);
    13,272 ( 0.00%)      for (Type* i = l+2; i <= r; i++) {
         .                 Type* j = i;
     3,541 ( 0.00%)        Type v = *i;
34,583,987 ( 0.04%)        while (less(v,*(j-1))) {
     1,052 ( 0.00%)          *j = *(j-1); j--;
         .                 }
     1,836 ( 0.00%)        *j = v;
         .               }
         .             }
         .           
         .             /// Standard partioning
         .             template<class Type, class Less>
         .             forceinline Type*
         .             partition(Type* l, Type* r, Less &less) {
         .               Type* i = l-1;
         .               Type* j = r;
         1 ( 0.00%)      Type v = *r;
         .               while (true) {
         3 ( 0.00%)        while (less(*(++i),v)) {}
        96 ( 0.00%)        while (less(v,*(--j))) if (j == l) break;
         2 ( 0.00%)          if (i >= j) break;
         .                   std::swap(*i,*j);
         .               }
         .               std::swap(*i,*r);
         .               return i;
         .             }
         .           
         .             /// Standard quick sort
         .             template<class Type, class Less>
         .             inline void
         .             quicksort(Type* l, Type* r, Less &less) {
         .               QuickSortStack<Type> s;
         .               while (true) {
        11 ( 0.00%)        std::swap(*(l+((r-l) >> 1)),*(r-1));
         .                 exchange(*l,*(r-1),less);
         .                 exchange(*l,*r,less);
         .                 exchange(*(r-1),*r,less);
         2 ( 0.00%)        Type* i = partition(l+1,r-1,less);
         6 ( 0.00%)        if (i-l > r-i) {
         .                   if (r-i > QuickSortCutoff) {
         .                     s.push(l,i-1); l=i+1; continue;
         .                   }
         .                   if (i-l > QuickSortCutoff) {
         .                     r=i-1; continue;
         .                   }
         .                 } else {
         2 ( 0.00%)          if (i-l > QuickSortCutoff) {
         .                     s.push(i+1,r); r=i-1; continue;
         .                   }
         2 ( 0.00%)          if (r-i > QuickSortCutoff) {
         2 ( 0.00%)            l=i+1; continue;
         .                   }
         .                 }
         2 ( 0.00%)        if (s.empty())
         .                   break;
         .                 s.pop(l,r);
         .               }
         .             }
         .           
         .             /// Comparison class for sorting using \a <
         .             template<class Type>
         .             class Less {
-- line 161 ----------------------------------------
-- line 223 ----------------------------------------
         .              * The algorithm is largely based on the following book:
         .              * Robert Sedgewick, Algorithms in C++, 3rd edition, 1998, Addison Wesley.
         .              *
         .              * \ingroup FuncSupport
         .              */
         .             template<class Type, class Less>
         .             forceinline void
         .             quicksort(Type* x, int n, Less &l) {
     2,463 ( 0.00%)      if (n < 2)
         .                 return;
         .               assert(!l(x[0],x[0]));
     3,280 ( 0.00%)      if (n > QuickSortCutoff)
 9,788,587 ( 0.01%)        quicksort(x,x+n-1,l);
         .               insertion(x,x+n-1,l);
         .             }
         .           
         .             /**
         .              * \brief Quicksort
         .              *
         .              * Sorts with quicksort the \a n first elements of array \a x according
         .              * to the order \a <.
-- line 243 ----------------------------------------
-- line 245 ----------------------------------------
         .              * The algorithm is largely based on the following book:
         .              * Robert Sedgewick, Algorithms in C++, 3rd edition, 1998, Addison Wesley.
         .              *
         .              * \ingroup FuncSupport
         .              */
         .             template<class Type>
         .             forceinline void
         .             quicksort(Type* x, int n) {
         2 ( 0.00%)      if (n < 2)
         .                 return;
         .               Less<Type> l;
         .               assert(!l(x[0],x[0]));
         2 ( 0.00%)      if (n > QuickSortCutoff)
         2 ( 0.00%)        quicksort(x,x+n-1,l);
         .               insertion(x,x+n-1,l);
         .             }
         .           
         .           }}
         .           
         .           // STATISTICS: support-any

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/x86_64-linux-gnu/c++/11/bits/gthr-default.h
--------------------------------------------------------------------------------
Ir                   

-- line 741 ----------------------------------------
          .             else
          .               return 0;
          .           }
          .           
          .           static inline int
          .           __gthread_mutex_lock (__gthread_mutex_t *__mutex)
          .           {
          .             if (__gthread_active_p ())
152,331,100 ( 0.17%)      return __gthrw_(pthread_mutex_lock) (__mutex);
      1,156 ( 0.00%)  => ???:0x0000000004de0510 (4x)
          .             else
          .               return 0;
          .           }
          .           
          .           static inline int
          .           __gthread_mutex_trylock (__gthread_mutex_t *__mutex)
          .           {
          .             if (__gthread_active_p ())
-- line 757 ----------------------------------------
-- line 771 ----------------------------------------
          .               return 0;
          .           }
          .           #endif
          .           
          .           static inline int
          .           __gthread_mutex_unlock (__gthread_mutex_t *__mutex)
          .           {
          .             if (__gthread_active_p ())
160,347,241 ( 0.18%)      return __gthrw_(pthread_mutex_unlock) (__mutex);
      1,105 ( 0.00%)  => ???:0x0000000004de0410 (2x)
          .             else
          .               return 0;
          .           }
          .           
          .           #if !defined( PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP) \
          .             || defined(_GTHREAD_USE_RECURSIVE_MUTEX_INIT_FUNC)
          .           static inline int
          .           __gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)
-- line 787 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view-sel.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 414 ----------------------------------------
          .               return home.ralloc(s);
          .             }
          .           
          .           
          .           
          .             template<class View>
          .             forceinline
          .             ViewSelNone<View>::ViewSelNone(Space& home, const VarBranch<Var>& vb)
          4 ( 0.00%)        : ViewSel<View>(home,vb) {}
          .             template<class View>
          .             forceinline
          .             ViewSelNone<View>::ViewSelNone(Space& home, ViewSelNone<View>& vs)
 16,032,300 ( 0.02%)      : ViewSel<View>(home,vs) {}
          .             template<class View>
          .             int
          .             ViewSelNone<View>::select(Space&, ViewArray<View>&, int s) {
          .               return s;
          .             }
          .             template<class View>
          .             int
          .             ViewSelNone<View>::select(Space&, ViewArray<View>&, int s,
-- line 434 ----------------------------------------
-- line 551 ----------------------------------------
          .             ChooseMax::operator ()(Val a, Val b) const {
          .               return a > b;
          .             }
          .           
          .           
          .             template<class Choose, class Merit>
          .             forceinline
          .             ViewSelChoose<Choose,Merit>::ViewSelChoose(Space& home, const VarBranch<Var>& vb)
          4 ( 0.00%)      : ViewSel<View>(home,vb), m(home,vb) {}
          .           
          .             template<class Choose, class Merit>
          .             forceinline
          .             ViewSelChoose<Choose,Merit>::ViewSelChoose(Space& home,
          .                                                        ViewSelChoose<Choose,Merit>& vs)
 16,032,300 ( 0.02%)      : ViewSel<View>(home,vs), m(home,vs.m) {}
          .           
          .             template<class Choose, class Merit>
          .             int
 80,436,800 ( 0.09%)    ViewSelChoose<Choose,Merit>::select(Space& home, ViewArray<View>& x, int s) {
          .               // Consider x[s] as the so-far best view
          .               int b_i = s;
          .               Val b_m = m(home,x[s],s);
          .               // Scan all non-assigned views from s+1 onwards
331,346,385 ( 0.37%)      for (int i=s+1; i<x.size(); i++)
204,810,228 ( 0.23%)        if (!x[i].assigned()) {
          .                   Val mxi = m(home,x[i],i);
106,658,576 ( 0.12%)          if (c(mxi,b_m)) {
          .                     b_i = i; b_m = mxi;
          .                   }
          .                 }
          .               return b_i;
 48,262,078 ( 0.05%)    }
          .           
          .             template<class Choose, class Merit>
          .             int
          .             ViewSelChoose<Choose,Merit>::select(Space& home, ViewArray<View>& x, int s,
          .                                                 BrancherFilter<View>& f) {
          .               // Consider x[s] as the so-far best view
          .               int b_i = s;
          .               Val b_m = m(home,x[s],s);
-- line 590 ----------------------------------------
-- line 681 ----------------------------------------
          .                   b_i = ties[i]; b_m = mxi;
          .                 }
          .               }
          .               return b_i;
          .             }
          .           
          .             template<class Choose, class Merit>
          .             bool
  8,016,147 ( 0.01%)    ViewSelChoose<Choose,Merit>::notice(void) const {
          .               return m.notice();
 16,032,294 ( 0.02%)    }
          .           
          .             template<class Choose, class Merit>
          .             void
  8,016,145 ( 0.01%)    ViewSelChoose<Choose,Merit>::dispose(Space& home) {
          .               m.dispose(home);
  8,016,145 ( 0.01%)    }
          .           
          .           
          .             template<class Choose, class Merit>
          .             forceinline
          .             ViewSelChooseTbl<Choose,Merit>::ViewSelChooseTbl(Space& home,
          .                                                              const VarBranch<Var>& vb)
          .               : ViewSelChoose<Choose,Merit>(home,vb), tbl(vb.tbl()) {
          .               if (!tbl())
-- line 705 ----------------------------------------
-- line 875 ----------------------------------------
          .               return new (home) ViewSelMinTbl<Merit>(home,*this);
          .             }
          .           
          .           
          .           
          .             template<class Merit>
          .             forceinline
          .             ViewSelMax<Merit>::ViewSelMax(Space& home, const VarBranch<Var>& vb)
          4 ( 0.00%)      : ViewSelChoose<ChooseMax,Merit>(home,vb) {}
          .           
          .             template<class Merit>
          .             forceinline
          .             ViewSelMax<Merit>::ViewSelMax(Space& home, ViewSelMax<Merit>& vs)
 16,032,300 ( 0.02%)      : ViewSelChoose<ChooseMax,Merit>(home,vs) {}
          .           
          .             template<class Merit>
          .             ViewSel<typename ViewSelMax<Merit>::View>*
 48,096,900 ( 0.05%)    ViewSelMax<Merit>::copy(Space& home) {
          .               return new (home) ViewSelMax<Merit>(home,*this);
 32,064,600 ( 0.04%)    }
          .           
          .           
          .           
          .             template<class Merit>
          .             forceinline
          .             ViewSelMaxTbl<Merit>::ViewSelMaxTbl(Space& home, const VarBranch<Var>& vb)
          .               : ViewSelChooseTbl<ChooseMax,Merit>(home,vb) {}
          .           
-- line 902 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/int/var-imp/delta.hpp
--------------------------------------------------------------------------------
Ir                  

-- line 30 ----------------------------------------
         .            *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
         .            *
         .            */
         .           
         .           namespace Gecode { namespace Int {
         .           
         .             forceinline
         .             IntDelta::IntDelta(void)
48,830,622 ( 0.05%)      : _min(1), _max(0) {}
         .             forceinline
         .             IntDelta::IntDelta(int min, int max)
87,362,362 ( 0.10%)      : _min(min), _max(max) {}
         .             forceinline
         .             IntDelta::IntDelta(int min)
         .               : _min(min) {}
         .             forceinline int
         .             IntDelta::min(void) const {
         .               return _min;
         .             }
         .             forceinline int
-- line 49 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/support/marked-pointer.hpp
--------------------------------------------------------------------------------
Ir                   

-- line 47 ----------------------------------------
          .             void* funmark(void* p);
          .             /// Split possibly marked pointer \a p into mark \a m and unmarked pointer
          .             void* ptrsplit(void* p, ptrdiff_t& m);
          .             /// Join unmarked pointer \a p and \a m into marked pointer
          .             void* ptrjoin(void* p, ptrdiff_t m);
          .           
          .             forceinline bool
          .             marked(void* p) {
574,917,816 ( 0.64%)      return (reinterpret_cast<ptrdiff_t>(p) & 1) != 0;
          .             }
          .             forceinline void*
          .             mark(void* p) {
          .               assert(!marked(p));
352,710,776 ( 0.39%)      return reinterpret_cast<void*>(reinterpret_cast<ptrdiff_t>(p)+1);
          .             }
          .             forceinline void*
          .             unmark(void* p) {
          .               assert(marked(p));
581,060,871 ( 0.65%)      return reinterpret_cast<void*>(reinterpret_cast<ptrdiff_t>(p)-1);
          .             }
          .             forceinline void*
          .             fmark(void* p) {
          .               return reinterpret_cast<void*>(reinterpret_cast<ptrdiff_t>(p)|1);
          .             }
          .             forceinline void*
          .             funmark(void* p) {
153,597,942 ( 0.17%)      return reinterpret_cast<void*>(reinterpret_cast<ptrdiff_t>(p)&
          .                                              ~static_cast<ptrdiff_t>(1));
          .             }
          .             forceinline void*
          .             ptrsplit(void* p, ptrdiff_t& m) {
 16,032,300 ( 0.02%)      ptrdiff_t mp = reinterpret_cast<ptrdiff_t>(p);
 16,032,300 ( 0.02%)      m = mp & 1;
 32,064,600 ( 0.04%)      return reinterpret_cast<void*>(mp & ~static_cast<ptrdiff_t>(1));
          .             }
          .             forceinline void*
          .             ptrjoin(void* p, ptrdiff_t m) {
 16,032,300 ( 0.02%)      return reinterpret_cast<void*>(reinterpret_cast<ptrdiff_t>(p) | m);
          .             }
          .           
          .           }}
          .           
          .           // STATISTICS: support-any

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/gecode/kernel/memory/region.cpp
--------------------------------------------------------------------------------
Ir                   

-- line 30 ----------------------------------------
          .            *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
          .            *
          .            */
          .           
          .           #include <gecode/kernel.hh>
          .           
          .           namespace Gecode {
          .           
         15 ( 0.00%)    Region::Pool::Pool(void)
          6 ( 0.00%)      : c(new Chunk), n_c(2U) {
          6 ( 0.00%)      c->next = new Chunk; c->next->next = nullptr;
         12 ( 0.00%)    }
          .             Region::Chunk*
112,232,547 ( 0.13%)    Region::Pool::chunk(void) {
          .               Chunk* n;
          .               {
          .                 Support::Lock l(m);
 48,099,663 ( 0.05%)        if (c != nullptr) {
          .                   assert(n_c > 0U);
 48,099,663 ( 0.05%)          n = c; c = c->next; n_c--;
          .                 } else {
          .                   n = new Region::Chunk;
          .                 }
          .                 n->reset();
          .               }
          .               return n;
112,232,547 ( 0.13%)    }
          .             void
 96,199,326 ( 0.11%)    Region::Pool::chunk(Chunk* u) {
          .               Support::Lock l(m);
 32,066,442 ( 0.04%)      if (n_c == Kernel::MemoryConfig::n_hc_cache) {
          .                 delete u;
          .               } else {
 48,099,663 ( 0.05%)        u->next = c; c = u;
 16,033,221 ( 0.02%)        n_c++;
          .               }
 48,099,663 ( 0.05%)    }
          5 ( 0.00%)    Region::Pool::~Pool(void) {
          .               Support::Lock l(m);
          .               // If that were the case there would be a memory leak!
          .               assert(c != nullptr);
          .               do {
          6 ( 0.00%)        Chunk* n=c->next;
          .                 delete c;
          2 ( 0.00%)        c=n;
          4 ( 0.00%)      } while (c != nullptr);
          3 ( 0.00%)    }
          .           
128,265,768 ( 0.14%)    Region::Pool& Region::pool(void) {
128,265,798 ( 0.14%)      thread_local static Region::Pool _p;
448,931,645 ( 0.50%)  => ???:0x0000000004954a10 (32,066,442x)
      5,448 ( 0.00%)  => ???:0x0000000004954a00 (3x)
      3,385 ( 0.00%)  => ???:0x0000000004954a60 (3x)
 96,199,326 ( 0.11%)      return _p;
448,930,188 ( 0.50%)  => ???:0x0000000004954a10 (32,066,442x)
128,265,768 ( 0.14%)    }
          .           
          .             void*
          .             Region::heap_alloc(size_t s) {
          .               void* p = heap.ralloc(s);
          .               if (hi == nullptr) {
          .                 hi = p;
          .                 assert(!Support::marked(hi));
          .               } else if (!Support::marked(hi)) {
-- line 89 ----------------------------------------
-- line 117 ----------------------------------------
          .                 for (unsigned int i=0U; i<h->n; i++)
          .                   heap.rfree(h->blocks[i]);
          .                 heap.rfree(h);
          .               } else {
          .                 heap.rfree(hi);
          .               }
          .             }
          .           
          3 ( 0.00%)  }
          .           
          .           // STATISTICS: kernel-memory

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dexter/master-thesis/gecode-dexter/./gecode/search/seq/path.hpp
--------------------------------------------------------------------------------
Ir                  

-- line 39 ----------------------------------------
         .              */
         .             template<class Tracer>
         .             forceinline
         .             Path<Tracer>::Edge::Edge(void) {}
         .           
         .             template<class Tracer>
         .             forceinline
         .             Path<Tracer>::Edge::Edge(Space* s, Space* c, unsigned int nid)
24,131,043 ( 0.03%)      : _space(c), _alt(0), _choice(s->choice()), _nid(nid) {}
2,464,657,750 ( 2.76%)  => ???:0x0000000004df1820 (5,256,983x)
         .           
         .             template<class Tracer>
         .             forceinline Space*
 2,441,715 ( 0.00%)    Path<Tracer>::Edge::space(void) const {
 9,234,194 ( 0.01%)      return _space;
         .             }
         .             template<class Tracer>
         .             forceinline void
         .             Path<Tracer>::Edge::space(Space* s) {
10,436,882 ( 0.01%)      _space = s;
         .             }
         .           
         .             template<class Tracer>
         .             forceinline unsigned int
         .             Path<Tracer>::Edge::alt(void) const {
         .               return _alt;
         .             }
         .             template<class Tracer>
-- line 65 ----------------------------------------
-- line 70 ----------------------------------------
         .             template<class Tracer>
         .             forceinline bool
         .             Path<Tracer>::Edge::leftmost(void) const {
         .               return _alt == 0;
         .             }
         .             template<class Tracer>
         .             forceinline bool
         .             Path<Tracer>::Edge::rightmost(void) const {
60,738,678 ( 0.07%)      return _alt+1 >= _choice->alternatives();
         .             }
         .             template<class Tracer>
         .             forceinline bool
         .             Path<Tracer>::Edge::lao(void) const {
         .               return _alt >= _choice->alternatives();
         .             }
         .             template<class Tracer>
         .             forceinline void
         .             Path<Tracer>::Edge::next(void) {
11,001,489 ( 0.01%)      _alt++;
         .             }
         .           
         .             template<class Tracer>
         .             forceinline const Choice*
         .             Path<Tracer>::Edge::choice(void) const {
         .               return _choice;
         .             }
         .           
-- line 96 ----------------------------------------
-- line 98 ----------------------------------------
         .             forceinline unsigned int
         .             Path<Tracer>::Edge::nid(void) const {
         .               return _nid;
         .             }
         .           
         .             template<class Tracer>
         .             forceinline void
         .             Path<Tracer>::Edge::dispose(void) {
16,264,846 ( 0.02%)      delete _space;
44,030,375 ( 0.05%)  => /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/flatzinc.cpp:Gecode::FlatZinc::FlatZincSpace::~FlatZincSpace() (88,750x)
40,218,365 ( 0.04%)      delete _choice;
546,131,623 ( 0.61%)  => /home/dexter/master-thesis/gecode-dexter/./gecode/kernel/branch/view-val.hpp:Gecode::PosValChoice<int>::~PosValChoice() (5,102,365x)
         .             }
         .           
         .           
         .           
         .             /*
         .              * Depth-first stack with recomputation
         .              *
         .              */
         .           
         .             template<class Tracer>
         .             forceinline
         .             Path<Tracer>::Path(unsigned int l)
         6 ( 0.00%)      : ds(heap), _ngdl(l) {}
         .           
         .             template<class Tracer>
         .             forceinline unsigned int
         .             Path<Tracer>::ngdl(void) const {
         .               return _ngdl;
         .             }
         .           
         .             template<class Tracer>
-- line 128 ----------------------------------------
-- line 129 ----------------------------------------
         .             forceinline void
         .             Path<Tracer>::ngdl(unsigned int l) {
         .               _ngdl = l;
         .             }
         .           
         .             template<class Tracer>
         .             forceinline const Choice*
         .             Path<Tracer>::push(Worker& stat, Space* s, Space* c, unsigned int nid) {
40,156,950 ( 0.04%)      if (!ds.empty() && ds.top().lao()) {
         .                 // Topmost stack entry was LAO -> reuse
         .                 ds.pop().dispose();
         .               }
         .               Edge sn(s,c,nid);
         .               ds.push(sn);
         .               stat.stack_depth(static_cast<unsigned long int>(ds.entries()));
         .               return sn.choice();
         .             }
         .           
         .             template<class Tracer>
         .             forceinline void
         .             Path<Tracer>::next(void) {
27,780,939 ( 0.03%)      while (!ds.empty())
27,780,936 ( 0.03%)        if (ds.top().rightmost()) {
         .                   ds.pop().dispose();
         .                 } else {
         .                   ds.top().next();
 7,927,392 ( 0.01%)          return;
         .                 }
         .             }
         .           
         .             template<class Tracer>
         .             forceinline typename Path<Tracer>::Edge&
         .             Path<Tracer>::top(void) const {
         .               assert(!ds.empty());
         .               return ds.top();
-- line 163 ----------------------------------------
-- line 174 ----------------------------------------
         .             Path<Tracer>::commit(Space* s, int i) const {
         .               const Edge& n = ds[i];
         .               s->commit(*n.choice(),n.alt());
         .             }
         .           
         .             template<class Tracer>
         .             forceinline int
         .             Path<Tracer>::lc(void) const {
25,015,047 ( 0.03%)      int l = ds.entries()-1;
62,128,449 ( 0.07%)      while (ds[l].space() == nullptr)
11,594,291 ( 0.01%)        l--;
         .               return l;
         .             }
         .           
         .             template<class Tracer>
         .             forceinline int
         .             Path<Tracer>::entries(void) const {
         .               return ds.entries();
         .             }
-- line 192 ----------------------------------------
-- line 202 ----------------------------------------
         .                   unsigned int fa = (i != l) ? top.alt() + 1 : top.alt();
         .                   for (unsigned int a = fa; a < top.choice()->alternatives(); a++) {
         .                     SearchTracer::EdgeInfo ei(t.wid(),top.nid(),a);
         .                     t.skip(ei);
         .                   }
         .                   ds.pop().dispose();
         .                 }
         .               } else {
        10 ( 0.00%)        for (int i=l; i<n; i++)
         .                   ds.pop().dispose();
         .               }
         .               assert(ds.entries() == l);
         .             }
         .           
         .             template<class Tracer>
         .             inline void
         .             Path<Tracer>::reset(void) {
   350,186 ( 0.00%)      while (!ds.empty())
         .                 ds.pop().dispose();
         .             }
         .           
         .             template<class Tracer>
         .             forceinline Space*
         .             Path<Tracer>::recompute(unsigned int& d, unsigned int a_d, Worker& stat,
         .                                     Tracer& t) {
         .               assert(!ds.empty());
         .               // Recompute space according to path
         .               // Also say distance to copy (d == 0) requires immediate copying
         .           
         .               // Check for LAO
13,469,790 ( 0.02%)      if ((ds.top().space() != nullptr) && ds.top().rightmost()) {
         .                 Space* s = ds.top().space();
         .                 s->commit(*ds.top().choice(),ds.top().alt());
         .                 assert(ds.entries()-1 == lc());
         .                 ds.top().space(nullptr);
         .                 // Mark as reusable
 3,229,362 ( 0.00%)        if (static_cast<unsigned int>(ds.entries()) > ngdl())
         .                   ds.top().next();
 1,614,681 ( 0.00%)        d = 0;
         .                 return s;
         .               }
         .               // General case for recomputation
         .               int l = lc();             // Position of last clone
         .               int n = ds.entries();     // Number of stack entries
         .               // New distance, if no adaptive recomputation
10,516,599 ( 0.01%)      d = static_cast<unsigned int>(n - l);
         .           
         .               Space* s = ds[l].space()->clone(); // Last clone
         .           
10,516,599 ( 0.01%)      if (d < a_d) {
         .                 // No adaptive recomputation
         .                 for (int i=l; i<n; i++)
         .                   commit(s,i);
         .               } else {
10,516,599 ( 0.01%)        int m = l + static_cast<int>(d >> 1); // Middle between copy and top
         .                 int i = l; // To iterate over all entries
         .                 // Recompute up to middle
47,722,587 ( 0.05%)        for (; i<m; i++ )
         .                   commit(s,i);
         .                 // Skip over all rightmost branches
54,034,969 ( 0.06%)        for (; (i<n) && ds[i].rightmost(); i++)
         .                   commit(s,i);
         .                 // Is there any point to make a copy?
 7,011,066 ( 0.01%)        if (i<n-1) {
         .                   // Propagate to fixpoint
 1,981,635 ( 0.00%)          SpaceStatus ss = s->status(stat);
754,119,758 ( 0.84%)  => ???:0x0000000004df1910 (660,545x)
         .                   /*
         .                    * Again, the space might already propagate to failure (due to
         .                    * weakly monotonic propagators).
         .                    */
 1,321,090 ( 0.00%)          if (ss == SS_FAILED) {
         .                     // s must be deleted as it is not on the stack
         .                     delete s;
         .                     stat.fail++;
         .                     unwind(i,t);
         .                     return nullptr;
         .                   }
         .                   ds[i].space(s->clone());
 2,642,180 ( 0.00%)          d = static_cast<unsigned int>(n-i);
         .                 }
         .                 // Finally do the remaining commits
11,474,425 ( 0.01%)        for (; i<n; i++)
         .                   commit(s,i);
         .               }
         .               return s;
         .             }
         .           
         .             template<class Tracer>
         .             forceinline Space*
         .             Path<Tracer>::recompute(unsigned int& d, unsigned int a_d, Worker& stat,
         .                                     const Space& best, int& mark,
         .                                     Tracer& t) {
         .               assert(!ds.empty());
         .               // Recompute space according to path
         .               // Also say distance to copy (d == 0) requires immediate copying
         .           
         .               // Check for LAO
 8,492,222 ( 0.01%)      if ((ds.top().space() != nullptr) && ds.top().rightmost()) {
         .                 Space* s = ds.top().space();
         .                 s->commit(*ds.top().choice(),ds.top().alt());
         .                 assert(ds.entries()-1 == lc());
 4,378,242 ( 0.00%)        if (mark > ds.entries()-1) {
         .                   mark = ds.entries()-1;
         .                   s->constrain(best);
         .                 }
         .                 ds.top().space(nullptr);
         .                 // Mark as reusable
 2,918,828 ( 0.00%)        if (static_cast<unsigned int>(ds.entries()) > ngdl())
         .                   ds.top().next();
 1,459,414 ( 0.00%)        d = 0;
         .                 return s;
         .               }
         .               // General case for recomputation
         .               int l = lc();             // Position of last clone
         .               int n = ds.entries();     // Number of stack entries
         .               // New distance, if no adaptive recomputation
 3,981,849 ( 0.00%)      d = static_cast<unsigned int>(n - l);
         .           
         .               Space* s = ds[l].space(); // Last clone
         .           
 2,654,566 ( 0.00%)      if (l < mark) {
         2 ( 0.00%)        mark = l;
         8 ( 0.00%)        s->constrain(best);
     2,067 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/flatzinc.cpp:Gecode::FlatZinc::FlatZincSpace::constrain(Gecode::Space const&) (2x)
         .                 // The space on the stack could be failed now as an additional
         .                 // constraint might have been added.
        10 ( 0.00%)        if (s->status(stat) == SS_FAILED) {
     3,547 ( 0.00%)  => ???:0x0000000004df1910 (2x)
         .                   // s does not need deletion as it is on the stack (unwind does this)
         .                   stat.fail++;
         .                   unwind(l,t);
         .                   return nullptr;
         .                 }
         .                 // It is important to replace the space on the stack with the
         .                 // copy: a copy might be much smaller due to flushed caches
         .                 // of propagators
         .                 Space* c = s->clone();
         .                 ds[l].space(c);
         .               } else {
         .                 s = s->clone();
         .               }
         .           
 3,981,849 ( 0.00%)      if (d < a_d) {
         .                 // No adaptive recomputation
         .                 for (int i=l; i<n; i++)
         .                   commit(s,i);
         .               } else {
 3,981,849 ( 0.00%)        int m = l + static_cast<int>(d >> 1); // Middle between copy and top
         .                 int i = l;            // To iterate over all entries
         .                 // Recompute up to middle
16,025,074 ( 0.02%)        for (; i<m; i++ )
         .                   commit(s,i);
         .                 // Skip over all rightmost branches
12,741,649 ( 0.01%)        for (; (i<n) && ds[i].rightmost(); i++)
         .                   commit(s,i);
         .                 // Is there any point to make a copy?
 2,654,566 ( 0.00%)        if (i<n-1) {
         .                   // Propagate to fixpoint
 1,662,147 ( 0.00%)          SpaceStatus ss = s->status(stat);
2,615,894,376 ( 2.93%)  => ???:0x0000000004df1910 (554,049x)
         .                   /*
         .                    * Again, the space might already propagate to failure
         .                    *
         .                    * This can be for two reasons:
         .                    *  - constrain is true, so we fail
         .                    *  - the space has weakly monotonic propagators
         .                    */
 1,108,098 ( 0.00%)          if (ss == SS_FAILED) {
         .                     // s must be deleted as it is not on the stack
         5 ( 0.00%)            delete s;
     2,279 ( 0.00%)  => /home/dexter/master-thesis/gecode-dexter/gecode/flatzinc/flatzinc.cpp:Gecode::FlatZinc::FlatZincSpace::~FlatZincSpace() (1x)
         1 ( 0.00%)            stat.fail++;
         .                     unwind(i,t);
         .                     return nullptr;
         .                   }
         .                   ds[i].space(s->clone());
 2,216,192 ( 0.00%)          d = static_cast<unsigned int>(n-i);
         .                 }
         .                 // Finally do the remaining commits
 9,496,138 ( 0.01%)        for (; i<n; i++)
         .                   commit(s,i);
         .               }
         .               return s;
         .             }
         .           
         .             template<class Tracer>
         .             void
   286,762 ( 0.00%)    Path<Tracer>::post(Space& home) const {
         .               GECODE_ES_FAIL(NoGoodsProp::post(home,*this));
   225,313 ( 0.00%)    }
         .           
         .           }}}
         .           
         .           // STATISTICS: search-seq

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./elf/../sysdeps/x86_64/tls_get_addr.S
  ./malloc/./malloc/arena.c
  ./malloc/./malloc/malloc.c
  ./nptl/./nptl/pthread_mutex_lock.c
  ./nptl/./nptl/pthread_mutex_unlock.c
  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

--------------------------------------------------------------------------------
Ir                      
--------------------------------------------------------------------------------
78,801,781,361 (88.13%)  events annotated

